{"version":3,"sources":["../src/index.ts","../src/abstract-relation.ts","../src/abstract-relation-helpers.ts","../src/cache-manager.ts","../src/goal-manager.ts"],"sourcesContent":["import type { Goal, Term } from \"logic\";\nimport { getDefaultLogger, type Logger, or } from \"logic\";\nimport { AbstractRelation } from \"./abstract-relation.js\";\nimport { DefaultGoalManager } from \"./goal-manager.js\";\nimport type {\n\tAbstractRelationConfig,\n\tDataStore,\n\tGoalManager,\n\tRelationOptions,\n} from \"./types.js\";\n\nexport type { RestDataStoreConfig } from \"./types.js\";\n/**\n * Factory for creating abstract relation systems\n * This is the main entry point for the abstract data layer\n */\n// Make AbstractRelationFactory generic over options type\nexport class AbstractRelationFactory<\n\tTOptions extends RelationOptions = RelationOptions,\n> {\n\tprivate goalManager: GoalManager;\n\tprivate logger: Logger;\n\tprivate config: AbstractRelationConfig;\n\n\tconstructor(\n\t\tprivate dataStore: DataStore,\n\t\tlogger?: Logger,\n\t\tconfig?: AbstractRelationConfig,\n\t) {\n\t\tthis.logger = logger ?? getDefaultLogger();\n\t\tthis.goalManager = new DefaultGoalManager();\n\t\tthis.config = config ?? {};\n\t}\n\n\t/**\n\t * Get the appropriate relation identifier based on datastore type and options\n\t */\n\tprivate getRelationIdentifier(table: string, options?: TOptions): string {\n\t\t// For REST APIs, prefer pathTemplate as the identifier since it's more meaningful\n\t\tif (this.dataStore.type === \"rest\") {\n\t\t\tconst restOptions = options as any;\n\t\t\tif (restOptions?.pathTemplate) {\n\t\t\t\treturn restOptions.pathTemplate;\n\t\t\t}\n\t\t}\n\t\t// For SQL or when no pathTemplate, use table name\n\t\treturn table;\n\t}\n\n\t/**\n\t * Create a regular relation for a table\n\t */\n\tcreateRelation(table: string, options?: TOptions) {\n\t\t// For REST APIs, use pathTemplate as identifier if available, otherwise use table name\n\t\t// For SQL APIs, always use table name\n\t\tconst relationIdentifier = this.getRelationIdentifier(table, options);\n\n\t\tconst relation = new AbstractRelation<TOptions>(\n\t\t\tthis.dataStore,\n\t\t\tthis.goalManager,\n\t\t\trelationIdentifier,\n\t\t\tthis.logger,\n\t\t\toptions,\n\t\t\tthis.config,\n\t\t);\n\n\t\treturn (queryObj: Record<string, Term>): Goal => {\n\t\t\treturn relation.createGoal(queryObj);\n\t\t};\n\t}\n\n\t/**\n\t * Create a symmetric relation for bidirectional queries\n\t */\n\tcreateSymmetricRelation(\n\t\ttable: string,\n\t\tkeys: [string, string],\n\t\toptions?: RelationOptions,\n\t) {\n\t\tconst relationIdentifier = this.getRelationIdentifier(\n\t\t\ttable,\n\t\t\toptions as TOptions,\n\t\t);\n\n\t\tconst relation = new AbstractRelation(\n\t\t\tthis.dataStore,\n\t\t\tthis.goalManager,\n\t\t\trelationIdentifier,\n\t\t\tthis.logger,\n\t\t\toptions,\n\t\t\tthis.config,\n\t\t);\n\n\t\treturn (queryObj: Record<string, Term>): Goal => {\n\t\t\t// Create both directions of the query\n\t\t\tconst queryObjSwapped = {\n\t\t\t\t[keys[0]]: queryObj[keys[1]],\n\t\t\t\t[keys[1]]: queryObj[keys[0]],\n\t\t\t};\n\n\t\t\treturn or(\n\t\t\t\trelation.createGoal(queryObj),\n\t\t\t\trelation.createGoal(queryObjSwapped),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Get debugging information\n\t */\n\tgetQueries(): string[] {\n\t\treturn this.goalManager.getQueries();\n\t}\n\n\tclearQueries(): void {\n\t\tthis.goalManager.clearQueries();\n\t}\n\n\tgetQueryCount(): number {\n\t\treturn this.goalManager.getQueryCount();\n\t}\n\n\t/**\n\t * Access the underlying data store\n\t */\n\tgetDataStore(): DataStore {\n\t\treturn this.dataStore;\n\t}\n\n\t/**\n\t * Close the data store connection\n\t */\n\tasync close(): Promise<void> {\n\t\tif (this.dataStore.close) {\n\t\t\tawait this.dataStore.close();\n\t\t}\n\t}\n}\n\n/**\n * Main factory function - creates an abstract relation system\n */\nexport function createAbstractRelationSystem<\n\tTOptions extends RelationOptions = RelationOptions,\n>(dataStore: DataStore, logger?: Logger, config?: AbstractRelationConfig) {\n\tconst factory = new AbstractRelationFactory<TOptions>(\n\t\tdataStore,\n\t\tlogger,\n\t\tconfig,\n\t);\n\n\treturn {\n\t\trel: factory.createRelation.bind(factory),\n\t\trelSym: factory.createSymmetricRelation?.bind(factory),\n\t\tgetQueries: factory.getQueries.bind(factory),\n\t\tclearQueries: factory.clearQueries.bind(factory),\n\t\tgetQueryCount: factory.getQueryCount.bind(factory),\n\t\tgetDataStore: factory.getDataStore.bind(factory),\n\t\tclose: factory.close.bind(factory),\n\t};\n}\n\nexport { AbstractRelation } from \"./abstract-relation.js\";\nexport { DefaultCacheManager } from \"./cache-manager.js\";\nexport { DefaultGoalManager } from \"./goal-manager.js\";\n// Re-export types and implementations\nexport type {\n\tAbstractRelationConfig,\n\tDataRow,\n\tDataStore,\n\tGoalManager,\n\tQueryParams,\n\tRelationOptions,\n\tWhereCondition,\n} from \"./types.js\";\n","import type { Goal, Observable, Subst, Term } from \"logic\";\nimport {\n  GOAL_GROUP_ALL_GOALS,\n  GOAL_GROUP_CONJ_GOALS,\n  getDefaultLogger,\n  isVar,\n  type Logger,\n  SimpleObservable,\n  walk,\n} from \"logic\";\nimport {\n  buildWhereConditions,\n  canMergeQueries,\n  collectAllWhereClauses,\n  collectColumnsFromGoals,\n  collectWhereClausesFromSubstitutions,\n  couldBenefitFromCache,\n  unifyRowWithQuery,\n} from \"./abstract-relation-helpers.js\";\nimport { DefaultCacheManager } from \"./cache-manager.js\";\nimport type {\n  AbstractRelationConfig,\n  CacheManager,\n  DataRow,\n  DataStore,\n  GoalManager,\n  GoalRecord,\n  QueryParams,\n  RelationOptions,\n} from \"./types.js\";\n\n// WeakMap to link observables to their goal IDs\nconst observableToGoalId = new WeakMap<Observable<any>, number>();\n\n// Default batch configuration\nconst DEFAULT_BATCH_SIZE = 100;\nconst DEFAULT_DEBOUNCE_MS = 50;\n\n/**\n * Abstract relation engine that handles batching, caching, and query optimization\n * Works with any DataStore implementation\n */\n// Make AbstractRelation generic over options type\nexport class AbstractRelation<\n  TOptions extends RelationOptions = RelationOptions,\n> {\n  private logger: Logger;\n  private cacheManager: CacheManager;\n  private config: Required<AbstractRelationConfig>;\n\n  constructor(\n    private dataStore: DataStore,\n    private goalManager: GoalManager,\n    private relationIdentifier: string,\n    logger?: Logger,\n    private _options?: TOptions,\n    config?: AbstractRelationConfig,\n  ) {\n    this.logger = logger ?? getDefaultLogger();\n    this.cacheManager = config?.cacheManager ?? new DefaultCacheManager();\n\n    // Set default config\n    this.config = {\n      batchSize: config?.batchSize ?? DEFAULT_BATCH_SIZE,\n      debounceMs: config?.debounceMs ?? DEFAULT_DEBOUNCE_MS,\n      enableCaching: config?.enableCaching ?? true,\n      enableQueryMerging: config?.enableQueryMerging ?? true,\n      cacheManager: this.cacheManager,\n    };\n  }\n\n  /**\n   * Create a goal for this relation\n   */\n  createGoal(queryObj: Record<string, Term>): Goal {\n    const goalId = this.goalManager.getNextGoalId();\n\n    this.logger.log(\"GOAL_CREATED\", {\n      goalId,\n      relationIdentifier: this.relationIdentifier,\n      queryObj,\n      dataStore: this.dataStore.type,\n    });\n\n    // Register goal\n    this.goalManager.addGoal(\n      goalId,\n      this.relationIdentifier,\n      queryObj,\n      undefined,\n      this._options,\n    );\n\n    // Create the goal function\n    const goalFunction = (input$: Observable<Subst>) => {\n      return new SimpleObservable<Subst>((observer) => {\n        let cancelled = false;\n        let batchIndex = 0;\n        let inputComplete = false;\n\n        this.logger.log(\"GOAL_STARTED\", {\n          goalId,\n          relationIdentifier: this.relationIdentifier,\n          queryObj,\n          dataStore: this.dataStore.type,\n        });\n\n        // Create batch processor\n        const batchProcessor = this.createBatchProcessor({\n          batchSize: this.config.batchSize,\n          debounceMs: this.config.debounceMs,\n          onFlush: async (batch) => {\n            if (cancelled) return;\n\n            this.logger.log(\"FLUSH_BATCH\", {\n              goalId,\n              batchIndex,\n              batchSize: batch.length,\n              dataStore: this.dataStore.type,\n            });\n\n            // Process batch\n            const rows = await this.executeQueryForSubstitutions(\n              goalId,\n              queryObj,\n              batch as Subst[],\n            );\n\n            // Find cache-compatible goals\n            const representativeSubst = batch[0];\n            const myGoal = this.goalManager.getGoalById(goalId);\n            let cacheCompatibleGoals: GoalRecord[] = [];\n\n            if (myGoal && representativeSubst) {\n              const relatedGoals = await this.findRelatedGoals(\n                myGoal,\n                representativeSubst as Subst,\n              );\n              cacheCompatibleGoals = this.findCacheCompatibleGoals(\n                myGoal,\n                relatedGoals,\n                representativeSubst as Subst,\n              );\n            }\n\n            await this.processFreshRows(\n              goalId,\n              queryObj,\n              rows,\n              batch as Subst[],\n              observer,\n              cacheCompatibleGoals,\n            );\n\n            batchIndex++;\n          },\n        });\n\n        // Subscribe to input stream\n        let active = 0;\n        let completed = false;\n        const subscription = input$.subscribe({\n          next: async (subst: Subst) => {\n            if (cancelled) return;\n            active++;\n\n            this.logger.log(\"GOAL_NEXT\", {\n              goalId,\n              batchIndex,\n              inputComplete,\n              dataStore: this.dataStore.type,\n            });\n\n            // Check cache first if caching is enabled\n            if (this.config.enableCaching) {\n              const cachedRows = this.cacheManager.get(goalId, subst);\n              if (cachedRows) {\n                this.logger.log(\"CACHE_HIT_IMMEDIATE\", {\n                  goalId,\n                  rowCount: cachedRows.length,\n                  relationIdentifier: this.relationIdentifier,\n                  dataStore: this.dataStore.type,\n                });\n\n                await this.processCachedRows(\n                  goalId,\n                  queryObj,\n                  cachedRows,\n                  subst,\n                  observer,\n                );\n                active--;\n                if (completed && active === 0) observer.complete?.();\n\n                return; // Don't add to batch if we had a cache hit\n              }\n            }\n\n            // Cache miss - add to batch\n            batchProcessor.addItem(subst);\n            this.logger.log(\"CACHE_MISS_TO_BATCH\", {\n              goalId,\n              inputComplete,\n              dataStore: this.dataStore.type,\n            });\n            active--;\n            if (completed && active === 0) observer.complete?.();\n          },\n          error: (err: any) => {\n            if (!cancelled) observer.error?.(err);\n          },\n          complete: () => {\n            this.logger.log(\"UPSTREAM_GOAL_COMPLETE\", {\n              goalId,\n              batchIndex,\n              inputComplete,\n              cancelled,\n              dataStore: this.dataStore.type,\n            });\n\n            inputComplete = true;\n            batchProcessor\n              .complete()\n              .then(() => {\n                this.logger.log(\"GOAL_COMPLETE\", {\n                  goalId,\n                  batchIndex,\n                  inputComplete,\n                  cancelled,\n                  dataStore: this.dataStore.type,\n                });\n\n                completed = true;\n                if (completed && active === 0) observer.complete?.();\n              })\n              .catch((e) => {\n                console.error(e);\n                // Silently handle completion errors to prevent unhandled rejections\n                completed = true;\n                if (completed && active === 0) observer.complete?.();\n              });\n          },\n        });\n\n        return () => {\n          this.logger.log(\"GOAL_CANCELLED\", {\n            goalId,\n            batchIndex,\n            inputComplete,\n            cancelled,\n            dataStore: this.dataStore.type,\n          });\n          cancelled = true;\n          batchProcessor.cancel();\n          subscription.unsubscribe?.();\n        };\n      });\n    };\n\n    // Set up goal metadata\n    const displayName = `${this.dataStore.type.toUpperCase()}_${this.relationIdentifier}_${goalId}`;\n    goalFunction.displayName = displayName;\n    observableToGoalId.set(goalFunction as unknown as Observable<any>, goalId);\n\n    return goalFunction;\n  }\n\n  /**\n   * Execute query for a set of substitutions\n   */\n  private async executeQueryForSubstitutions(\n    goalId: number,\n    queryObj: Record<string, Term>,\n    substitutions: Subst[],\n  ): Promise<DataRow[]> {\n    if (substitutions.length === 0) return [];\n\n    this.logger.log(\"EXECUTING_UNIFIED_QUERY\", {\n      goalId,\n      substitutionCount: substitutions.length,\n      relationIdentifier: this.relationIdentifier,\n      dataStore: this.dataStore.type,\n    });\n\n    const myGoal = this.goalManager.getGoalById(goalId);\n    if (!myGoal) return [];\n\n    const representativeSubst = substitutions[0];\n\n    // Find related goals for merging and caching\n    const relatedGoals = await this.findRelatedGoals(\n      myGoal,\n      representativeSubst,\n    );\n    const mergeCompatibleGoals = this.config.enableQueryMerging\n      ? this.findMergeCompatibleGoals(myGoal, relatedGoals)\n      : [];\n    const cacheCompatibleGoals = this.config.enableCaching\n      ? this.findCacheCompatibleGoals(myGoal, relatedGoals, representativeSubst)\n      : [];\n\n    // Build and execute query\n    return await this.buildAndExecuteQuery(\n      goalId,\n      queryObj,\n      substitutions,\n      mergeCompatibleGoals,\n      cacheCompatibleGoals,\n    );\n  }\n\n  /**\n   * Build query parameters and execute via data store\n   */\n  private async buildAndExecuteQuery(\n    goalId: number,\n    queryObj: Record<string, Term>,\n    substitutions: Subst[],\n    mergeCompatibleGoals: GoalRecord[],\n    cacheCompatibleGoals: GoalRecord[],\n  ): Promise<DataRow[]> {\n    // Collect WHERE clauses from substitutions\n    const whereClauses = await this.collectWhereClausesFromSubstitutions(\n      queryObj,\n      substitutions,\n    );\n\n    // If we have merge-compatible goals, include their WHERE clauses too\n    if (mergeCompatibleGoals.length > 0) {\n      const myGoal = this.goalManager.getGoalById(goalId);\n      if (myGoal) {\n        const allGoalsToMerge = [myGoal, ...mergeCompatibleGoals];\n        const goalWhereClauses = await this.collectAllWhereClauses(\n          allGoalsToMerge,\n          substitutions[0],\n        );\n\n        // Merge goal WHERE clauses with substitution WHERE clauses\n        for (const [col, values] of Object.entries(goalWhereClauses)) {\n          if (whereClauses[col]) {\n            for (const value of values) {\n              whereClauses[col].add(value);\n            }\n          } else {\n            whereClauses[col] = new Set(values);\n          }\n        }\n      }\n    }\n\n    // Collect columns from all relevant goals\n    const columns = this.collectColumnsFromGoals(\n      queryObj,\n      cacheCompatibleGoals,\n      mergeCompatibleGoals,\n    );\n\n    // Convert to data store format\n    const whereConditions = this.buildWhereConditions(whereClauses);\n\n    const mergeCompatibleGoalIds = mergeCompatibleGoals\n      .map((x) => x.goalId)\n      .join(\",\");\n    const cacheCompatibleGoalIds = cacheCompatibleGoals\n      .map((x) => x.goalId)\n      .join(\",\");\n    const iffmt = (v: string | undefined, fn: (v: string) => string) =>\n      v ? fn(v) : \"\";\n    const annotatedLogQuery = (queryString: string) =>\n      this.goalManager.addQuery(\n        `G:${goalId}${iffmt(mergeCompatibleGoalIds, (v) => ` M:${v}`)}${iffmt(cacheCompatibleGoalIds, (v) => ` C:${v}`)} - ${queryString}`,\n      );\n\n    const queryParams: QueryParams = {\n      relationIdentifier: this.relationIdentifier,\n      selectColumns: columns.columns,\n      whereConditions,\n      relationOptions: this._options,\n      goalId,\n      logQuery: annotatedLogQuery,\n    };\n\n    // Execute via data store (it will handle query logging)\n    const rows = await this.dataStore.executeQuery(queryParams);\n\n    this.logger.log(\"DB_QUERY_EXECUTED\", {\n      goalId,\n      relationIdentifier: this.relationIdentifier,\n      rowCount: rows.length,\n      queryParams,\n      dataStore: this.dataStore.type,\n    });\n\n    return rows;\n  }\n\n  /**\n   * Find related goals for merging and caching\n   */\n  private async findRelatedGoals(\n    myGoal: GoalRecord,\n    s: Subst,\n  ): Promise<{ goal: GoalRecord; matchingIds: string[] }[]> {\n    // Get goal groups from substitution (matches current SQL implementation)\n    const innerGroupGoals = (s.get(GOAL_GROUP_CONJ_GOALS) as Goal[]) || [];\n    const outerGroupGoals = (s.get(GOAL_GROUP_ALL_GOALS) as Goal[]) || [];\n\n    // const goalsForCaching = outerGroupGoals.length > 0 ? outerGroupGoals : innerGroupGoals;\n    const goalsForCaching = outerGroupGoals;\n\n    if (goalsForCaching.length === 0) {\n      return [];\n    }\n\n    // Look up goal IDs for each goal function using the WeakMap\n    const otherGoalIds = goalsForCaching\n      .map((goalFn) =>\n        observableToGoalId.get(goalFn as unknown as Observable<any>),\n      )\n      .filter(\n        (goalId) => goalId !== undefined && goalId !== myGoal.goalId,\n      ) as number[];\n\n    // Get the goal records\n    const otherGoals = otherGoalIds\n      .map((goalId) => this.goalManager.getGoalById(goalId))\n      .filter((goal) => goal !== undefined) as GoalRecord[];\n\n    this.logger.log(\"FOUND_RELATED_GOALS\", {\n      myGoalId: myGoal.goalId,\n      myGoalQueryObj: myGoal.queryObj,\n      foundOtherGoalIds: otherGoalIds,\n      relatedGoals: otherGoals.map((g) => ({\n        goalId: g.goalId,\n        relationIdentifier: g.relationIdentifier,\n        queryObj: g.queryObj,\n      })),\n      dataStore: this.dataStore.type,\n    });\n\n    return otherGoals.map((goal) => ({\n      goal,\n      matchingIds: [], // Empty for now - could implement variable matching logic\n    }));\n  }\n\n  /**\n   * Find goals that are compatible for query merging\n   */\n  private findMergeCompatibleGoals(\n    myGoal: GoalRecord,\n    relatedGoals: { goal: GoalRecord; matchingIds: string[] }[],\n  ): GoalRecord[] {\n    const compatibleGoals: GoalRecord[] = [];\n    for (const { goal } of relatedGoals) {\n      if (\n        goal.relationIdentifier === myGoal.relationIdentifier &&\n        this.canMergeQueries(myGoal, goal)\n      ) {\n        compatibleGoals.push(goal);\n      }\n    }\n\n    this.logger.log(\"MERGE_COMPATIBILITY_CHECK\", {\n      myGoalId: myGoal.goalId,\n      candidateGoals: relatedGoals.map((g) => ({\n        goalId: g.goal.goalId,\n        queryObj: g.goal.queryObj,\n      })),\n      mergeCompatibleGoalIds: compatibleGoals.map((g) => g.goalId),\n      relationIdentifier: this.relationIdentifier,\n      dataStore: this.dataStore.type,\n    });\n\n    return compatibleGoals;\n  }\n\n  /**\n   * Find goals that are compatible for result caching\n   */\n  private findCacheCompatibleGoals(\n    myGoal: GoalRecord,\n    relatedGoals: { goal: GoalRecord; matchingIds: string[] }[],\n    subst: Subst,\n  ): GoalRecord[] {\n    const cacheBeneficiaryGoals: GoalRecord[] = [];\n    const candidateGoalsWithCompatibility = [];\n\n    for (const { goal } of relatedGoals) {\n      const isCompatible = this.couldBenefitFromCache(myGoal, goal, subst);\n\n      candidateGoalsWithCompatibility.push({\n        goalId: goal.goalId,\n        queryObj: goal.queryObj,\n        cacheCompatible: isCompatible,\n      });\n\n      if (isCompatible === \"match\") {\n        cacheBeneficiaryGoals.push(goal);\n      }\n    }\n\n    this.logger.log(\"CACHE_COMPATIBILITY_CHECK\", {\n      myGoalId: myGoal.goalId,\n      myGoalQueryObj: myGoal.queryObj,\n      candidateGoals: candidateGoalsWithCompatibility,\n      cacheCompatibleGoalIds: cacheBeneficiaryGoals.map((g) => g.goalId),\n      relationIdentifier: this.relationIdentifier,\n      dataStore: this.dataStore.type,\n    });\n\n    return cacheBeneficiaryGoals;\n  }\n\n  /**\n   * Process cached rows\n   */\n  private async processCachedRows(\n    goalId: number,\n    queryObj: Record<string, Term>,\n    cachedRows: DataRow[],\n    subst: Subst,\n    observer: any,\n  ): Promise<void> {\n    // Filter cached rows to match current substitution\n    const filteredRows = cachedRows.filter((row) => {\n      for (const [col, term] of Object.entries(queryObj)) {\n        const grounded = walk(term, subst);\n        if (!isVar(grounded) && row[col] !== grounded) {\n          return false;\n        }\n      }\n      return true;\n    });\n\n    this.logger.log(\"CACHE_ROWS_PROCESSED\", {\n      goalId,\n      originalCount: cachedRows.length,\n      filteredCount: filteredRows.length,\n      relationIdentifier: this.relationIdentifier,\n      dataStore: this.dataStore.type,\n    });\n\n    for (const row of filteredRows) {\n      const unifiedSubst = this.unifyRowWithQuery(\n        row,\n        queryObj,\n        new Map(subst),\n      );\n      if (unifiedSubst) {\n        observer.next(unifiedSubst);\n      }\n      await new Promise((resolve) => setTimeout(() => resolve(undefined), 0));\n    }\n  }\n\n  /**\n   * Process fresh query rows\n   */\n  private async processFreshRows(\n    goalId: number,\n    queryObj: Record<string, Term>,\n    rows: DataRow[],\n    substitutions: Subst[],\n    observer: any,\n    cacheCompatibleGoals: GoalRecord[],\n  ): Promise<void> {\n    for (const subst of substitutions) {\n      // Clear any existing cache for this goal\n      if (this.config.enableCaching) {\n        this.cacheManager.clear(goalId);\n      }\n\n      if (rows.length === 0) {\n        this.logger.log(\"DB_NO_ROWS\", {\n          goalId,\n          queryObj,\n          wasFromCache: false,\n          relationIdentifier: this.relationIdentifier,\n          dataStore: this.dataStore.type,\n        });\n        continue;\n      }\n\n      for (const row of rows) {\n        const unifiedSubst = this.unifyRowWithQuery(\n          row,\n          queryObj,\n          new Map(subst),\n        );\n        if (unifiedSubst) {\n          // Cache rows for compatible goals\n          if (this.config.enableCaching) {\n            for (const otherGoal of cacheCompatibleGoals) {\n              if (otherGoal.goalId !== goalId) {\n                this.cacheManager.set(otherGoal.goalId, unifiedSubst, rows, {\n                  fromGoalId: goalId,\n                });\n                this.logger.log(\"CACHED_FOR_OTHER_GOAL\", {\n                  myGoalId: goalId,\n                  otherGoalId: otherGoal.goalId,\n                  rowCount: rows.length,\n                  dataStore: this.dataStore.type,\n                });\n              }\n            }\n          }\n\n          this.logger.log(\"UNIFY_SUCCESS\", {\n            goalId,\n            queryObj,\n            row,\n            wasFromCache: false,\n            relationIdentifier: this.relationIdentifier,\n            dataStore: this.dataStore.type,\n          });\n\n          observer.next(unifiedSubst);\n          await new Promise((resolve) => setTimeout(resolve, 0));\n        } else {\n          this.logger.log(\"UNIFY_FAILURE\", {\n            goalId,\n            queryObj,\n            row,\n            wasFromCache: false,\n            relationIdentifier: this.relationIdentifier,\n            dataStore: this.dataStore.type,\n          });\n        }\n      }\n    }\n  }\n\n  // Helper method delegates\n  private couldBenefitFromCache = couldBenefitFromCache;\n  private canMergeQueries = canMergeQueries;\n  private collectWhereClausesFromSubstitutions =\n    collectWhereClausesFromSubstitutions;\n  private collectAllWhereClauses = collectAllWhereClauses;\n  private collectColumnsFromGoals = collectColumnsFromGoals;\n  private buildWhereConditions = buildWhereConditions;\n  private unifyRowWithQuery = unifyRowWithQuery;\n\n  /**\n   * Create a batch processor utility\n   */\n  private createBatchProcessor<T>(options: {\n    batchSize: number;\n    debounceMs: number;\n    onFlush: (batch: T[]) => Promise<void> | void;\n  }): {\n    addItem: (item: T) => void;\n    complete: () => Promise<void>;\n    cancel: () => void;\n  } {\n    let batch: T[] = [];\n    let debounceTimer: NodeJS.Timeout | null = null;\n    let flushingPromise: Promise<void> | null = null;\n    let cancelled = false;\n\n    const clearDebounce = (): void => {\n      if (debounceTimer) {\n        clearTimeout(debounceTimer);\n        debounceTimer = null;\n      }\n    };\n\n    const flushBatch = (): Promise<void> => {\n      clearDebounce();\n      if (flushingPromise) return flushingPromise;\n      if (batch.length === 0 || cancelled) return Promise.resolve();\n\n      const toFlush = batch;\n      batch = [];\n      flushingPromise = Promise.resolve(options.onFlush(toFlush)).finally(\n        () => {\n          flushingPromise = null;\n        },\n      );\n      return flushingPromise;\n    };\n\n    const addItem = (item: T): void => {\n      // if (cancelled) return;\n      batch.push(item);\n      if (batch.length >= options.batchSize) {\n        flushBatch();\n      } else {\n        clearDebounce();\n        debounceTimer = setTimeout(() => flushBatch(), options.debounceMs);\n      }\n    };\n\n    const complete = async (): Promise<void> => {\n      await flushBatch();\n    };\n\n    const cancel = (): void => {\n      cancelled = true;\n      clearDebounce();\n      batch = [];\n    };\n\n    return {\n      addItem,\n      complete,\n      cancel,\n    };\n  }\n}\n","import type { Subst, Term } from \"logic\";\nimport { isVar, queryUtils, unify, walk } from \"logic\";\nimport type {\n\tDataRow,\n\tGoalRecord,\n\tQueryParams,\n\tWhereCondition,\n} from \"./types.js\";\n\n/**\n * Helper functions for AbstractRelation\n * Extracted to keep the main class focused\n */\n\n/**\n * Check if one goal could benefit from cached data of another goal\n */\nexport function couldBenefitFromCache(\n\tmyGoal: GoalRecord,\n\totherGoal: GoalRecord,\n\tsubst: Subst,\n): string {\n\tif (myGoal.relationIdentifier !== otherGoal.relationIdentifier) {\n\t\treturn \"different_relation\";\n\t}\n\n\t// // Check if relation options are compatible for caching\n\t// // For REST APIs, different pathTemplates mean different endpoints\n\t// const myOptions = myGoal.relationOptions as any;\n\t// const otherOptions = otherGoal.relationOptions as any;\n\n\t// if (myOptions?.pathTemplate !== otherOptions?.pathTemplate) {\n\t//   return \"different_path_template\";\n\t// }\n\n\t// // Add other option compatibility checks as needed\n\t// if (JSON.stringify(myOptions) !== JSON.stringify(otherOptions)) {\n\t//   return \"incompatible_options\";\n\t// }\n\n\tconst myColumns = Object.keys(myGoal.queryObj);\n\tconst otherColumns = Object.keys(otherGoal.queryObj);\n\n\tlet matches = 0;\n\n\tfor (const column of myColumns) {\n\t\tif (otherColumns.includes(column)) {\n\t\t\tconst myValueRaw = myGoal.queryObj[column];\n\t\t\tconst otherValueRaw = otherGoal.queryObj[column];\n\t\t\tconst myValue = walk(myValueRaw, subst);\n\t\t\tconst otherValue = walk(otherValueRaw, subst);\n\n\t\t\tif (!isVar(myValue)) {\n\t\t\t\tif (!isVar(otherValue)) {\n\t\t\t\t\tif (myValue === otherValue) {\n\t\t\t\t\t\tmatches++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn \"value_not_match\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn \"term_to_var\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isVar(otherValue)) {\n\t\t\t\t\tmatches++;\n\t\t\t\t} else {\n\t\t\t\t\treturn \"var_to_term\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (matches > 0) {\n\t\treturn \"match\";\n\t}\n\treturn \"no_matches\";\n}\n\n/**\n * Check if two goals can have their queries merged\n */\nexport function canMergeQueries(goalA: GoalRecord, goalB: GoalRecord): boolean {\n\tconst aColumns = Object.keys(goalA.queryObj);\n\tconst bColumns = Object.keys(goalB.queryObj);\n\n\tif (aColumns.length !== bColumns.length) {\n\t\treturn false;\n\t}\n\n\tif (!aColumns.every((col) => bColumns.includes(col))) {\n\t\treturn false;\n\t}\n\n\tfor (const column of aColumns) {\n\t\tconst aValue = goalA.queryObj[column];\n\t\tconst bValue = goalB.queryObj[column];\n\n\t\tif (isVar(aValue) && isVar(bValue)) {\n\t\t\tif (aValue.id !== bValue.id) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (isVar(aValue) || isVar(bValue)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (aValue !== bValue) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Collect WHERE clauses from a set of goals for merging\n */\nexport async function collectAllWhereClauses(\n\tgoals: GoalRecord[],\n\ts: Subst,\n): Promise<Record<string, Set<any>>> {\n\tconst allWhereClauses: Record<string, Set<any>> = {};\n\tfor (const goal of goals) {\n\t\tconst whereCols = queryUtils.onlyGrounded(goal.queryObj);\n\t\tfor (const [col, value] of Object.entries(whereCols)) {\n\t\t\tif (!allWhereClauses[col]) allWhereClauses[col] = new Set();\n\t\t\tallWhereClauses[col].add(value);\n\t\t}\n\t}\n\treturn allWhereClauses;\n}\n\n/**\n * Collect WHERE clauses from substitutions for batching\n */\nexport async function collectWhereClausesFromSubstitutions(\n\tqueryObj: Record<string, Term>,\n\tsubstitutions: Subst[],\n): Promise<Record<string, Set<any>>> {\n\tconst whereClauses: Record<string, Set<any>> = {};\n\tfor (const subst of substitutions) {\n\t\tconst walked = await queryUtils.walkAllKeys(queryObj, subst);\n\t\tconst whereCols = queryUtils.onlyGrounded(walked);\n\t\tfor (const [col, value] of Object.entries(whereCols)) {\n\t\t\tif (!whereClauses[col]) whereClauses[col] = new Set();\n\t\t\twhereClauses[col].add(value);\n\t\t}\n\t}\n\treturn whereClauses;\n}\n\n/**\n * Collect all columns needed for query from goals\n */\nexport function collectColumnsFromGoals(\n\tmyQueryObj: Record<string, Term>,\n\tcacheCompatibleGoals: GoalRecord[],\n\tmergeCompatibleGoals?: GoalRecord[],\n): { columns: string[]; additionalColumns: string[] } {\n\tconst allGoalColumns = new Set<string>();\n\n\t// Add columns from current goal\n\tObject.keys(myQueryObj).forEach((col) => allGoalColumns.add(col));\n\n\t// Add columns from merge-compatible goals\n\tif (mergeCompatibleGoals) {\n\t\tfor (const goal of mergeCompatibleGoals) {\n\t\t\tObject.keys(goal.queryObj).forEach((col) => allGoalColumns.add(col));\n\t\t}\n\t}\n\n\t// Add columns from cache-compatible goals\n\tfor (const cacheGoal of cacheCompatibleGoals) {\n\t\tObject.keys(cacheGoal.queryObj).forEach((col) => allGoalColumns.add(col));\n\t}\n\n\tconst additionalColumns: string[] = []; // Could be from options\n\tconst columns = [...new Set([...allGoalColumns, ...additionalColumns])];\n\n\treturn {\n\t\tcolumns,\n\t\tadditionalColumns,\n\t};\n}\n\n/**\n * Build WHERE conditions from clause sets\n */\nexport function buildWhereConditions(\n\twhereClauses: Record<string, Set<any>>,\n): WhereCondition[] {\n\tconst conditions: WhereCondition[] = [];\n\n\tfor (const [column, values] of Object.entries(whereClauses)) {\n\t\tif (values.size === 1) {\n\t\t\tconditions.push({\n\t\t\t\tcolumn,\n\t\t\t\toperator: \"eq\",\n\t\t\t\tvalue: Array.from(values)[0],\n\t\t\t});\n\t\t} else if (values.size > 1) {\n\t\t\tconditions.push({\n\t\t\t\tcolumn,\n\t\t\t\toperator: \"in\",\n\t\t\t\tvalue: null,\n\t\t\t\tvalues: Array.from(values),\n\t\t\t});\n\t\t}\n\t}\n\n\treturn conditions;\n}\n\n/**\n * Format query parameters for logging\n */\nexport function sssformatQueryForLog(params: QueryParams): string {\n\tlet query = `SELECT ${params.selectColumns.join(\", \")} FROM ${params.relationIdentifier}`;\n\n\tif (params.whereConditions.length > 0) {\n\t\tconst whereClause = params.whereConditions\n\t\t\t.map((cond) => {\n\t\t\t\tif (cond.operator === \"in\" && cond.values) {\n\t\t\t\t\treturn `${cond.column} IN (${cond.values.map((v) => (typeof v === \"string\" ? `'${v}'` : v)).join(\", \")})`;\n\t\t\t\t} else {\n\t\t\t\t\tconst value =\n\t\t\t\t\t\ttypeof cond.value === \"string\" ? `'${cond.value}'` : cond.value;\n\t\t\t\t\treturn `${cond.column} = ${value}`;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\" AND \");\n\t\tquery += ` WHERE ${whereClause}`;\n\t}\n\n\tif (params.limit) {\n\t\tquery += ` LIMIT ${params.limit}`;\n\t}\n\n\tif (params.offset) {\n\t\tquery += ` OFFSET ${params.offset}`;\n\t}\n\n\treturn query;\n}\n\n/**\n * Unify a data row with a query object\n */\nexport function unifyRowWithQuery(\n\trow: DataRow,\n\tqueryObj: Record<string, Term>,\n\ts: Subst,\n): Subst | null {\n\tlet result = s;\n\tfor (const [column, term] of Object.entries(queryObj)) {\n\t\tconst value = row[column];\n\t\tif (value === undefined) continue;\n\t\tconst unified = unify(term, value, result);\n\t\tif (unified === null) {\n\t\t\treturn null;\n\t\t}\n\t\tresult = unified;\n\t}\n\treturn result;\n}\n","import type { Subst } from \"logic\";\nimport type { CacheEntry, CacheManager, DataRow } from \"./types.js\";\n\nconst ROW_CACHE = Symbol.for(\"abstract-row-cache\");\n\n/**\n * Default cache manager that stores cache entries in substitution objects\n * This matches the current SQL implementation behavior\n */\nexport class DefaultCacheManager implements CacheManager {\n\t/**\n\t * Get cached rows for a goal from a substitution\n\t */\n\tget(goalId: number, subst: Subst): DataRow[] | null {\n\t\tconst cache = this.getOrCreateRowCache(subst);\n\t\tif (cache.has(goalId)) {\n\t\t\tconst entry = cache.get(goalId)!;\n\t\t\treturn entry.data;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set cached rows for a goal in a substitution\n\t */\n\tset(\n\t\tgoalId: number,\n\t\tsubst: Subst,\n\t\trows: DataRow[],\n\t\tmeta?: Record<string, any>,\n\t): void {\n\t\tconst cache = this.getOrCreateRowCache(subst);\n\t\tcache.set(goalId, {\n\t\t\tdata: rows,\n\t\t\ttimestamp: Date.now(),\n\t\t\tgoalId,\n\t\t\tmeta,\n\t\t});\n\t}\n\n\t/**\n\t * Clear cache entries\n\t */\n\tclear(goalId?: number): void {\n\t\t// Note: This implementation clears from a specific substitution\n\t\t// For global clearing, you'd need to track all substitutions\n\t\tif (goalId !== undefined) {\n\t\t\t// Clear specific goal - would need access to all active substitutions\n\t\t\t// This is a limitation of the current design\n\t\t}\n\t\t// For now, we rely on substitution-local clearing\n\t}\n\n\t/**\n\t * Check if cache entry exists\n\t */\n\thas(goalId: number, subst: Subst): boolean {\n\t\tconst cache = this.getOrCreateRowCache(subst);\n\t\treturn cache.has(goalId);\n\t}\n\n\t/**\n\t * Remove cache entry for a specific goal from a substitution\n\t */\n\tdelete(goalId: number, subst: Subst): void {\n\t\tconst cache = this.getOrCreateRowCache(subst);\n\t\tcache.delete(goalId);\n\t}\n\n\t/**\n\t * Get or create the cache map from a substitution\n\t */\n\tprivate getOrCreateRowCache(subst: Subst): Map<number, CacheEntry> {\n\t\tif (!subst.has(ROW_CACHE)) {\n\t\t\tsubst.set(ROW_CACHE, new Map<number, CacheEntry>());\n\t\t}\n\t\treturn subst.get(ROW_CACHE) as Map<number, CacheEntry>;\n\t}\n\n\t/**\n\t * Format cache for logging (matches current implementation)\n\t */\n\tformatCacheForLog(subst: Subst): Record<number, any> {\n\t\tconst result: Record<number, any> = {};\n\t\tconst cache = subst.get(ROW_CACHE);\n\t\tif (!(cache instanceof Map)) return result;\n\n\t\tfor (const [goalId, entry] of cache.entries()) {\n\t\t\tif (Array.isArray(entry.data)) {\n\t\t\t\tif (entry.data.length <= 5) {\n\t\t\t\t\tresult[goalId] = entry.data;\n\t\t\t\t} else {\n\t\t\t\t\tresult[goalId] = {\n\t\t\t\t\t\tcount: entry.data.length,\n\t\t\t\t\t\ttimestamp: entry.timestamp,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n","import type { Term } from \"logic\";\nimport type { GoalManager, GoalRecord } from \"./types.js\";\n\n/**\n * Default implementation of GoalManager\n * Handles goal tracking, ID generation, and query logging\n */\nexport class DefaultGoalManager implements GoalManager {\n\tprivate goals: GoalRecord[] = [];\n\tprivate queries: string[] = [];\n\tprivate nextGoalId = 0;\n\n\tgetNextGoalId(): number {\n\t\treturn ++this.nextGoalId;\n\t}\n\n\taddGoal(\n\t\tgoalId: number,\n\t\trelationIdentifier: string,\n\t\tqueryObj: Record<string, Term>,\n\t\tbatchKey?: string,\n\t\trelationOptions?: any,\n\t): void {\n\t\tthis.goals.push({\n\t\t\tgoalId,\n\t\t\trelationIdentifier,\n\t\t\tqueryObj,\n\t\t\tbatchKey,\n\t\t\trelationOptions,\n\t\t});\n\t}\n\n\tgetGoalById(id: number): GoalRecord | undefined {\n\t\treturn this.goals.find((goal) => goal.goalId === id);\n\t}\n\n\tgetGoalsByBatchKey(batchKey: string): GoalRecord[] {\n\t\treturn this.goals.filter((goal) => goal.batchKey === batchKey);\n\t}\n\n\tgetGoals(): GoalRecord[] {\n\t\treturn [...this.goals];\n\t}\n\n\tclearGoals(): void {\n\t\tthis.goals.length = 0;\n\t}\n\n\taddQuery(query: string): void {\n\t\tthis.queries.push(query);\n\t}\n\n\tgetQueries(): string[] {\n\t\treturn [...this.queries];\n\t}\n\n\tclearQueries(): void {\n\t\tthis.queries.length = 0;\n\t}\n\n\tgetQueryCount(): number {\n\t\treturn this.queries.length;\n\t}\n}\n"],"mappings":"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","names":["getDefaultLogger","isVar","walk","walk","isVar","getDefaultLogger"]}