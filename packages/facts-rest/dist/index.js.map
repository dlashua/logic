{"version":3,"sources":["../src/index.ts","../src/rest-datastore.ts"],"sourcesContent":["import type {\n  AbstractRelationConfig,\n  RestDataStoreConfig,\n} from \"@codespiral/facts-abstract\";\nimport { createAbstractRelationSystem } from \"@codespiral/facts-abstract\";\nimport { getDefaultLogger } from \"@codespiral/logic\";\nimport type { RelationCache } from \"./relation-cache.js\";\nimport { RestDataStore } from \"./rest-datastore.js\";\nimport type { RestRelationOptions } from \"./types.js\";\n\n/**\n * REST API implementation using the abstract data layer\n * Example of how to create a facts system backed by a REST API\n */\nexport const makeRelREST = async (\n  restConfig: RestDataStoreConfig & {\n    cache?: RelationCache;\n    cacheMethods?: string[];\n  },\n  config?: AbstractRelationConfig,\n) => {\n  const logger = getDefaultLogger();\n\n  // Create REST data store\n  const dataStore = new RestDataStore(restConfig);\n\n  // Configure the abstract relation system\n  const systemConfig: AbstractRelationConfig = {\n    batchSize: 50, // Smaller batches for REST APIs\n    debounceMs: 100, // Longer debounce for network calls\n    enableCaching: true,\n    enableQueryMerging: false, // REST APIs might not benefit from query merging\n    ...config,\n  };\n\n  // Create the abstract relation system\n  const relationSystem = createAbstractRelationSystem<RestRelationOptions>(\n    dataStore,\n    logger,\n    systemConfig,\n  );\n\n  // Patch rel to accept cache option per relation\n  const origRel = relationSystem.rel;\n  function rel(\n    pathTemplate: string,\n    options: RestRelationOptions & { cache?: RelationCache | null } = {},\n  ) {\n    // If cache is explicitly set, create a new RestDataStore for this rel with the given cache\n    if (Object.hasOwn(options, \"cache\")) {\n      const relCache = options.cache;\n      const relDataStore = new RestDataStore({\n        ...restConfig,\n        cache: relCache,\n      });\n      const relSystem = createAbstractRelationSystem<RestRelationOptions>(\n        relDataStore,\n        logger,\n        systemConfig,\n      );\n      return relSystem.rel(pathTemplate, options);\n    }\n    // Otherwise, use the default system\n    return origRel(pathTemplate, options);\n  }\n\n  return {\n    rel,\n    relSym: relationSystem.relSym,\n    getQueries: relationSystem.getQueries,\n    clearQueries: relationSystem.clearQueries,\n    getQueryCount: relationSystem.getQueryCount,\n    close: relationSystem.close,\n    getDataStore: relationSystem.getDataStore,\n  };\n};\n\n// Re-export for convenience\nexport type { RestDataStoreConfig } from \"@codespiral/facts-abstract\";\n","import type {\n  DataRow,\n  DataStore,\n  QueryParams,\n  RestDataStoreConfig,\n  WhereCondition,\n} from \"@codespiral/facts-abstract\";\nimport type { RelationCache } from \"./relation-cache.js\";\nimport type { RestRelationOptions } from \"./types.js\";\n\n/**\n * REST API implementation of DataStore\n * Demonstrates how the abstract interface can work with different backends\n */\nexport class RestDataStore implements DataStore {\n  readonly type = \"rest\";\n\n  private config: Required<RestDataStoreConfig>;\n  private cache?: RelationCache | null;\n  private cacheMethods: string[];\n  private cachePrefix: string;\n\n  constructor(\n    config: RestDataStoreConfig & {\n      cache?: RelationCache | null;\n      cacheMethods?: string[];\n      cachePrefix?: string;\n    },\n  ) {\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/$/, \"\"), // Remove trailing slash\n      apiKey: config.apiKey ?? \"\",\n      timeout: config.timeout ?? 30000,\n      headers: config.headers ?? {},\n      pagination: {\n        limitParam: config.pagination?.limitParam ?? \"limit\",\n        offsetParam: config.pagination?.offsetParam ?? \"offset\",\n        maxPageSize: config.pagination?.maxPageSize ?? 1000,\n        ...config.pagination,\n      },\n      features: {\n        primaryKeyInPath: config.features?.primaryKeyInPath ?? false,\n        supportsInOperator: config.features?.supportsInOperator ?? true,\n        supportsFieldSelection: config.features?.supportsFieldSelection ?? true,\n        urlBuilder: config.features?.urlBuilder,\n        queryParamFormatter: config.features?.queryParamFormatter,\n        ...config.features,\n      },\n    };\n    this.cache = config.cache;\n    this.cacheMethods = config.cacheMethods ?? [\"GET\"];\n    this.cachePrefix = config.cachePrefix ?? \"\";\n  }\n\n  async executeQuery(params: QueryParams): Promise<DataRow[]> {\n    // Detect a 'limit' whereCondition and move it to params.limit\n    let limitFromWhere: number | undefined;\n    const filteredWhere = params.whereConditions.filter((c) => {\n      if (\n        c.column === \"limit\" &&\n        c.operator === \"eq\" &&\n        typeof c.value === \"number\"\n      ) {\n        limitFromWhere = c.value;\n        return false;\n      }\n      return true;\n    });\n    const effectiveParams = {\n      ...params,\n      limit: limitFromWhere ?? params.limit,\n      whereConditions: filteredWhere,\n      relationOptions: params.relationOptions as RestRelationOptions,\n    };\n\n    // Handle IN operations that don't support comma-separated values\n    if (!this.config.features.supportsInOperator) {\n      return await this.executeQueryWithoutInOperator(effectiveParams);\n    }\n\n    // Build URL - check for primary key in path\n    const { baseUrl, primaryKeyCondition, otherConditions } =\n      this.buildUrl(effectiveParams);\n    const url = new URL(baseUrl);\n\n    // Add non-primary-key WHERE conditions as query parameters\n    for (const condition of otherConditions) {\n      this.addConditionToUrl(url, condition);\n    }\n\n    // Add field selection (if the API supports it)\n    if (\n      this.config.features.supportsFieldSelection &&\n      effectiveParams.selectColumns.length > 0\n    ) {\n      url.searchParams.append(\n        \"fields\",\n        effectiveParams.selectColumns.join(\",\"),\n      );\n    }\n\n    // Add pagination\n    // this.addPaginationToUrl(url, effectiveParams);\n\n    // Execute the request\n    return await this.executeHttpRequest(url.toString(), effectiveParams);\n  }\n\n  private async executeQueryWithoutInOperator(\n    params: QueryParams,\n  ): Promise<DataRow[]> {\n    // Find IN conditions and split them into multiple queries\n    const inConditions = params.whereConditions.filter(\n      (c) => c.operator === \"in\" && c.values,\n    );\n    const otherConditions = params.whereConditions.filter(\n      (c) => !(c.operator === \"in\" && c.values),\n    );\n\n    if (inConditions.length === 0) {\n      // No IN conditions, execute normally but bypass the IN operator check\n      return await this.executeQueryDirect({\n        ...params,\n        whereConditions: otherConditions,\n      });\n    }\n\n    // Execute multiple queries for each IN condition value\n    const allResults: DataRow[] = [];\n    for (const inCondition of inConditions) {\n      if (inCondition.values) {\n        for (const value of inCondition.values) {\n          const eqCondition = {\n            column: inCondition.column,\n            operator: \"eq\" as const,\n            value: value,\n          };\n          const queryParams = {\n            ...params,\n            whereConditions: [...otherConditions, eqCondition],\n          };\n          const results = await this.executeQueryDirect(queryParams);\n          // Tag each result row with the IN value for correct unification\n          for (const row of results) {\n            allResults.push({\n              ...row,\n              [inCondition.column]: value,\n            });\n          }\n        }\n      }\n    }\n\n    // Remove duplicates (in case of overlapping results)\n    const uniqueResults = allResults.filter(\n      (row, index, self) =>\n        index ===\n        self.findIndex((r) => JSON.stringify(r) === JSON.stringify(row)),\n    );\n\n    return uniqueResults;\n  }\n\n  private async executeQueryDirect(params: QueryParams): Promise<DataRow[]> {\n    // Direct execution without IN operator check to avoid recursion\n    const { baseUrl, primaryKeyCondition, otherConditions } =\n      this.buildUrl(params);\n    const url = new URL(baseUrl);\n\n    // Add non-primary-key WHERE conditions as query parameters\n    for (const condition of otherConditions) {\n      this.addConditionToUrl(url, condition);\n    }\n\n    // Add field selection (if the API supports it)\n    if (\n      this.config.features.supportsFieldSelection &&\n      params.selectColumns.length > 0\n    ) {\n      url.searchParams.append(\"fields\", params.selectColumns.join(\",\"));\n    }\n\n    // Add pagination\n    // this.addPaginationToUrl(url, params);\n\n    // Execute the request\n    return await this.executeHttpRequest(url.toString(), params);\n  }\n\n  private buildUrl(params: QueryParams): {\n    baseUrl: string;\n    primaryKeyCondition: WhereCondition | null;\n    otherConditions: WhereCondition[];\n  } {\n    // --- Flexible path template logic ---\n    function fillPathTemplate(\n      template: string,\n      whereConditions: WhereCondition[],\n    ): { path: string; usedColumns: Set<string> } {\n      const usedColumns = new Set<string>();\n      let path = template.replace(/:([a-zA-Z0-9_]+)\\??/g, (_, key) => {\n        const cond = whereConditions.find(\n          (c) => c.column === key && c.operator === \"eq\",\n        );\n        if (cond && cond.value !== undefined && cond.value !== null) {\n          usedColumns.add(key);\n          return encodeURIComponent(cond.value);\n        }\n        // If optional (ends with ?), remove segment if not present\n        return \"\";\n      });\n      // Remove double slashes from missing optional params\n      path = path.replace(/\\/+/g, \"/\").replace(/\\/$/, \"\");\n      return {\n        path,\n        usedColumns,\n      };\n    }\n\n    let path = \"\";\n    let usedColumns = new Set<string>();\n\n    if (params.relationIdentifier) {\n      const filled = fillPathTemplate(\n        params.relationIdentifier,\n        params.whereConditions,\n      );\n      path = filled.path;\n      usedColumns = filled.usedColumns;\n    } else if (this.config.features.primaryKeyInPath) {\n      // Look for primary key condition using relation options\n      const primaryKeyColumn =\n        params.relationOptions?.restPrimaryKey ||\n        params.relationOptions?.primaryKey;\n      let primaryKeyCondition: WhereCondition | null = null;\n      let otherConditions: WhereCondition[] = [];\n      if (primaryKeyColumn) {\n        // Find condition that matches the primary key column\n        primaryKeyCondition =\n          params.whereConditions.find(\n            (c) => c.column === primaryKeyColumn && c.operator === \"eq\",\n          ) || null;\n\n        if (primaryKeyCondition) {\n          otherConditions = params.whereConditions.filter(\n            (c) => c !== primaryKeyCondition,\n          );\n        } else {\n          otherConditions = params.whereConditions;\n        }\n      } else {\n        otherConditions = params.whereConditions;\n      }\n      if (primaryKeyCondition) {\n        path = `/${params.relationIdentifier}/${primaryKeyCondition.value}`;\n        // @ts-expect-error\n        usedColumns.add(primaryKeyColumn);\n      } else {\n        path = `/${params.relationIdentifier}`;\n      }\n    } else {\n      path = `/${params.relationIdentifier}`;\n    }\n    // Remove used columns from query params\n    const otherConditions = params.whereConditions.filter(\n      (c) => !usedColumns.has(c.column),\n    );\n    const baseUrl = `${this.config.baseUrl}${path}`;\n    return {\n      baseUrl,\n      primaryKeyCondition: null,\n      otherConditions,\n    };\n  }\n\n  private addConditionToUrl(url: URL, condition: WhereCondition): void {\n    if (this.config.features.queryParamFormatter) {\n      const formatted = this.config.features.queryParamFormatter(\n        condition.column,\n        condition.operator,\n        condition.value,\n      );\n      url.searchParams.append(formatted.key, formatted.value);\n      return;\n    }\n\n    // Default behavior\n    if (condition.operator === \"eq\") {\n      url.searchParams.append(condition.column, String(condition.value));\n    } else if (condition.operator === \"in\" && condition.values) {\n      if (this.config.features.supportsInOperator) {\n        url.searchParams.append(condition.column, condition.values.join(\",\"));\n      }\n      // If doesn't support IN, this will be handled by executeQueryWithoutInOperator\n    } else if (condition.operator === \"gt\") {\n      url.searchParams.append(\n        `${condition.column}[gt]`,\n        String(condition.value),\n      );\n    } else if (condition.operator === \"lt\") {\n      url.searchParams.append(\n        `${condition.column}[lt]`,\n        String(condition.value),\n      );\n    } else if (condition.operator === \"gte\") {\n      url.searchParams.append(\n        `${condition.column}[gte]`,\n        String(condition.value),\n      );\n    } else if (condition.operator === \"lte\") {\n      url.searchParams.append(\n        `${condition.column}[lte]`,\n        String(condition.value),\n      );\n    } else if (condition.operator === \"like\") {\n      url.searchParams.append(\n        `${condition.column}[like]`,\n        String(condition.value),\n      );\n    }\n  }\n\n  private addPaginationToUrl(url: URL, params: QueryParams): void {\n    if (params.limit && this.config.pagination.limitParam) {\n      const limit = Math.min(\n        params.limit,\n        this.config.pagination.maxPageSize ?? params.limit,\n      );\n      url.searchParams.append(this.config.pagination.limitParam, String(limit));\n    }\n    if (params.offset && this.config.pagination.offsetParam) {\n      url.searchParams.append(\n        this.config.pagination.offsetParam,\n        String(params.offset),\n      );\n    }\n  }\n\n  // Helper: auto-paginate for APIs with { results: [], page: number } format\n  private async fetchAllPages(\n    url: string,\n    params: QueryParams,\n    initialData: any,\n    initialPage: number,\n    pageSize: number,\n    totalLimit: number,\n  ): Promise<DataRow[]> {\n    const allResults: DataRow[] = Array.isArray(initialData.results)\n      ? initialData.results\n      : [];\n    let page = initialPage;\n    const done = false;\n    // Cache the initial page if caching is enabled\n    const method = \"GET\";\n    const shouldCache = this.cache && this.cacheMethods.includes(method);\n    const limitKey = params.limit !== undefined ? `:limit=${params.limit}` : \"\";\n    if (shouldCache) {\n      const cacheKey = this.cachePrefix + method + \":\" + url + limitKey;\n      await this.cache!.set(cacheKey, initialData.results);\n    }\n    while (!done && allResults.length < totalLimit) {\n      page++;\n      const pagedUrl = new URL(url);\n      pagedUrl.searchParams.set(\"page\", String(page));\n      pagedUrl.searchParams.set(\"limit\", String(pageSize));\n      const pagedUrlStr = pagedUrl.toString();\n      let pageResults: any[] | undefined;\n      let fromCache = false;\n      const pageLimitKey =\n        params.limit !== undefined ? `:limit=${params.limit}` : \"\";\n      if (shouldCache) {\n        const cacheKey =\n          this.cachePrefix + method + \":\" + pagedUrlStr + pageLimitKey;\n        const cached = await this.cache!.get(cacheKey);\n        if (cached !== undefined) {\n          pageResults = Array.isArray(cached)\n            ? cached\n            : cached &&\n                typeof cached === \"object\" &&\n                Array.isArray(cached.results)\n              ? cached.results\n              : [];\n          fromCache = true;\n        }\n      }\n      if (!fromCache) {\n        const response = await fetch(pagedUrlStr, {\n          method: \"GET\",\n          headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\",\n            ...this.config.headers,\n            ...(this.config.apiKey\n              ? {\n                  Authorization: `Bearer ${this.config.apiKey}`,\n                }\n              : {}),\n          },\n          signal: AbortSignal.timeout(this.config.timeout),\n        });\n        if (!response.ok) break;\n        const data = await response.json();\n        pageResults = Array.isArray(data.results) ? data.results : [];\n        if (shouldCache) {\n          const cacheKey =\n            this.cachePrefix + method + \":\" + pagedUrlStr + pageLimitKey;\n          await this.cache!.set(cacheKey, pageResults);\n        }\n      }\n      if (!pageResults || pageResults.length === 0) break;\n      allResults.push(...pageResults);\n      if (pageResults.length < pageSize) break; // last page\n    }\n    return allResults.slice(0, totalLimit);\n  }\n\n  private async executeHttpRequest(\n    url: string,\n    params: QueryParams,\n  ): Promise<DataRow[]> {\n    // Prepare headers\n    const headers: Record<string, string> = {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      ...this.config.headers,\n    };\n\n    if (this.config.apiKey) {\n      headers[\"Authorization\"] = `Bearer ${this.config.apiKey}`;\n    }\n\n    // Determine HTTP method (default GET)\n    const method = \"GET\"; // TODO: support other methods if needed\n    const limitKey = params.limit !== undefined ? `:limit=${params.limit}` : \"\";\n    const cacheKey = this.cachePrefix + method + \":\" + url + limitKey;\n\n    const shouldCache = this.cache && this.cacheMethods.includes(method);\n\n    if (shouldCache) {\n      const cached = await this.cache!.get(cacheKey);\n      if (cached !== undefined) {\n        if (params.logQuery) {\n          const headersStr =\n            Object.keys(headers).length > 2\n              ? ` Headers: ${JSON.stringify({\n                  ...headers,\n                  Authorization: undefined,\n                })}`\n              : \"\";\n          params.logQuery(`[CACHED] ${method} ${url}${headersStr}`);\n        }\n        if (Array.isArray(cached)) {\n          return cached;\n        }\n        if (typeof cached === \"string\") {\n          try {\n            const arr = JSON.parse(cached);\n            if (Array.isArray(arr)) return arr;\n          } catch (e) {\n            /* ignore parse error */\n          }\n        }\n        if (cached && typeof cached === \"object\") return [cached];\n        return [];\n      }\n    }\n\n    // Log the actual HTTP request\n    if (params.logQuery) {\n      const headersStr =\n        Object.keys(headers).length > 2\n          ? ` Headers: ${JSON.stringify({\n              ...headers,\n              Authorization: undefined,\n            })}`\n          : \"\";\n      params.logQuery(`${method} ${url}${headersStr}`);\n    }\n\n    // Execute the request\n    const response = await fetch(url, {\n      method,\n      headers,\n      signal: AbortSignal.timeout(this.config.timeout),\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `REST API error: ${response.status} ${response.statusText} @${url}`,\n      );\n    }\n\n    const data = await response.json();\n\n    // Auto-paginate if response is { results: [], page: number }\n    const totalLimit = params.limit ?? 50;\n    let result: DataRow[];\n    if (data && Array.isArray(data.results) && typeof data.page === \"number\") {\n      if (data.results.length >= totalLimit) {\n        result = data.results.slice(0, totalLimit);\n      } else {\n        // Fetch more pages if needed\n        const pageSize = data.results.length;\n        if (pageSize === 0) return [];\n        result = await this.fetchAllPages(\n          url,\n          params,\n          data,\n          data.page,\n          pageSize,\n          totalLimit,\n        );\n      }\n    } else if (Array.isArray(data)) {\n      result = data;\n    } else if (data.data && Array.isArray(data.data)) {\n      result = data.data;\n    } else if (data.results && Array.isArray(data.results)) {\n      result = data.results;\n    } else if (typeof data === \"object\" && data !== null) {\n      result = [data];\n    } else {\n      console.error(\"UNEXPECTED FORMAT\");\n      throw new Error(\n        `Unexpected REST API response format: ${JSON.stringify(data)}`,\n      );\n    }\n\n    if (shouldCache) {\n      await this.cache!.set(cacheKey, result);\n    }\n    return result;\n  }\n\n  async getColumns(relationIdentifier: string): Promise<string[]> {\n    // This would typically require a schema endpoint\n    // For now, we'll return an empty array or make a sample query\n    try {\n      const url = `${this.config.baseUrl}/${relationIdentifier}`;\n      const headers: Record<string, string> = {\n        Accept: \"application/json\",\n        ...this.config.headers,\n      };\n\n      if (this.config.apiKey) {\n        headers[\"Authorization\"] = `Bearer ${this.config.apiKey}`;\n      }\n\n      // Try to get first record to infer schema\n      console.log(\"FETCH COLUMNS\", url);\n      const response = await fetch(`${url}?limit=1`, {\n        method: \"GET\",\n        headers,\n        signal: AbortSignal.timeout(this.config.timeout),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        const records = Array.isArray(data)\n          ? data\n          : data.data || data.results || [];\n        if (records.length > 0) {\n          return Object.keys(records[0]);\n        }\n      }\n    } catch (error) {\n      console.warn(\n        `Could not infer columns for relationIdentifier ${relationIdentifier}:`,\n        error,\n      );\n    }\n\n    return [];\n  }\n\n  buildWhereConditions(clauses: Record<string, Set<any>>): WhereCondition[] {\n    const conditions: WhereCondition[] = [];\n\n    for (const [column, values] of Object.entries(clauses)) {\n      if (values.size === 1) {\n        conditions.push({\n          column,\n          operator: \"eq\",\n          value: Array.from(values)[0],\n        });\n      } else if (values.size > 1) {\n        conditions.push({\n          column,\n          operator: \"in\",\n          value: null,\n          values: Array.from(values),\n        });\n      }\n    }\n\n    return conditions;\n  }\n\n  async close(): Promise<void> {\n    // No cleanup needed for REST API\n  }\n}\n"],"mappings":"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","names":["usedColumns","path","otherConditions"]}