{"version":3,"sources":["../src/facts-memory.ts","../src/memory-obj-relation.ts","../src/memory-relation.ts","../src/symmetric-relation.ts","../src/relation-factory.ts"],"sourcesContent":["import { type BaseConfig, getDefaultLogger } from \"logic\";\nimport { FactRelationFactory } from \"./relation-factory.js\";\nimport type {\n\tFactObjRelation,\n\tFactRelation,\n\tFactRelationConfig,\n} from \"./types.js\";\n\nexport const makeFacts = (\n\tconfig?: Partial<BaseConfig>,\n\tfactConfig?: FactRelationConfig,\n) => {\n\tconst logger = getDefaultLogger();\n\n\tconst factory = new FactRelationFactory({\n\t\tlogger,\n\t\tconfig: factConfig || {\n\t\t\tenableLogging: false,\n\t\t\tenableIndexing: true,\n\t\t},\n\t});\n\n\treturn factory.createArrayRelation();\n};\n\nexport const makeFactsObj = (\n\tkeys: string[],\n\tconfig?: Partial<BaseConfig>,\n\tfactConfig?: FactRelationConfig,\n): FactObjRelation => {\n\tconst logger = getDefaultLogger();\n\n\tconst factory = new FactRelationFactory({\n\t\tlogger,\n\t\tconfig: factConfig || {\n\t\t\tenableLogging: false,\n\t\t\tenableIndexing: true,\n\t\t},\n\t});\n\n\treturn factory.createObjectRelation(keys);\n};\n\nexport const makeFactsSym = (\n\tconfig?: Partial<BaseConfig>,\n\tfactConfig?: FactRelationConfig,\n): FactRelation => {\n\tconst logger = getDefaultLogger();\n\n\tconst factory = new FactRelationFactory({\n\t\tlogger,\n\t\tconfig: factConfig || {\n\t\t\tenableLogging: false,\n\t\t\tenableIndexing: true,\n\t\t},\n\t});\n\n\treturn factory.createSymmetricArrayRelation();\n};\n\nexport const makeFactsObjSym = (\n\tkeys: string[],\n\tconfig?: Partial<BaseConfig>,\n\tfactConfig?: FactRelationConfig,\n): FactObjRelation => {\n\tconst logger = getDefaultLogger();\n\n\tconst factory = new FactRelationFactory({\n\t\tlogger,\n\t\tconfig: factConfig || {\n\t\t\tenableLogging: false,\n\t\t\tenableIndexing: true,\n\t\t},\n\t});\n\n\treturn factory.createSymmetricObjectRelation(keys);\n};\n","import {\n  type Goal,\n  indexUtils,\n  isVar,\n  type Logger,\n  queryUtils,\n  SimpleObservable,\n  type Subst,\n  type Term,\n  unificationUtils,\n} from \"logic\";\nimport type { FactObjRelation, FactRelationConfig } from \"./types.js\";\n\nexport class MemoryObjRelation {\n  /**\n   * Update facts matching a where-clause with new values.\n   * @param where - fields and values to match\n   * @param newValues - fields and values to update\n   */\n  private updateFacts(\n    where: Partial<Record<string, Term>>,\n    newValues: Record<string, Term>,\n    upsert: boolean = false,\n  ): void {\n    let updated = false;\n    for (let i = 0; i < this.facts.length; i++) {\n      const fact = this.facts[i];\n      let match = true;\n      for (const key of Object.keys(where)) {\n        // Use strict equality for now; can swap for deep equality or unification if needed\n        if (fact[key] !== where[key]) {\n          match = false;\n          break;\n        }\n      }\n      if (match) {\n        updated = true;\n        // Remove old index entries for changed keys\n        if (this.config.enableIndexing !== false) {\n          for (const key of this.keys) {\n            if (\n              key in newValues &&\n              key in fact &&\n              indexUtils.isIndexable(fact[key])\n            ) {\n              const index = this.indexes.get(key);\n              if (index) {\n                this.removeFromIndex(index, fact[key], i);\n              }\n            }\n          }\n        }\n        // Update fact fields\n        Object.assign(fact, newValues);\n        // Add new index entries for changed keys\n        if (this.config.enableIndexing !== false) {\n          for (const key of this.keys) {\n            if (key in newValues && indexUtils.isIndexable(fact[key])) {\n              let index = this.indexes.get(key);\n              if (!index) {\n                index = indexUtils.createIndex();\n                this.indexes.set(key, index);\n              }\n              indexUtils.addToIndex(index, fact[key], i);\n            }\n          }\n        }\n        this.logger.log(\"FACT_UPDATED\", {\n          message: `Updated object fact at index ${i}`,\n          fact,\n        });\n      }\n    }\n    // If no record was updated and upsert is true, insert a new one\n    if (!updated && upsert) {\n      const newFact: Record<string, Term> = { ...where, ...newValues };\n      this.addFact(newFact);\n      this.logger.log(\"FACT_INSERTED\", {\n        message: `Inserted new object fact (upsert)`,\n        fact: newFact,\n      });\n    }\n  }\n\n  /**\n   * Remove a fact index from a Map<value, Set<index>>\n   */\n  private removeFromIndex(\n    index: Map<unknown, Set<number>>,\n    value: unknown,\n    factIndex: number,\n  ): void {\n    const set = index.get(value);\n    if (set) {\n      set.delete(factIndex);\n      if (set.size === 0) {\n        index.delete(value);\n      }\n    }\n  }\n  private facts: Record<string, Term>[] = [];\n  private indexes: Map<string, Map<unknown, Set<number>>> = new Map();\n  private goalIdCounter = 0;\n\n  constructor(\n    private keys: string[],\n    private logger: Logger,\n    private config: FactRelationConfig,\n  ) {}\n\n  createRelation(): FactObjRelation {\n    const goalFn = (queryObj: Record<string, Term>): Goal => {\n      const goalId = this.generateGoalId();\n      return this.createGoal(queryObj, goalId);\n    };\n\n    goalFn.set = (factObj: Record<string, Term>) => {\n      this.addFact(factObj);\n    };\n\n    goalFn.update = (\n      where: Partial<Record<string, Term>>,\n      newValues: Record<string, Term>,\n    ) => {\n      this.updateFacts(where, newValues, false);\n    };\n\n    goalFn.upsert = (\n      where: Partial<Record<string, Term>>,\n      newValues: Record<string, Term>,\n    ) => {\n      this.updateFacts(where, newValues, true);\n    };\n\n    goalFn.raw = this.facts;\n    goalFn.indexes = this.indexes;\n    goalFn.keys = this.keys;\n\n    return goalFn;\n  }\n\n  private generateGoalId(): number {\n    return ++this.goalIdCounter;\n  }\n\n  private createGoal(queryObj: Record<string, Term>, goalId: number): Goal {\n    return (input$) =>\n      new SimpleObservable<Subst>((observer) => {\n        let cancelled = false;\n        this.logger.log(\"RUN_START\", {\n          message: `Starting memory object relation goal ${goalId}`,\n          queryObj,\n        });\n        this.logger.log(\"STARTING PROCESS ALL\", {\n          goalId,\n        });\n        const subscription = input$.subscribe({\n          next: async (s: Subst) => {\n            try {\n              const queryKeys = Object.keys(queryObj);\n              const walkedQuery = await queryUtils.walkAllKeys(queryObj, s);\n              // Find indexable, grounded keys\n              const indexedKeys: string[] = [];\n              for (const key of queryKeys) {\n                if (!isVar(walkedQuery[key]) && this.indexes.has(key)) {\n                  indexedKeys.push(key);\n                }\n              }\n              let candidateIndexes: Set<number> | null = null;\n              if (indexedKeys.length > 0) {\n                this.logger.log(\"INDEX_LOOKUP\", {\n                  message: `Using indexes for keys: ${indexedKeys.join(\", \")}`,\n                });\n                for (const key of indexedKeys) {\n                  const value = walkedQuery[key];\n                  const index = this.indexes.get(key);\n                  if (!index) continue;\n                  const factNums = index.get(value);\n                  if (!factNums || factNums.size === 0) {\n                    candidateIndexes = new Set();\n                    break;\n                  }\n                  if (candidateIndexes === null) {\n                    candidateIndexes = new Set(factNums);\n                  } else {\n                    candidateIndexes = indexUtils.intersect(\n                      candidateIndexes,\n                      factNums,\n                    );\n                    if (candidateIndexes.size === 0) break;\n                  }\n                }\n              }\n              if (candidateIndexes === null) {\n                this.logger.log(\"MEMORY_SCAN\", {\n                  message: `Full scan of ${this.facts.length} object facts`,\n                });\n                await this.processFacts(\n                  this.facts,\n                  queryObj,\n                  walkedQuery,\n                  queryKeys,\n                  s,\n                  observer,\n                  () => cancelled,\n                );\n              } else {\n                this.logger.log(\"INDEX_LOOKUP\", {\n                  message: `Checking ${candidateIndexes.size} indexed object facts`,\n                });\n                const indexedFacts = Array.from(candidateIndexes).map(\n                  (i) => this.facts[i],\n                );\n                await this.processFacts(\n                  indexedFacts,\n                  queryObj,\n                  walkedQuery,\n                  queryKeys,\n                  s,\n                  observer,\n                  () => cancelled,\n                );\n              }\n            } catch (err) {\n              if (!cancelled) observer.error?.(err);\n            }\n          },\n          complete: () => {\n            if (!cancelled) {\n              this.logger.log(\"RUN_END\", {\n                message: `Completed memory object relation goal ${goalId}`,\n              });\n              observer.complete?.();\n            }\n          },\n          error: (err) => {\n            if (!cancelled) observer.error?.(err);\n          },\n        });\n        return () => {\n          cancelled = true;\n          subscription.unsubscribe?.();\n        };\n      });\n  }\n\n  private async processFacts(\n    facts: Record<string, Term>[],\n    queryObj: Record<string, Term>,\n    walkedQuery: Record<string, Term>,\n    queryKeys: string[],\n    s: Subst,\n    observer: {\n      next: (s: Subst) => void;\n      complete?: () => void;\n      error?: (err: unknown) => void;\n    },\n    isCancelled: () => boolean,\n  ): Promise<void> {\n    for (let i = 0; i < facts.length; i++) {\n      if (isCancelled()) break;\n\n      const fact = facts[i];\n      const s1 = await unificationUtils.unifyRowWithWalkedQ(\n        queryKeys,\n        walkedQuery,\n        fact,\n        s,\n      );\n      if (s1 && !isCancelled()) {\n        this.logger.log(\"FACT_MATCH\", {\n          message: \"Object fact matched\",\n          fact,\n          queryObj,\n        });\n        observer.next(s1);\n      }\n\n      // Yield control periodically to allow cancellation\n      if (i % 10 === 0) {\n        await new Promise((resolve) => queueMicrotask(() => resolve(null)));\n      }\n    }\n  }\n\n  private addFact(factObj: Record<string, Term>): void {\n    const factIndex = this.facts.length;\n    this.facts.push(factObj);\n\n    if (this.config.enableIndexing !== false) {\n      // Index by keys\n      for (const key of this.keys) {\n        if (key in factObj) {\n          const term = factObj[key];\n          if (indexUtils.isIndexable(term)) {\n            let index = this.indexes.get(key);\n            if (!index) {\n              index = indexUtils.createIndex();\n              this.indexes.set(key, index);\n            }\n            indexUtils.addToIndex(index, term, factIndex);\n          }\n        }\n      }\n    }\n\n    this.logger.log(\"FACT_ADDED\", {\n      message: `Added object fact at index ${factIndex}`,\n      fact: factObj,\n    });\n  }\n}\n","import {\n  type Goal,\n  indexUtils,\n  isVar,\n  type Logger,\n  queryUtils,\n  SimpleObservable,\n  type Subst,\n  type Term,\n  unificationUtils,\n  unify,\n  walk,\n} from \"logic\";\nimport type { FactRelation, FactRelationConfig } from \"./types.js\";\n\nexport class MemoryRelation {\n  private facts: Term[][] = [];\n  private indexes = new Map<number, Map<any, Set<number>>>();\n  private goalIdCounter = 0;\n\n  constructor(\n    private logger: Logger,\n    private config: FactRelationConfig,\n  ) {}\n\n  createRelation(): FactRelation {\n    const goalFn = (...query: Term[]): Goal => {\n      const goalId = this.generateGoalId();\n      return this.createGoal(query, goalId);\n    };\n\n    goalFn.set = (...fact: Term[]) => {\n      this.addFact(fact);\n    };\n\n    goalFn.raw = this.facts;\n    goalFn.indexes = this.indexes;\n\n    return goalFn;\n  }\n\n  private generateGoalId(): number {\n    return ++this.goalIdCounter;\n  }\n\n  private createGoal(query: Term[], goalId: number): Goal {\n    return (input$) =>\n      new SimpleObservable<Subst>((observer) => {\n        let cancelled = false;\n\n        this.logger.log(\"RUN_START\", {\n          message: `Starting memory relation goal ${goalId}`,\n          query,\n        });\n\n        const subscription = input$.subscribe({\n          next: async (s: Subst) => {\n            try {\n              if (cancelled) return;\n\n              const walkedQuery = queryUtils.walkAllArray(query, s);\n\n              // Try to use indexes for optimization\n              const indexedPositions: number[] = [];\n              walkedQuery.forEach((term, i) => {\n                if (!isVar(term) && this.indexes.has(i)) {\n                  indexedPositions.push(i);\n                }\n              });\n\n              let candidateIndexes: Set<number> | null = null;\n\n              if (indexedPositions.length > 0) {\n                this.logger.log(\"INDEX_LOOKUP\", {\n                  message: `Using indexes for positions: ${indexedPositions.join(\", \")}`,\n                });\n\n                for (const pos of indexedPositions) {\n                  const term = walkedQuery[pos];\n                  const index = this.indexes.get(pos);\n                  if (!index) continue;\n\n                  const factNums = index.get(term);\n                  if (!factNums || factNums.size === 0) {\n                    candidateIndexes = new Set();\n                    break;\n                  }\n\n                  if (candidateIndexes === null) {\n                    candidateIndexes = new Set(factNums);\n                  } else {\n                    candidateIndexes = indexUtils.intersect(\n                      candidateIndexes,\n                      factNums,\n                    );\n                    if (candidateIndexes.size === 0) break;\n                  }\n                }\n              }\n\n              if (candidateIndexes === null) {\n                this.logger.log(\"MEMORY_SCAN\", {\n                  message: `Full scan of ${this.facts.length} facts`,\n                });\n\n                // Process facts one by one with cancellation support\n                await this.processFacts(\n                  this.facts,\n                  query,\n                  s,\n                  observer,\n                  () => cancelled,\n                );\n              } else {\n                this.logger.log(\"INDEX_LOOKUP\", {\n                  message: `Checking ${candidateIndexes.size} indexed facts`,\n                });\n\n                // Process indexed facts\n                const indexedFacts = Array.from(candidateIndexes).map(\n                  (i) => this.facts[i],\n                );\n                await this.processFacts(\n                  indexedFacts,\n                  query,\n                  s,\n                  observer,\n                  () => cancelled,\n                );\n              }\n            } catch (err) {\n              if (!cancelled) observer.error?.(err);\n            }\n          },\n          complete: () => {\n            if (!cancelled) {\n              this.logger.log(\"RUN_END\", {\n                message: `Completed memory relation goal ${goalId}`,\n              });\n              observer.complete?.();\n            }\n          },\n          error: (err) => {\n            if (!cancelled) observer.error?.(err);\n          },\n        });\n\n        return () => {\n          cancelled = true;\n          subscription.unsubscribe?.();\n        };\n      });\n  }\n\n  private async processFacts(\n    facts: Term[][],\n    query: Term[],\n    s: Subst,\n    observer: any,\n    isCancelled: () => boolean,\n  ): Promise<void> {\n    for (let i = 0; i < facts.length; i++) {\n      if (isCancelled()) break;\n\n      const fact = facts[i];\n      const s1 = await unificationUtils.unifyArrays(query, fact, s);\n      if (s1 && !isCancelled()) {\n        this.logger.log(\"FACT_MATCH\", {\n          message: \"Fact matched\",\n          fact,\n          query,\n        });\n        observer.next(s1);\n      }\n\n      // Yield control periodically to allow cancellation\n      if (i % 10 === 0) {\n        await new Promise((resolve) => queueMicrotask(() => resolve(null)));\n      }\n    }\n  }\n\n  private addFact(fact: Term[]): void {\n    const factIndex = this.facts.length;\n    this.facts.push(fact);\n\n    if (this.config.enableIndexing !== false) {\n      fact.forEach((term, position) => {\n        if (indexUtils.isIndexable(term)) {\n          let index = this.indexes.get(position);\n          if (!index) {\n            index = indexUtils.createIndex();\n            this.indexes.set(position, index);\n          }\n          indexUtils.addToIndex(index, term, factIndex);\n        }\n      });\n    }\n\n    this.logger.log(\"FACT_ADDED\", {\n      message: `Added fact at index ${factIndex}`,\n      fact,\n    });\n  }\n}\n","import { eq, type Logger, type Term } from \"logic\";\nimport { MemoryObjRelation } from \"./memory-obj-relation.js\";\nimport { MemoryRelation } from \"./memory-relation.js\";\nimport type {\n\tFactObjRelation,\n\tFactRelation,\n\tFactRelationConfig,\n} from \"./types.js\";\n\nexport class SymmetricMemoryRelation {\n\tprivate memoryRelation: MemoryRelation;\n\n\tconstructor(logger: Logger, config: FactRelationConfig) {\n\t\tthis.memoryRelation = new MemoryRelation(logger, config);\n\t}\n\n\tcreateRelation(): FactRelation {\n\t\tconst baseRelation = this.memoryRelation.createRelation();\n\t\tconst origSet = baseRelation.set;\n\n\t\tconst symGoal = (...query: Term[]) => {\n\t\t\tif (query.length !== 2) {\n\t\t\t\treturn eq(1, 0); // fail\n\t\t\t}\n\t\t\treturn baseRelation(...query);\n\t\t};\n\n\t\tsymGoal.set = (...fact: Term[]) => {\n\t\t\tif (fact.length === 2) {\n\t\t\t\torigSet(fact[0], fact[1]);\n\t\t\t\torigSet(fact[1], fact[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow Error(\"Symmetric Facts are Binary\");\n\t\t};\n\n\t\tsymGoal.raw = baseRelation.raw;\n\t\tsymGoal.indexes = baseRelation.indexes;\n\n\t\treturn symGoal as FactRelation;\n\t}\n}\n\nexport class SymmetricMemoryObjRelation {\n\tprivate memoryObjRelation: MemoryObjRelation;\n\n\tconstructor(\n\t\tprivate keys: string[],\n\t\tlogger: Logger,\n\t\tconfig: FactRelationConfig,\n\t) {\n\t\tif (keys.length !== 2) {\n\t\t\tthrow new Error(\"Symmetric object relations must have exactly 2 keys\");\n\t\t}\n\t\tthis.memoryObjRelation = new MemoryObjRelation(keys, logger, config);\n\t}\n\n\tcreateRelation(): FactObjRelation {\n\t\tconst baseRelation = this.memoryObjRelation.createRelation();\n\t\tconst origSet = baseRelation.set;\n\n\t\tconst symGoal = (queryObj: Record<string, Term>) => {\n\t\t\treturn baseRelation(queryObj);\n\t\t};\n\n\t\tsymGoal.set = (factObj: Record<string, Term>) => {\n\t\t\tconst [key1, key2] = this.keys;\n\n\t\t\tif (!(key1 in factObj) || !(key2 in factObj)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Symmetric object fact must have both keys: ${key1}, ${key2}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Add both directions\n\t\t\torigSet(factObj);\n\n\t\t\t// Add reversed fact\n\t\t\tconst reversedFact = {\n\t\t\t\t[key1]: factObj[key2],\n\t\t\t\t[key2]: factObj[key1],\n\t\t\t\t...Object.fromEntries(\n\t\t\t\t\tObject.entries(factObj).filter(([k]) => k !== key1 && k !== key2),\n\t\t\t\t),\n\t\t\t};\n\t\t\torigSet(reversedFact);\n\t\t};\n\n\t\tsymGoal.raw = baseRelation.raw;\n\t\tsymGoal.indexes = baseRelation.indexes;\n\t\tsymGoal.keys = baseRelation.keys;\n\n\t\treturn symGoal as FactObjRelation;\n\t}\n}\n","import type { Logger } from \"logic\";\nimport { MemoryObjRelation } from \"./memory-obj-relation.js\";\nimport { MemoryRelation } from \"./memory-relation.js\";\nimport {\n\tSymmetricMemoryObjRelation,\n\tSymmetricMemoryRelation,\n} from \"./symmetric-relation.js\";\nimport type {\n\tFactObjRelation,\n\tFactRelation,\n\tFactRelationConfig,\n} from \"./types.js\";\n\nexport interface FactRelationFactoryDependencies {\n\tlogger: Logger;\n\tconfig: FactRelationConfig;\n}\n\nexport class FactRelationFactory {\n\tconstructor(private deps: FactRelationFactoryDependencies) {}\n\n\tcreateArrayRelation(): FactRelation {\n\t\tconst relation = new MemoryRelation(this.deps.logger, this.deps.config);\n\t\treturn relation.createRelation();\n\t}\n\n\tcreateObjectRelation(keys: string[]): FactObjRelation {\n\t\tconst relation = new MemoryObjRelation(\n\t\t\tkeys,\n\t\t\tthis.deps.logger,\n\t\t\tthis.deps.config,\n\t\t);\n\t\treturn relation.createRelation();\n\t}\n\n\tcreateSymmetricArrayRelation(): FactRelation {\n\t\tconst relation = new SymmetricMemoryRelation(\n\t\t\tthis.deps.logger,\n\t\t\tthis.deps.config,\n\t\t);\n\t\treturn relation.createRelation();\n\t}\n\n\tcreateSymmetricObjectRelation(keys: string[]): FactObjRelation {\n\t\tconst relation = new SymmetricMemoryObjRelation(\n\t\t\tkeys,\n\t\t\tthis.deps.logger,\n\t\t\tthis.deps.config,\n\t\t);\n\t\treturn relation.createRelation();\n\t}\n}\n"],"mappings":"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","names":["indexUtils","isVar","queryUtils","SimpleObservable","unificationUtils"]}