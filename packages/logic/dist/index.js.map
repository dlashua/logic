{"version":3,"sources":["../src/core/combinators.ts","../src/core/kernel.ts","../src/core/suspend-helper.ts","../src/core/subst-suspends.ts","../src/core/query.ts","../src/relations/aggregates.ts","../src/relations/aggregates-base.ts","../src/relations/aggregates-subqueries.ts","../src/relations/control.ts","../src/relations/lists.ts","../src/relations/numeric.ts","../src/relations/objects.ts","../src/shared/logger.ts","../src/shared/utils.ts","../src/util/procedural-helpers.ts"],"sourcesContent":["import jsonata from \"jsonata\";\nimport type { Observer, Subscription } from \"@codespiral/observable\";\nimport { SimpleObservable, flatMap, share, take } from \"@codespiral/observable\";\nimport {\n  arrayToLogicList,\n  enrichGroupInput,\n  isVar,\n  lvar,\n  unify,\n  walk,\n} from \"./kernel.js\";\nimport type {\n  Goal,\n  LiftableFunction,\n  LiftedArgs,\n  Subst,\n  Term,\n  Var,\n} from \"./types.js\";\n\n/**\n * A goal that succeeds if two terms can be unified.\n */\n// export function eq(u: Term, v: Term): Goal {\n//   return liftGoal(function eq (s: Subst){\n//     return new SimpleObservable<Subst>((observer) => {\n//       try {\n//         const result = unify(u, v, s);\n//         if (result !== null) {\n//           observer.next(result);\n//         }\n//         observer.complete?.();\n//       } catch (error) {\n//         observer.error?.(error);\n//       }\n//     });\n//   });\n// }\nexport function eq(x: Term, y: Term): Goal {\n  return enrichGroupInput(\n    \"eq\",\n    [],\n    [],\n    (input$) =>\n      new SimpleObservable((observer) => {\n        const sub = input$.subscribe({\n          error: (err: Error) => observer.error(err),\n          complete: () => observer.complete(),\n          next: (subst) => {\n            const s2 = unify(x, y, subst);\n            if (s2) {\n              observer.next(s2);\n            }\n          },\n        });\n\n        return () => sub.unsubscribe();\n      }),\n  );\n}\n// export function eq(x: Term<any>, y: Term<any>): Goal {\n//   return suspendable([x, y], (values, subst) => {\n//     const [xVal, yVal] = values;\n//     const xGrounded = !isVar(xVal);\n//     const yGrounded = !isVar(yVal);\n\n//     // All grounded - check constraint\n//     if (xGrounded && yGrounded) {\n//       return (xVal === yVal) ? subst : null;\n//     }\n\n//     if(xGrounded) {\n//       const s2 = unify(xVal, yVal, subst);\n//       if(s2) return s2;\n//       return null;\n//     }\n\n//     if(yGrounded) {\n//       const s2 = unify(yVal, xVal, subst);\n//       if(s2) return s2;\n//       return null;\n//     }\n\n//     return CHECK_LATER; // Still not enough variables bound\n//   });\n// }\n\n/**\n * Introduces new (fresh) logic variables into a sub-goal.\n */\nexport function fresh(f: (...vars: Var[]) => Goal): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const freshVars = Array.from({ length: f.length }, () => lvar());\n          const subGoal = f(...freshVars);\n          subGoal(SimpleObservable.of(s)).subscribe({\n            next: (v) => observer.next(v),\n            error: (e: Error) => observer.error(e),\n            complete: () => {\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            },\n          });\n        },\n        error: (err: Error) => observer.error(err),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * Logical disjunction (OR).\n */\nexport function disj(g1: Goal, g2: Goal): Goal {\n  return or(g1, g2);\n}\n\n/**\n * Logical conjunction (AND).\n */\nexport function conj(g1: Goal, g2: Goal): Goal {\n  return and(g1, g2);\n}\n\n/**\n * Helper for combining multiple goals with logical AND.\n * Creates a single group containing all goals for optimal SQL merging.\n */\n\nexport const and = (...goals: Goal[]): Goal => {\n  if (goals.length === 0) {\n    return (input$) => input$;\n  }\n  if (goals.length === 1) {\n    return goals[0];\n  }\n  return enrichGroupInput(\"and\", goals, [], (enrichedInput$) =>\n    goals.reduce((acc, goal) => goal(acc), enrichedInput$),\n  );\n};\n\n/**\n * Helper for combining multiple goals with logical OR.\n * Creates a single group containing all goals for optimal SQL merging.\n */\n\nexport const or = (...goals: Goal[]): Goal => {\n  if (goals.length === 0) {\n    return () => SimpleObservable.empty();\n  }\n  if (goals.length === 1) {\n    return goals[0];\n  }\n\n  return enrichGroupInput(\n    \"or\",\n    [],\n    goals,\n    (input$: SimpleObservable<Subst>) => {\n      return new SimpleObservable<Subst>((observer) => {\n        // Use the improved share() method that replays values for logic programming\n        const sharedInput$ = input$.pipe(share());\n\n        let completedGoals = 0;\n        const subscriptions: Subscription[] = [];\n\n        const sharedObserver = {\n          next: (value: Subst) => observer.next(value),\n          error: (err: Error) => observer.error(err),\n          complete: () => {\n            completedGoals++;\n            if (completedGoals === goals.length) {\n              observer.complete();\n            }\n          },\n        };\n        for (const goal of goals) {\n          const goalSubscription = goal(sharedInput$).subscribe(sharedObserver);\n          subscriptions.push(goalSubscription);\n        }\n\n        // for (const goal of goals) {\n        //   const goalSubscription = goal(sharedInput$).subscribe({\n        //     next: (v) => observer.next(v),\n        //     error: (e: Error) => observer.error(e),\n        //     complete: () => {\n        //       completedGoals++;\n        //       if (completedGoals === goals.length) {\n        //         observer.complete?.();\n        //       }\n        //     }\n        //   });\n        //   subscriptions.push(goalSubscription);\n        // }\n\n        return () => {\n          subscriptions.forEach((sub) => sub.unsubscribe?.());\n        };\n      });\n    },\n  );\n};\n\n/**\n * Multi-clause disjunction (OR).\n */\nexport function conde(...clauses: Goal[][]): Goal {\n  const clauseGoals = clauses.map((clause) => and(...clause));\n  return or(...clauseGoals);\n}\n\n/**\n * Lifts a pure JavaScript function into a Goal function.\n */\nexport function lift<U, T extends LiftableFunction<U>>(\n  fn: T,\n): LiftedArgs<T, U> {\n  return ((...args: [Term[], Term<U>]) => {\n    // Extract the 'out' parameter (last argument)\n    const out = args[args.length - 1];\n    const inputArgs = args.slice(0, -1);\n    return (input$: SimpleObservable<Subst>) =>\n      new SimpleObservable<Subst>((observer) => {\n        const subscription = input$.subscribe({\n          next: (s) => {\n            try {\n              // Walk all input arguments to resolve any variables\n              const resolvedArgs = inputArgs.map((arg) => walk(arg, s));\n              // Check if all arguments are ground (no variables)\n              const hasVariables = resolvedArgs.some((arg) => isVar(arg));\n              if (!hasVariables) {\n                // All arguments are ground, we can call the function\n                const result = fn(...resolvedArgs);\n                // Unify the result with the output parameter\n                const unified = unify(out, result, s);\n                if (unified !== null) {\n                  observer.next(unified);\n                }\n              }\n            } catch (error) {\n              observer.error?.(error);\n            }\n          },\n          error: (e: Error) => observer.error(e),\n          complete: () => observer.complete(),\n        });\n        return () => subscription.unsubscribe?.();\n      });\n  }) as LiftedArgs<T, U>;\n}\n\n/**\n * Either-or combinator: tries the first goal, and only if it produces no results,\n * tries the second goal. This is different from `or` which tries both goals.\n */\nexport function eitherOr(firstGoal: Goal, secondGoal: Goal): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          let hasResults = false;\n          const results: Subst[] = [];\n\n          firstGoal(SimpleObservable.of(s)).subscribe({\n            next: (s1) => {\n              hasResults = true;\n              results.push(s1);\n            },\n            complete: () => {\n              if (hasResults) {\n                // First goal succeeded, emit all its results\n                for (const result of results) {\n                  observer.next(result);\n                }\n              } else {\n                // First goal failed, try second goal\n                secondGoal(SimpleObservable.of(s)).subscribe({\n                  next: (v) => observer.next(v),\n                  error: (e: Error) => observer.error(e),\n                  complete: () => {\n                    active--;\n                    if (completed && active === 0) observer.complete?.();\n                  },\n                });\n                return; // Skip the active-- below since secondGoal will handle it\n              }\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            },\n            error: (e: Error) => observer.error(e),\n          });\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * Soft-cut if-then-else combinator.\n */\nexport function ifte(ifGoal: Goal, thenGoal: Goal, elseGoal: Goal): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          let succeeded = false;\n          const results: Subst[] = [];\n          ifGoal(SimpleObservable.of(s)).subscribe({\n            next: (s1) => {\n              succeeded = true;\n              results.push(s1);\n            },\n            complete: () => {\n              if (succeeded) {\n                let completed = 0;\n                for (const s1 of results) {\n                  thenGoal(SimpleObservable.of(s1)).subscribe({\n                    next: (v) => observer.next(v),\n                    error: (e: Error) => observer.error(e),\n                    complete: () => {\n                      completed++;\n                      if (completed === results.length) {\n                        observer.complete?.();\n                      }\n                    },\n                  });\n                }\n                if (results.length === 0) {\n                  observer.complete?.();\n                }\n              } else {\n                elseGoal(SimpleObservable.of(s)).subscribe({\n                  next: (v) => observer.next(v),\n                  complete: () => observer.complete(),\n                  error: (e: Error) => observer.error(e),\n                });\n              }\n            },\n            error: (e: Error) => observer.error(e),\n          });\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n\n/**\n * Succeeds exactly once with the given substitution (useful for cut-like behavior)\n */\nexport function once(goal: Goal): Goal {\n  return (input$) => goal(input$).pipe(take(1));\n}\n\n/**\n * Apply a goal with a timeout\n */\nexport function timeout(goal: Goal, timeoutMs: number): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let completed = false;\n      const timer = setTimeout(() => {\n        if (!completed) {\n          completed = true;\n          observer.error?.(new Error(`Goal timed out after ${timeoutMs}ms`));\n        }\n      }, timeoutMs);\n      goal(input$).subscribe({\n        next: (result) => {\n          if (!completed) {\n            observer.next(result);\n          }\n        },\n        complete: () => {\n          if (!completed) {\n            completed = true;\n            clearTimeout(timer);\n            observer.complete?.();\n          }\n        },\n        error: (error) => {\n          if (!completed) {\n            completed = true;\n            clearTimeout(timer);\n            observer.error?.(error);\n          }\n        },\n      });\n      return () => {\n        clearTimeout(timer);\n      };\n    });\n}\n\n/**\n * Run a goal and collect results with optional limits\n */\nexport function run(\n  goal: Goal,\n  maxResults?: number,\n  timeoutMs?: number,\n): Promise<{ results: Subst[]; completed: boolean; error?: string | Error }> {\n  return new Promise((resolve) => {\n    const results: Subst[] = [];\n    let completed = false;\n    let error: string | Error;\n    const effectiveGoal = timeoutMs ? timeout(goal, timeoutMs) : goal;\n    const limitedGoal = maxResults\n      ? (input$: SimpleObservable<Subst>) =>\n          effectiveGoal(input$).pipe(take(maxResults))\n      : effectiveGoal;\n    limitedGoal(SimpleObservable.of(new Map())).subscribe({\n      next: (result) => {\n        results.push(result);\n      },\n      complete: () => {\n        completed = true;\n        resolve({\n          results,\n          completed,\n          error,\n        });\n      },\n      error: (err) => {\n        error = err;\n        resolve({\n          results,\n          completed,\n          error,\n        });\n      },\n    });\n  });\n}\n\n/**\n * project: Declarative data transformation relation for logic engine.\n * Allows extracting or mapping fields from an object using a path string or mapping object.\n * Example:\n *   project($.input, \"species.name\", $.species_name)\n *   project($.input, { genus: \"genera[0].genus\" }, $.output)\n */\nfunction getByPath(obj: unknown, path: string): unknown {\n  if (!path) return obj;\n  const parts = path.split(\".\");\n  let current: unknown = obj;\n  for (const part of parts) {\n    if (!current) return undefined;\n    const match = part.match(/^(\\w+)\\[\\?\\(@\\.(.+?)==['\"](.+?)['\"]\\)\\]$/);\n    if (match) {\n      const [_, arrKey, filterKey, filterVal] = match;\n      const currentObj = current as Record<string, unknown>;\n      const array = currentObj[arrKey] as unknown[];\n      current = (array || []).find((x: unknown) => {\n        const item = x as Record<string, unknown>;\n        return item?.[filterKey] === filterVal;\n      });\n    } else if (part.endsWith(\"]\")) {\n      const arrMatch = part.match(/^(\\w+)\\[(\\d+)\\]$/);\n      if (arrMatch) {\n        const [_, arrKey, idx] = arrMatch;\n        const currentObj = current as Record<string, unknown>;\n        const array = currentObj[arrKey] as unknown[];\n        current = (array || [])[parseInt(idx)];\n      } else {\n        const currentObj = current as Record<string, unknown>;\n        current = currentObj[part];\n      }\n    } else {\n      const currentObj = current as Record<string, unknown>;\n      current = currentObj[part];\n    }\n  }\n  return current;\n}\n\n// project(input, \"field.path\", outputVar)\n// project(input, { out1: \"path1\", out2: \"path2\" }, outputObjVar)\nexport function project(\n  inputVar: Term,\n  pathOrMap: string | Record<string, string>,\n  outputVar: Term,\n): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const subscription = input$.subscribe({\n        next: (s) => {\n          const input = walk(inputVar, s);\n          if (isVar(input)) return;\n          if (input === undefined) return;\n          if (typeof pathOrMap === \"string\") {\n            const value = getByPath(input, pathOrMap);\n            const unified = unify(outputVar, value, s);\n            if (unified !== null) observer.next(unified);\n          } else {\n            const outObj: Record<string, unknown> = {};\n            for (const key in pathOrMap) {\n              outObj[key] = getByPath(input, pathOrMap[key]);\n            }\n            const unified = unify(outputVar, outObj, s);\n            if (unified !== null) observer.next(unified);\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * projectJsonata: Declarative data transformation using JSONata expressions.\n *\n * @param inputVars - An object mapping keys to logic vars, or a single logic var.\n * @param jsonataExpr - The JSONata template string.\n * @param outputVars - An object mapping output keys to logic vars, or a single logic var.\n *\n * Example:\n *   projectJsonata({ x: $.some_var, y: $.some_other_var }, \"{ thing: x, thang: y }\", { thing: $.thing_here, thang: $.thang_here })\n *   projectJsonata($.input, \"$value + 1\", $.output)\n */\nexport function projectJsonata(\n  inputVars: Term | Record<string, Term>,\n  jsonataExpr: string,\n  outputVars: Term | Record<string, Term>,\n): Goal {\n  const expr = jsonata(jsonataExpr);\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: async (s) => {\n          active++;\n          // Prepare input for JSONata\n          let inputObj: unknown;\n          if (\n            typeof inputVars === \"object\" &&\n            inputVars !== null &&\n            !isVar(inputVars)\n          ) {\n            const objInput: Record<string, unknown> = {};\n            const inputVarsRecord = inputVars as Record<string, Term>;\n            for (const key in inputVarsRecord) {\n              objInput[key] = walk(inputVarsRecord[key], s);\n            }\n            inputObj = objInput;\n          } else {\n            inputObj = walk(inputVars, s);\n          }\n          // Evaluate JSONata\n          let result: unknown;\n          try {\n            result = await expr.evaluate(inputObj);\n          } catch (e) {\n            observer.error?.(e);\n            active--;\n            if (completed && active === 0) observer.complete?.();\n            return;\n          }\n          // Unify result to output logic vars\n          if (\n            typeof outputVars === \"object\" &&\n            outputVars !== null &&\n            !isVar(outputVars)\n          ) {\n            const outputVarsRecord = outputVars as Record<string, Term>;\n            if (\n              result &&\n              typeof result === \"object\" &&\n              \"then\" in result &&\n              typeof (result as { then: unknown }).then === \"function\"\n            ) {\n              (result as Promise<unknown>)\n                .then((resolved: unknown) => {\n                  let currentSubst = s;\n                  for (const key in outputVarsRecord) {\n                    const value =\n                      resolved &&\n                      typeof resolved === \"object\" &&\n                      resolved !== null\n                        ? (resolved as Record<string, unknown>)[key]\n                        : undefined;\n                    const unified = unify(\n                      outputVarsRecord[key],\n                      value,\n                      currentSubst,\n                    );\n                    if (unified !== null) {\n                      currentSubst = unified;\n                    } else {\n                      // If any unification fails, skip this result\n                      active--;\n                      if (completed && active === 0) observer.complete?.();\n                      return;\n                    }\n                  }\n                  observer.next(currentSubst);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                })\n                .catch((e: unknown) => {\n                  observer.error?.(e);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                });\n            } else {\n              const resolved = result;\n              let currentSubst = s;\n              for (const key in outputVarsRecord) {\n                const value =\n                  resolved && typeof resolved === \"object\" && resolved !== null\n                    ? (resolved as Record<string, unknown>)[key]\n                    : undefined;\n                const unified = unify(\n                  outputVarsRecord[key],\n                  value,\n                  currentSubst,\n                );\n                if (unified !== null) {\n                  currentSubst = unified;\n                } else {\n                  // If any unification fails, skip this result\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                  return;\n                }\n              }\n              observer.next(currentSubst);\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            }\n          } else {\n            if (\n              result &&\n              typeof result === \"object\" &&\n              \"then\" in result &&\n              typeof (result as { then: unknown }).then === \"function\"\n            ) {\n              (result as Promise<unknown>)\n                .then((resolved: unknown) => {\n                  const unified = unify(outputVars, resolved, s);\n                  if (unified !== null) observer.next(unified);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                })\n                .catch((e: unknown) => {\n                  observer.error?.(e);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                });\n            } else {\n              const unified = unify(outputVars, result, s);\n              if (unified !== null) observer.next(unified);\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            }\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * Subquery: Run a subgoal and bind its results to a variable in the main stream.\n * This is the universal bridge between goal-based and stream-based operations.\n *\n * @param goal - The subgoal to run\n * @param extractVar - Variable to extract from subgoal results\n * @param bindVar - Variable to bind the extracted results to in main stream\n * @param aggregator - How to combine multiple results (receives results and original substitution)\n *\n * Examples:\n * - Subquery(membero(x, [1,2,3]), x, $.items) // binds $.items to [1,2,3]\n * - Subquery(goal, x, $.count, (results, _) => results.length) // binds $.count to result count\n * - Subquery(goal, x, $.count, (results, s) => results.filter(r => r === walk(target, s)).length) // count matches\n */\nexport function Subquery(\n  goal: Goal,\n  extractVar: Term,\n  bindVar: Term,\n  aggregator: (results: unknown[], originalSubst: Subst) => unknown = (\n    results,\n    _,\n  ) => arrayToLogicList(results),\n): Goal {\n  return enrichGroupInput(\"Subquery\", [], [goal], (input$) =>\n    input$.pipe(\n      flatMap((s: Subst) => {\n        const extracted: unknown[] = [];\n\n        return new SimpleObservable<Subst>((observer) => {\n          const subgoalSubscription = goal(SimpleObservable.of(s)).subscribe({\n            next: (subResult) => {\n              // Extract the value from each subgoal result\n              const value = walk(extractVar, subResult);\n              extracted.push(value);\n            },\n            error: (error) => {\n              extracted.length = 0;\n              observer.error?.(error);\n            },\n            complete: () => {\n              // Aggregate all extracted values and bind to the target variable\n              // Pass the original substitution so aggregator can walk variables\n              const aggregated = aggregator(extracted, s);\n              const unified = unify(bindVar, aggregated, s);\n              if (unified !== null) {\n                observer.next(unified);\n              }\n              extracted.length = 0;\n              observer.complete?.();\n            },\n          });\n\n          return () => {\n            subgoalSubscription.unsubscribe?.();\n            extracted.length = 0;\n          };\n        });\n      }),\n    ),\n  );\n}\n\nexport function branch(\n  goal: Goal,\n  aggregator: (\n    observer: Observer<Subst>,\n    substs: Subst[],\n    originalSubst: Subst,\n  ) => void,\n): Goal {\n  return enrichGroupInput(\n    \"branch\",\n    [],\n    [goal],\n    (input$) =>\n      new SimpleObservable<Subst>((observer) => {\n        const goalSubs: Subscription[] = [];\n        const inputSub = input$.subscribe({\n          error: (e: Error) => observer.error(e),\n          complete: () => observer.complete(),\n          next: (inputSubst) => {\n            const collectedSubsts: Subst[] = [];\n            const goalSub = goal(SimpleObservable.of(inputSubst)).subscribe({\n              error: (e: Error) => observer.error(e),\n              complete: () => {\n                aggregator(observer, collectedSubsts, inputSubst);\n                // observer.complete?.();\n                collectedSubsts.length = 0;\n              },\n              next: (goalSubst) => {\n                collectedSubsts.push(goalSubst);\n              },\n            });\n            goalSubs.push(goalSub);\n          },\n        });\n\n        return () => {\n          goalSubs.forEach((goalSub) => goalSub.unsubscribe());\n          inputSub.unsubscribe();\n        };\n      }),\n  );\n}\n","import { SimpleObservable, map } from \"@codespiral/observable\";\nimport { SUSPENDED_CONSTRAINTS, wakeUpSuspends } from \"./subst-suspends.js\";\nimport type {\n  ConsNode,\n  Goal,\n  LogicList,\n  NilNode,\n  Subst,\n  Term,\n  Var,\n} from \"./types.js\";\n\n// Well-known symbols for SQL query coordination\nexport const GOAL_GROUP_ID = Symbol(\"goal-group-id\");\nexport const GOAL_GROUP_PATH = Symbol(\"goal-group-path\");\nexport const GOAL_GROUP_CONJ_GOALS = Symbol(\"goal-group-conj-goals\"); // Goals in immediate group\nexport const GOAL_GROUP_ALL_GOALS = Symbol(\"goal-group-all-goals\"); // Goals across all related groups\n\nlet varCounter = 0;\nlet groupCounter = 0;\nexport function nextGroupId() {\n  return groupCounter++;\n}\n\n/**\n * Creates a new, unique logic variable.\n * @param name An optional prefix for debugging.\n */\nexport function lvar(name = \"\"): Var {\n  return {\n    tag: \"var\",\n    id: `${name}_${varCounter++}`,\n  };\n}\n\n/**\n * Resets the global variable counter for deterministic tests.\n */\nexport function resetVarCounter(): void {\n  varCounter = 0;\n}\n\n/**\n * Recursively finds the ultimate binding of a term in a given substitution.\n * Optimized to use iteration for variable chains and avoid deep recursion.\n * @param u The term to resolve.\n * @param s The substitution map.\n */\nexport function walk(u: Term, s: Subst): Term {\n  let current = u;\n\n  if (\n    !isVar(current) &&\n    !isCons(current) &&\n    !Array.isArray(current) &&\n    typeof current !== \"object\"\n  ) {\n    return current; // Fast exit for primitives\n  }\n\n  // Fast path for variable chains - use iteration instead of recursion\n  while (isVar(current) && s.has(current.id)) {\n    current = s.get(current.id);\n  }\n\n  // If we ended up with a non-variable, check if it needs structural walking\n  if (isCons(current)) {\n    // Walk both parts of the cons cell\n    return cons(walk(current.head, s), walk(current.tail, s));\n  }\n\n  if (Array.isArray(current)) {\n    return current.map((x) => walk(x, s));\n  }\n\n  if (\n    current &&\n    typeof current === \"object\" &&\n    !isVar(current) &&\n    !isLogicList(current)\n  ) {\n    const out: Record<string, Term> = {};\n    for (const k in current) {\n      if (Object.hasOwn(current, k)) {\n        out[k] = walk((current as any)[k], s);\n      }\n    }\n    return out;\n  }\n\n  return current;\n}\n\n/**\n * Extends a substitution by binding a variable to a value, with an occurs check.\n */\nexport function extendSubst(v: Var, val: Term, s: Subst): Subst | null {\n  if (occursCheck(v, val, s)) {\n    return null; // Occurs check failed\n  }\n  const s2 = new Map(s);\n  s2.set(v.id, val);\n  return s2;\n}\n\n/**\n * Checks if a variable `v` occurs within a term `x` to prevent infinite loops.\n */\nfunction occursCheck(v: Var, x: Term, s: Subst): boolean {\n  const resolvedX = walk(x, s);\n  if (isVar(resolvedX)) {\n    return v.id === resolvedX.id;\n  }\n  if (isCons(resolvedX)) {\n    return (\n      occursCheck(v, resolvedX.head, s) || occursCheck(v, resolvedX.tail, s)\n    );\n  }\n  if (Array.isArray(resolvedX)) {\n    for (const item of resolvedX) {\n      if (occursCheck(v, item, s)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * The core unification algorithm. It attempts to make two terms structurally equivalent.\n * Optimized with fast paths for common cases.\n */\nexport function baseUnify(u: Term, v: Term, s: Subst | null): Subst | null {\n  if (s === null) {\n    return null;\n  }\n\n  // Fast path: if both terms are identical primitives, no walking needed\n  if (u === v) {\n    return s;\n  }\n\n  const uWalked = walk(u, s);\n  const vWalked = walk(v, s);\n\n  // Fast path: after walking, if they're still identical, succeed\n  if (uWalked === vWalked) {\n    return s;\n  }\n\n  if (isVar(uWalked)) return extendSubst(uWalked, vWalked, s);\n  if (isVar(vWalked)) return extendSubst(vWalked, uWalked, s);\n\n  // Fast paths for primitive types\n  if (typeof uWalked === \"number\" && typeof vWalked === \"number\") {\n    return uWalked === vWalked ? s : null;\n  }\n\n  if (typeof uWalked === \"string\" && typeof vWalked === \"string\") {\n    return uWalked === vWalked ? s : null;\n  }\n\n  if (isNil(uWalked) && isNil(vWalked)) return s;\n  if (isCons(uWalked) && isCons(vWalked)) {\n    const s1 = unify(uWalked.head, vWalked.head, s);\n    if (s1 === null) return null;\n    return unify(uWalked.tail, vWalked.tail, s1);\n  }\n\n  if (\n    Array.isArray(uWalked) &&\n    Array.isArray(vWalked) &&\n    uWalked.length === vWalked.length\n  ) {\n    let currentSubst: Subst | null = s;\n    for (let i = 0; i < uWalked.length; i++) {\n      currentSubst = unify(uWalked[i], vWalked[i], currentSubst);\n      if (currentSubst === null) return null;\n    }\n    return currentSubst;\n  }\n\n  if (JSON.stringify(uWalked) === JSON.stringify(vWalked)) {\n    return s;\n  }\n\n  return null;\n}\n\n/**\n * Constraint-aware unify that wakes up suspended constraints when variables are bound\n */\n\nexport function unifyWithConstraints(\n  u: Term,\n  v: Term,\n  s: Subst | null,\n): Subst | null {\n  const result = baseUnify(u, v, s);\n\n  if (result !== null && s !== null) {\n    // Fast path: if no constraints exist, skip constraint logic\n    if (!result.has(SUSPENDED_CONSTRAINTS)) {\n      return result;\n    }\n\n    // Check what new variables were bound\n    const newlyBoundVars: string[] = [];\n    for (const [key] of result) {\n      if (!s.has(key) && typeof key === \"string\") {\n        newlyBoundVars.push(key);\n      }\n    }\n\n    // Wake up constraints for newly bound variables (if any)\n    if (newlyBoundVars.length > 0) {\n      return wakeUpSuspends(result, newlyBoundVars);\n    }\n  }\n\n  return result;\n}\n\nexport const unify = unifyWithConstraints;\n// export const unify = baseUnify;\n\n/**\n * Type guard to check if a term is a logic variable.\n */\nexport function isVar(x: Term): x is Var {\n  return typeof x === \"object\" && x !== null && (x as Var).tag === \"var\";\n}\n\n/**\n * The canonical `nil` value, representing an empty logic list.\n */\nexport const nil: NilNode = { tag: \"nil\" };\n\n/**\n * Creates a `cons` cell (a node in a logic list).\n */\nexport function cons(head: Term, tail: Term): ConsNode {\n  return {\n    tag: \"cons\",\n    head,\n    tail,\n  };\n}\n\n/**\n * Converts a JavaScript array into a logic list.\n */\nexport function arrayToLogicList(arr: Term[]): LogicList {\n  return arr.reduceRight<LogicList>((tail, head) => cons(head, tail), nil);\n}\n\n/**\n * A convenience function to create a logic list from arguments.\n */\nexport function logicList<T = unknown>(...items: T[]): LogicList {\n  return arrayToLogicList(items);\n}\n\n/**\n * Type guard to check if a term is a `cons` cell.\n */\nexport function isCons(x: Term): x is ConsNode {\n  return typeof x === \"object\" && x !== null && (x as ConsNode).tag === \"cons\";\n}\n\n/**\n * Type guard to check if a term is `nil`.\n */\nexport function isNil(x: Term): x is NilNode {\n  return typeof x === \"object\" && x !== null && (x as NilNode).tag === \"nil\";\n}\n\n/**\n * Type guard to check if a term is a logic list.\n */\nexport function isLogicList(x: Term): x is LogicList {\n  return isCons(x) || isNil(x);\n}\n\n/**\n * Converts a logic list to a JavaScript array.\n */\nexport function logicListToArray(list: Term): Term[] {\n  const out = [];\n  let cur = list;\n  while (\n    cur &&\n    typeof cur === \"object\" &&\n    \"tag\" in cur &&\n    (cur as any).tag === \"cons\"\n  ) {\n    out.push((cur as any).head);\n    cur = (cur as any).tail;\n  }\n  return out;\n}\n\n// Helper: Convert a single-substitution goal to the new protocol\nexport function liftGoal(\n  singleGoal: (s: Subst) => SimpleObservable<Subst>,\n): Goal {\n  const groupType = singleGoal.name || \"liftGoal\";\n  return enrichGroupInput(\n    groupType,\n    [],\n    [],\n    (input$) =>\n      new SimpleObservable((observer) => {\n        const subs = input$.subscribe({\n          next: (s) => {\n            const out$ = singleGoal(s);\n            out$.subscribe({\n              next: (s2) => observer.next(s2),\n              error: (e) => observer.error?.(e),\n              complete: () => {\n                /* pass */\n              }, // wait for all\n            });\n          },\n          error: (e) => observer.error?.(e),\n          complete: () => observer.complete?.(),\n        });\n        return () => subs.unsubscribe?.();\n      }),\n  );\n}\n\n// Helper: Chain goals (like flatMap for observables)\nexport function chainGoals(\n  goals: Goal[],\n  initial$: SimpleObservable<Subst>,\n): SimpleObservable<Subst> {\n  return goals.reduce((input$, goal) => goal(input$), initial$);\n}\n\n/**\n * Creates an enriched substitution with group metadata\n */\nexport function createEnrichedSubst(\n  s: Subst,\n  type: string,\n  conjGoals: Goal[],\n  disjGoals: Goal[],\n  branch?: number,\n): Subst {\n  const groupId = nextGroupId();\n  const parentPath = (s.get(GOAL_GROUP_PATH) as any[]) || [];\n  const newPath = [\n    ...parentPath,\n    {\n      type: Symbol(type),\n      id: groupId,\n      ...(branch !== undefined ? { branch } : {}),\n    },\n  ];\n  const parentOuterGoals = (s.get(GOAL_GROUP_ALL_GOALS) as Goal[]) || [];\n  // Recursively collect all innerGoals from the combined goals array\n  function collectAllInnerConjGoals(goals: Goal[]): Goal[] {\n    return goals.flatMap((goal) => {\n      const innerGoals = (goal as any)?.conjGoals ?? ([] as Goal[]);\n      if (innerGoals && innerGoals.length > 0) {\n        return [...collectAllInnerConjGoals(innerGoals)];\n      } else {\n        return [goal];\n      }\n    });\n  }\n  function collectAllInnerGoals(goals: Goal[]): Goal[] {\n    return goals.flatMap((goal) => {\n      const innerConjGoals = (goal as any)?.conjGoals ?? ([] as Goal[]);\n      const innerDisjGoals = (goal as any)?.disjGoals ?? ([] as Goal[]);\n      const innerGoals = [...new Set([...innerConjGoals, ...innerDisjGoals])];\n      if (innerGoals && innerGoals.length > 0) {\n        return [...collectAllInnerGoals(innerGoals)];\n      } else {\n        return [goal];\n      }\n    });\n  }\n\n  const allGoals = [...conjGoals, ...disjGoals];\n  const conjInnerConj = collectAllInnerConjGoals(conjGoals);\n  const disjInnerAll = collectAllInnerGoals(allGoals);\n\n  const newSubst = new Map(s);\n  newSubst.set(GOAL_GROUP_ID, groupId);\n  newSubst.set(GOAL_GROUP_PATH, newPath);\n  newSubst.set(GOAL_GROUP_CONJ_GOALS, [\n    ...new Set([...conjGoals, ...conjInnerConj]),\n  ]);\n  newSubst.set(GOAL_GROUP_ALL_GOALS, [\n    ...new Set([\n      ...parentOuterGoals,\n      ...conjGoals,\n      ...disjGoals,\n      ...disjInnerAll,\n    ]),\n  ]);\n  return newSubst;\n}\n\n/**\n * Unified helper for enriching input with group metadata\n */\nexport function enrichGroupInput(\n  type: string,\n  conjGoals: Goal[],\n  disjGoals: Goal[],\n  fn: (enrichedInput$: SimpleObservable<Subst>) => SimpleObservable<Subst>,\n) {\n  function newInput$(input$: SimpleObservable<Subst>) {\n    const enrichedInput$ = input$.pipe(\n      map((s) => createEnrichedSubst(s, type, conjGoals, disjGoals)),\n    );\n    return fn(enrichedInput$);\n  }\n  (newInput$ as any).conjGoals = conjGoals;\n  (newInput$ as any).disjGoals = disjGoals;\n  Object.defineProperty(newInput$, \"name\", { value: type });\n  return newInput$;\n}\n","import { SimpleObservable } from \"@codespiral/observable\";\nimport { isVar, walk } from \"./kernel.js\";\nimport { addSuspendToSubst } from \"./subst-suspends.js\";\nimport type { Goal, Subst, Term, Var } from \"./types.js\";\n\nexport const CHECK_LATER = Symbol.for(\"constraint-check-later\");\n\n/**\n * Generic constraint helper that handles suspension automatically\n */\n\nexport function makeSuspendHandler(\n  vars: Term[],\n  evaluator: (\n    values: Term[],\n    subst: Subst,\n  ) => Subst | null | typeof CHECK_LATER,\n  minGrounded: number,\n) {\n  return function handleSuspend(subst: Subst): Subst | null {\n    const values = vars.map((v) => walk(v, subst));\n    const groundedCount = values.filter((v) => !isVar(v)).length;\n\n    if (groundedCount >= minGrounded) {\n      const result = evaluator(values, subst);\n      if (result === null) {\n        return null;\n      }\n      if (result !== CHECK_LATER) {\n        return result;\n      }\n      // If we get here, result === CHECK_LATER, so fall through to suspension logic\n    }\n\n    // Only suspend if there are variables to watch\n    const watchedVars: string[] = vars\n      .filter((v) => isVar(v))\n      .map((v) => (v as Var).id); // Type-safe access to Var.id\n    if (watchedVars.length > 0) {\n      return addSuspendToSubst(subst, handleSuspend, watchedVars);\n    }\n    return null; // No variables to watch and CHECK_LATER returned, fail\n  };\n}\n\nexport function suspendable<T extends Term[]>(\n  vars: T,\n  evaluator: (\n    values: Term[],\n    subst: Subst,\n  ) => Subst | null | typeof CHECK_LATER,\n  minGrounded = vars.length - 1,\n): Goal {\n  const handleSuspend = makeSuspendHandler(vars, evaluator, minGrounded);\n  // console.log(\"VARS\", vars);\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const sub = input$.subscribe({\n        next: (subst) => {\n          try {\n            const result = handleSuspend(subst);\n            if (result !== null) {\n              observer.next(result);\n              return;\n            }\n            // console.log(\"SUSPEND DIED\");\n          } catch (error) {\n            observer.error?.(error);\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n\n      return () => sub.unsubscribe();\n    });\n}\n","import { isVar, walk } from \"./kernel.js\";\nimport { CHECK_LATER } from \"./suspend-helper.js\";\nimport type { Subst } from \"./types.js\";\n\nexport const SUSPENDED_CONSTRAINTS = Symbol(\"suspended-constraints\");\n\nexport interface SuspendedConstraint {\n  id: string;\n  resumeFn: (subst: Subst) => Subst | null | typeof CHECK_LATER;\n  watchedVars: string[];\n}\n\nlet constraintCounter = 0;\nconst MAX_COUNTER = 1000000; // Reset after 1M constraints to prevent overflow\n\nexport function addSuspendToSubst(\n  subst: Subst,\n  resumeFn: (subst: Subst) => Subst | null | typeof CHECK_LATER,\n  watchedVars: string[],\n): Subst {\n  const suspends =\n    (subst.get(SUSPENDED_CONSTRAINTS) as SuspendedConstraint[]) || [];\n\n  // **Issue #3: Automatic pruning** - Check if constraint is already irrelevant\n  const stillRelevantVars = watchedVars.filter((varId) => {\n    const value = walk({ tag: \"var\", id: varId }, subst);\n    return isVar(value); // Only keep if variable is still unbound\n  });\n\n  // If no variables left to watch, don't add the constraint\n  if (stillRelevantVars.length === 0) {\n    return subst;\n  }\n\n  // Reset counter periodically to prevent unbounded growth\n  if (constraintCounter >= MAX_COUNTER) {\n    constraintCounter = 0;\n  }\n\n  const newSuspend: SuspendedConstraint = {\n    id: `constraint_${constraintCounter++}`,\n    resumeFn,\n    // watchedVars: stillRelevantVars // Use pruned list\n    watchedVars,\n  };\n\n  const newSubst = new Map(subst);\n  newSubst.set(SUSPENDED_CONSTRAINTS, [...suspends, newSuspend]);\n  return newSubst;\n}\n\nexport function getSuspendsFromSubst(subst: Subst): SuspendedConstraint[] {\n  return (subst.get(SUSPENDED_CONSTRAINTS) as SuspendedConstraint[]) || [];\n}\n\nexport function removeSuspendFromSubst(\n  subst: Subst,\n  suspendIds: string[],\n): Subst {\n  const suspends = getSuspendsFromSubst(subst);\n  const filteredSuspends = suspends.filter((c) => !suspendIds.includes(c.id));\n\n  const newSubst = new Map(subst);\n  if (filteredSuspends.length === 0) {\n    newSubst.delete(SUSPENDED_CONSTRAINTS);\n  } else {\n    newSubst.set(SUSPENDED_CONSTRAINTS, filteredSuspends);\n  }\n  return newSubst;\n}\n\nexport function wakeUpSuspends(\n  subst: Subst,\n  newlyBoundVars: string[],\n): Subst | null {\n  const suspends = getSuspendsFromSubst(subst);\n  if (suspends.length === 0) {\n    return subst;\n  }\n\n  // Partition suspends: those to wake up, and those to keep\n  const [toWake, toKeep] = suspends.reduce<\n    [SuspendedConstraint[], SuspendedConstraint[]]\n  >(\n    ([wake, keep], s) =>\n      s.watchedVars.some((v) => newlyBoundVars.includes(v))\n        ? [[...wake, s], keep]\n        : [wake, [...keep, s]],\n    [[], []],\n  );\n\n  // Remove only the suspends to be woken up\n  // let currentSubst = removeSuspendFromSubst(subst, toWake.map(x => x.id));\n  let currentSubst = subst;\n\n  for (const suspend of toWake) {\n    const result = suspend.resumeFn(currentSubst);\n    if (result === null) {\n      return null;\n    } else if (result === CHECK_LATER) {\n      // If still needs to be suspended, add back to suspends\n      toKeep.push(suspend);\n    } else {\n      toKeep.push(suspend);\n\n      currentSubst = result;\n    }\n  }\n\n  // currentSubst = removeSuspendFromSubst(subst, toWake.map(x => x.id));\n\n  // Restore any suspends that remain (not woken, or still suspended)\n  // if (toKeep.length > 0) {\n  //   const newSubst = new Map(currentSubst);\n  //   newSubst.set(SUSPENDED_CONSTRAINTS, toKeep);\n  //   return newSubst;\n  // }\n  return currentSubst;\n}\n","import type { Observable } from \"@codespiral/observable\";\nimport { SimpleObservable } from \"@codespiral/observable\";\nimport { and } from \"./combinators.js\";\nimport { isLogicList, isVar, logicListToArray, lvar, walk } from \"./kernel.js\";\nimport type { Goal, RunResult, Subst, Var } from \"./types.js\";\n\n/**\n * Recursively walks a result object, converting any logic lists into JS arrays.\n */\nfunction deepListWalk(val: any): any {\n  if (isLogicList(val)) {\n    return logicListToArray(val).map(deepListWalk);\n  } else if (Array.isArray(val)) {\n    return val.map(deepListWalk);\n  } else if (val && typeof val === \"object\" && !isVar(val)) {\n    const out: any = {};\n    for (const k in val) {\n      if (Object.hasOwn(val, k)) {\n        out[k] = deepListWalk(val[k]);\n      }\n    }\n    return out;\n  }\n  return val;\n}\n\n/**\n * Creates a proxy object that automatically creates logic variables on access.\n */\nexport function createLogicVarProxy<K extends string | symbol = string>(\n  prefix = \"\",\n): { proxy: Record<K, Var>; varMap: Map<K, Var> } {\n  const varMap = new Map<K, Var>();\n  const proxy = new Proxy({} as Record<K, Var>, {\n    get(_target, prop: K) {\n      if (typeof prop !== \"string\") return undefined;\n      if (prop === \"_\") return lvar();\n      if (!varMap.has(prop)) {\n        varMap.set(prop, lvar(`${prefix}${String(prop)}`));\n      }\n      return varMap.get(prop);\n    },\n    has: () => true,\n    ownKeys: () => Array.from(varMap.keys()),\n    getOwnPropertyDescriptor: () => ({\n      enumerable: true,\n      configurable: true,\n    }),\n  });\n  return {\n    proxy,\n    varMap,\n  };\n}\n\n/**\n * Formats the raw substitution streams into user-friendly result objects.\n */\nfunction formatSubstitutions<Fmt>(\n  substs: Observable<Subst>,\n  formatter: Fmt,\n  limit: number,\n): Observable<RunResult<Fmt>> {\n  // Use the built-in take operator which properly handles cleanup\n  const limitedSubsts =\n    limit === Infinity ? substs : (substs as any).take(limit);\n  return new SimpleObservable((observer) => {\n    const unsub = limitedSubsts.subscribe({\n      next: (s: Subst) => {\n        const result: Partial<RunResult<Fmt>> = {};\n        for (const key in formatter) {\n          if (key.startsWith(\"_\")) continue;\n          const term = formatter[key];\n          result[key] = walk(term, s);\n        }\n        // Convert logic lists to arrays before yielding the final result\n        observer.next(deepListWalk(result) as RunResult<Fmt>);\n      },\n      error: (e: Error) => observer.error(e),\n      complete: () => observer.complete(),\n    });\n    if (typeof unsub === \"function\") return unsub;\n    if (unsub && typeof unsub.unsubscribe === \"function\")\n      return () => unsub.unsubscribe();\n    return function noop() {\n      /* pass */\n    };\n  });\n}\n\ntype QueryOutput<Fmt, Sel> = Sel extends ($: Record<string, Var>) => Fmt\n  ? RunResult<Fmt>\n  : Sel extends \"*\"\n    ? RunResult<Record<string, any>>\n    : any;\n\n/**\n * A fluent interface for building and executing logic queries.\n */\nclass Query<Fmt = Record<string, Var>, Sel = \"*\"> {\n  private _formatter: Fmt | Record<string, Var> | null = null;\n  private _rawSelector: any = null;\n  private _goals: Goal[] = [];\n  private _limit = Infinity;\n  private readonly _logicVarProxy: Record<string, Var>;\n  private _selectAllVars = false;\n\n  constructor() {\n    const { proxy } = createLogicVarProxy(\"q_\");\n    this._logicVarProxy = proxy;\n    this._selectAllVars = true;\n  }\n\n  /**\n   * Specifies the shape of the desired output.\n   */\n  select<NewSel extends \"*\">(\n    selector: NewSel,\n  ): Query<Record<string, Var>, NewSel>;\n  select<NewSel extends ($: Record<string, Var>) => any>(\n    selector: NewSel,\n  ): Query<ReturnType<NewSel>, NewSel>;\n  select<NewSel>(selector: NewSel): Query<any, any> {\n    if (selector === \"*\") {\n      this._formatter = null;\n      this._rawSelector = null;\n      this._selectAllVars = true;\n    } else if (typeof selector === \"function\") {\n      this._rawSelector = null;\n      this._selectAllVars = false;\n      this._formatter = selector(this._logicVarProxy);\n    } else {\n      this._formatter = null;\n      this._selectAllVars = false;\n      this._rawSelector = selector;\n    }\n    return this;\n  }\n\n  /**\n   * Adds constraints (goals) to the query.\n   */\n  where(goalFn: (proxy: Record<string, Var>) => Goal | Goal[]): this {\n    const result = goalFn(this._logicVarProxy);\n    this._goals.push(...(Array.isArray(result) ? result : [result]));\n    return this;\n  }\n\n  /**\n   * Sets the maximum number of results.\n   */\n  limit(n: number): this {\n    this._limit = n;\n    return this;\n  }\n\n  getSubstObservale() {\n    const initialSubst: Subst = new Map();\n    const combinedGoal = and(...this._goals);\n    // Updated for streaming protocol: pass Observable<Subst> to the goal\n    const substStream = combinedGoal(SimpleObservable.of(initialSubst));\n    return substStream;\n  }\n\n  private getObservable(): Observable<any> {\n    if (this._goals.length === 0) {\n      throw new Error(\"Query must have at least one .where() clause.\");\n    }\n\n    let formatter: Fmt | Record<string, Var> | any = this._formatter;\n    if (this._selectAllVars) {\n      formatter = {\n        ...this._logicVarProxy,\n      };\n    } else if (this._rawSelector) {\n      formatter = {\n        result: this._rawSelector,\n      };\n    } else if (!formatter) {\n      formatter = {\n        ...this._logicVarProxy,\n      };\n    }\n\n    const initialSubst: Subst = new Map();\n    const combinedGoal = and(...this._goals);\n    // Updated for streaming protocol: pass Observable<Subst> to the goal\n    const substStream = combinedGoal(SimpleObservable.of(initialSubst));\n    const results = formatSubstitutions(substStream, formatter, this._limit);\n\n    const rawSelector = this._rawSelector;\n    return new SimpleObservable((observer) => {\n      const sub = results.subscribe({\n        next: (result) => {\n          if (rawSelector) {\n            observer.next(result.result);\n          } else {\n            observer.next(result);\n          }\n        },\n        error: (err: Error) => observer.error(err),\n        complete: () => observer.complete(),\n      });\n\n      return () => sub.unsubscribe();\n    });\n  }\n\n  /**\n   * Makes the Query object itself an async iterable.\n   * Properly propagates cancellation upstream when the consumer stops early.\n   */\n  async *[Symbol.asyncIterator](): AsyncGenerator<QueryOutput<Fmt, Sel>> {\n    const observable = this.getObservable();\n    const queue: QueryOutput<Fmt, Sel>[] = [];\n    let completed = false;\n    let error: any = null;\n    let resolveNext: (() => void) | null = null;\n    // let unsub: (() => void) | null = null;\n\n    const nextPromise = () =>\n      new Promise<void>((resolve) => {\n        resolveNext = resolve;\n      });\n\n    const subcription = observable.subscribe({\n      next: (result) => {\n        queue.push(result);\n        if (resolveNext) {\n          resolveNext();\n          resolveNext = null;\n        }\n      },\n      error: (err) => {\n        error = err;\n        completed = true;\n        if (resolveNext) {\n          resolveNext();\n          resolveNext = null;\n        }\n      },\n      complete: () => {\n        completed = true;\n        if (resolveNext) {\n          resolveNext();\n          resolveNext = null;\n        }\n      },\n    });\n\n    try {\n      while (!completed || queue.length > 0) {\n        if (queue.length === 0) {\n          await nextPromise();\n        }\n        while (queue.length > 0) {\n          const item = queue.shift();\n          if (item !== undefined) {\n            yield item;\n          }\n        }\n        if (error) throw error;\n      }\n    } finally {\n      subcription.unsubscribe?.();\n    }\n  }\n\n  /**\n   * Executes the query and returns all results as an array.\n   */\n  async toArray(): Promise<QueryOutput<Fmt, Sel>[]> {\n    const observable = this.getObservable();\n    const results: QueryOutput<Fmt, Sel>[] = [];\n\n    return new Promise((resolve, reject) => {\n      observable.subscribe({\n        next: (result) => {\n          results.push(result);\n        },\n        error: reject,\n        complete: () => resolve(results),\n      });\n    });\n  }\n\n  /**\n   * Returns the observable stream directly for reactive programming.\n   */\n  toObservable(): Observable<QueryOutput<Fmt, Sel>> {\n    return this.getObservable();\n  }\n}\n\n/**\n * The main entry point for creating a new logic query.\n */\nexport function query<Fmt>(): Query<Fmt> {\n  return new Query<Fmt>();\n}\n","import type { Observable } from \"@codespiral/observable\";\nimport { SimpleObservable } from \"@codespiral/observable\";\nimport { eq } from \"../core/combinators.js\";\nimport { arrayToLogicList, unify, walk } from \"../core/kernel.js\";\nimport type { Goal, Subst, Term } from \"../core/types.ts\";\nimport {\n  collect_and_process_base,\n  group_by_streamo_base,\n} from \"./aggregates-base.js\";\n\n/**\n * count_value_streamo(x, value, count):\n *   count is the number of times x == value in the current stream of substitutions.\n *   (Stream-based version: aggregates over the current stream, like maxo/mino.)\n *\n * Usage: count_value_streamo(x, value, count)\n */\nexport function count_value_streamo(x: Term, value: Term, count: Term): Goal {\n  return (input$: Observable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const substitutions: Subst[] = [];\n\n      const subscription = input$.subscribe({\n        next: (s) => substitutions.push(s),\n        error: (error) => {\n          // Clean up substitutions on error\n          substitutions.length = 0;\n          observer.error?.(error);\n        },\n        complete: () => {\n          let n = 0;\n          for (const s of substitutions) {\n            const val = walk(x, s);\n            const target = walk(value, s);\n            if (JSON.stringify(val) === JSON.stringify(target)) n++;\n          }\n\n          eq(\n            count,\n            n,\n          )(SimpleObservable.of(new Map())).subscribe({\n            next: (v) => observer.next(v),\n            error: (e: Error) => observer.error(e),\n            complete: () => {\n              // Clean up substitutions after processing\n              substitutions.length = 0;\n              observer.complete?.();\n            },\n          });\n        },\n      });\n\n      // Return cleanup function to handle early unsubscription\n      return () => {\n        subscription.unsubscribe?.();\n        substitutions.length = 0; // Clean up substitutions on unsubscribe\n      };\n    });\n}\n\n/**\n * group_by_count_streamo(x, count, drop?):\n *   Groups the input stream by values of x and counts each group.\n *   - If drop=false (default): Preserves all variables from original substitutions,\n *     emitting one result for EACH substitution in each group with the count added.\n *   - If drop=true: Creates fresh substitutions with ONLY x and count variables.\n *   Example: if stream is x=A,y=1; x=A,y=2; x=B,y=3\n *   - drop=false: emits x=A,y=1,count=2; x=A,y=2,count=2; x=B,y=3,count=1\n *   - drop=true: emits x=A,count=2; x=B,count=1\n */\nexport function group_by_count_streamo(\n  x: Term,\n  count: Term,\n  drop = false,\n): Goal {\n  return group_by_streamo_base(\n    x, // keyVar\n    null, // valueVar (not needed for counting)\n    count, // outVar\n    drop, // drop\n    (_, substitutions) => substitutions.length, // aggregator: count substitutions\n  );\n}\n\n/**\n * sort_by_streamo(x, orderOrFn?):\n *   Sorts the stream of substitutions by the value of x.\n *   - If orderOrFn is 'asc' (default), sorts ascending.\n *   - If orderOrFn is 'desc', sorts descending.\n *   - If orderOrFn is a function (a, b) => number, uses it as the comparator on walked x values.\n *   Emits the same substitutions, but in sorted order by x.\n *   Example: if stream is x=3, x=1, x=2, emits x=1, x=2, x=3 (asc)\n */\nexport function sort_by_streamo(\n  x: Term,\n  orderOrFn?: \"asc\" | \"desc\" | ((a: any, b: any) => number),\n): Goal {\n  return collect_and_process_base(\n    (buffer: Subst[], observer: { next: (s: Subst) => void }) => {\n      // Extract values and create sortable pairs\n      const pairs = buffer.map((subst) => ({\n        value: walk(x, subst),\n        subst,\n      }));\n\n      // Create comparator\n      const orderFn = (() => {\n        if (typeof orderOrFn === \"function\") {\n          return orderOrFn;\n        }\n        if (typeof orderOrFn === \"string\") {\n          if (orderOrFn === \"desc\") {\n            return descComparator;\n          }\n        }\n        return ascComparator;\n      })();\n\n      const comparator = (a: { value: any }, b: { value: any }) =>\n        orderFn(a.value, b.value);\n\n      // Sort and emit\n      pairs.sort(comparator);\n      for (const { subst } of pairs) {\n        observer.next(subst);\n      }\n    },\n  );\n}\n\nconst descComparator = <T>(a: T, b: T) => {\n  if (a < b) return 1;\n  if (a > b) return -1;\n  return 0;\n};\n\nconst ascComparator = <T>(a: T, b: T) => {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\n/**\n * take_streamo(n):\n *   Allows only the first n substitutions to pass through the stream.\n *   Example: take_streamo(3) will emit only the first 3 substitutions.\n */\nexport function take_streamo(n: number): Goal {\n  return (input$: Observable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      let count = 0;\n\n      const subscription = input$.subscribe({\n        next: (item) => {\n          if (count < n) {\n            observer.next(item);\n            count++;\n            if (count === n) {\n              observer.complete?.();\n              subscription.unsubscribe?.();\n            }\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * group_by_collect_streamo(keyVar, valueVar, outList, drop?):\n *   Groups the input stream by keyVar and collects valueVar values into lists.\n *   The keyVar is preserved in the output (no need for separate outKey parameter).\n *   - If drop=false (default): Preserves all variables from original substitutions,\n *     emitting one result for EACH substitution in each group with the collected list added.\n *   - If drop=true: Creates fresh substitutions with ONLY keyVar and outList variables.\n *   Example: if stream is x=A,y=1; x=A,y=2; x=B,y=3\n *   - drop=false: emits x=A,y=1,list=[1,2]; x=A,y=2,list=[1,2]; x=B,y=3,list=[3]\n *   - drop=true: emits x=A,list=[1,2]; x=B,list=[3]\n */\nexport function group_by_collect_streamo<T>(\n  keyVar: Term,\n  valueVar: Term<T>,\n  outList: Term<T[]>,\n  drop = false,\n): Goal {\n  return group_by_streamo_base(\n    keyVar, // keyVar\n    valueVar, // valueVar\n    outList, // outVar\n    drop, // drop\n    (values, _) => arrayToLogicList(values), // aggregator: collect into list\n  );\n}\n\nexport function group_by_collect_distinct_streamo<T>(\n  keyVar: Term,\n  valueVar: Term<T>,\n  outList: Term<T[]>,\n  drop = false,\n): Goal {\n  return group_by_streamo_base(\n    keyVar, // keyVar\n    valueVar, // valueVar\n    outList, // outVar\n    drop, // drop\n    (values, _) => arrayToLogicList([...new Set(values)]), // aggregator: collect into list\n  );\n}\n\nexport function collect_streamo(\n  valueVar: Term,\n  outList: Term,\n  drop = false,\n): Goal {\n  return collect_and_process_base((buffer, observer) => {\n    const results = buffer.map((x) => walk(valueVar, x));\n    let s;\n    if (drop) {\n      s = new Map() as Subst;\n    } else {\n      s = buffer[0] ?? new Map();\n    }\n    const newSubst = unify(results, outList, s);\n    if (newSubst) {\n      observer.next(newSubst);\n    }\n  });\n}\n\n// export function collect_distinct_streamo(\n//   valueVar: Term,\n//   outList: Term,\n//   drop = false,\n// ): Goal {\n//   return collect_and_process_base(\n//     (buffer, observer) => {\n//       const resultsRaw = buffer.map(x => walk(valueVar, x));\n//       const results = [...new Set(resultsRaw)];\n//       let s;\n//       if(drop) {\n//         s = new Map() as Subst;\n//       } else {\n//         s = buffer[0];\n//       }\n//       const newSubst = unify(results, outList, s);\n//       if(newSubst) {\n//         observer.next(newSubst);\n//       }\n//     }\n//   )\n// }\n","/**\n * Base functions for building aggregation operations.\n *\n * These are foundational building blocks intended for creating new aggregation\n * relations, not for direct use by end users. They handle the low-level\n * subscription, buffering, grouping, and cleanup patterns that most\n * aggregation functions need.\n *\n * Functions ending in _base are infrastructure - use the public aggregation\n * functions in aggregates.ts instead.\n */\nimport type { Observable } from \"@codespiral/observable\";\nimport { SimpleObservable } from \"@codespiral/observable\";\nimport type { Goal, Subst, Term } from \"../index.js\";\nimport { unify, walk } from \"../index.js\";\n\n/**\n * Helper: collect all substitutions from a stream, then process them all at once.\n * Handles subscription, buffering, cleanup, and error management.\n * This is a foundational building block for aggregation functions that need\n * to see all data before processing (like sorting).\n *\n * @param processor - Function that receives all buffered substitutions and observer to emit results\n */\nexport function collect_and_process_base(\n  processor: (buffer: Subst[], observer: { next: (s: Subst) => void }) => void,\n): Goal {\n  return (input$: Observable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const buffer: Subst[] = [];\n\n      const subscription = input$.subscribe({\n        next: (item) => buffer.push(item),\n        error: (error) => {\n          buffer.length = 0;\n          observer.error?.(error);\n        },\n        complete: () => {\n          processor(buffer, observer);\n          buffer.length = 0;\n          observer.complete?.();\n        },\n      });\n\n      return () => {\n        subscription.unsubscribe?.();\n        buffer.length = 0;\n      };\n    });\n}\n\n/**\n * Generic stream-based grouping function - the foundation for all group_by_*_streamo functions.\n * Groups substitutions by keyVar and applies an aggregator function to each group.\n * This is a foundational building block for all grouping operations.\n *\n * @param keyVar - Variable to group by\n * @param valueVar - Variable to extract values from (null for count-only operations)\n * @param outVar - Variable to bind the aggregated result to\n * @param drop - If true, create fresh substitutions; if false, preserve original variables\n * @param aggregator - Function that takes (values, substitutions) and returns aggregated result\n */\nexport function group_by_streamo_base(\n  keyVar: Term,\n  valueVar: Term | null,\n  outVar: Term,\n  drop: boolean,\n  aggregator: (values: any[], substitutions: Subst[]) => any,\n): Goal {\n  return (input$: Observable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      // Shared grouping logic - collect all substitutions by key\n      const groups = new Map<\n        string,\n        { key: any; values: any[]; substitutions: Subst[] }\n      >();\n\n      const subscription = input$.subscribe({\n        next: (s) => {\n          const key = walk(keyVar, s);\n          const keyStr = JSON.stringify(key);\n\n          if (!groups.has(keyStr)) {\n            groups.set(keyStr, {\n              key,\n              values: [],\n              substitutions: [],\n            });\n          }\n          const group = groups.get(keyStr)!;\n          if (valueVar !== null) {\n            const value = walk(valueVar, s);\n            group.values.push(value);\n          }\n          group.substitutions.push(s);\n        },\n        error: (error) => {\n          groups.clear();\n          observer.error?.(error);\n        },\n        complete: () => {\n          // Different output generation based on drop parameter\n          if (drop) {\n            // Drop mode: emit one fresh substitution per group\n            for (const { key, values, substitutions } of groups.values()) {\n              const aggregated = aggregator(values, substitutions);\n              const subst = new Map();\n              const subst1 = unify(keyVar, key, subst);\n              if (subst1 === null) continue;\n              const subst2 = unify(outVar, aggregated, subst1);\n              if (subst2 === null) continue;\n              observer.next(subst2 as Subst);\n            }\n          } else {\n            // Preserve mode: emit all substitutions with aggregated result added\n            for (const { key, values, substitutions } of groups.values()) {\n              const aggregated = aggregator(values, substitutions);\n              for (const subst of substitutions) {\n                const subst1 = unify(keyVar, key, subst);\n                if (subst1 === null) continue;\n                const subst2 = unify(outVar, aggregated, subst1);\n                if (subst2 === null) continue;\n                observer.next(subst2 as Subst);\n              }\n            }\n          }\n          groups.clear();\n          observer.complete?.();\n        },\n      });\n\n      return () => {\n        subscription.unsubscribe?.();\n        groups.clear();\n      };\n    });\n}\n","import { and, branch, eq, fresh, lift, Subquery } from \"../core/combinators.js\";\nimport {\n\tarrayToLogicList,\n\tenrichGroupInput,\n\tisVar,\n\tlogicListToArray,\n\tlvar,\n\tunify,\n\twalk,\n} from \"../core/kernel.js\";\nimport type { Goal, Term, Var } from \"../core/types.ts\";\nimport {\n\tcollect_streamo,\n\tgroup_by_collect_distinct_streamo,\n\tgroup_by_collect_streamo,\n} from \"./aggregates.js\";\nimport { substLog } from \"./control.js\";\n\n/**\n * aggregateRelFactory: generic helper for collecto, collect_distincto, counto.\n * - x: variable to collect\n * - goal: logic goal\n * - out: output variable\n * - aggFn: aggregation function (receives array of results)\n * - dedup: if true, deduplicate results\n */\n\nexport function aggregateRelFactory(\n\taggFn: (results: Term[]) => any,\n\tdedup = false,\n) {\n\treturn (x: Term, goal: Goal, out: Term): Goal => {\n\t\treturn enrichGroupInput(\n\t\t\t\"aggregateRelFactory\",\n\t\t\t[],\n\t\t\t[goal],\n\t\t\tSubquery(\n\t\t\t\tgoal,\n\t\t\t\tx, // extract x from each subgoal result\n\t\t\t\tout, // bind the aggregated result to this variable\n\t\t\t\t(extractedValues, _) => {\n\t\t\t\t\tconst values = dedup ? deduplicate(extractedValues) : extractedValues;\n\t\t\t\t\treturn aggFn(values);\n\t\t\t\t},\n\t\t\t),\n\t\t);\n\t};\n}\n\n/**\n * collecto(x, goal, xs): xs is the list of all values x can take under goal (logic relation version)\n * Usage: collecto(x, membero(x, ...), xs)\n */\n\nexport const collecto = aggregateRelFactory(\n\t(arr) => arrayToLogicList(arr),\n\tfalse,\n);\n\n/**\n * collect_distincto(x, goal, xs): xs is the list of distinct values of x under goal.\n * Usage: collect_distincto(x, goal, xs)\n */\n\nexport const collect_distincto = aggregateRelFactory(\n\t(arr) => arrayToLogicList(arr),\n\ttrue,\n);\n\n/**\n * counto(x, goal, n): n is the number of (distinct) values of x under goal.\n * Usage: counto(x, goal, n)\n */\n\nexport const counto = aggregateRelFactory((arr) => arr.length, false);\n\nexport const count_distincto = aggregateRelFactory((arr) => arr.length, true);\n\n/**\n * count_valueo(x, goal, value, count):\n *   count is the number of times x == value in the stream of substitutions from goal.\n *   (Canonical, goal-wrapping version: aggregates over all solutions to goal.)\n *\n *   This is implemented using Subquery with a custom aggregator that counts\n *   how many times the extracted value equals the target value (walked in context).\n */\n\nexport function count_valueo(\n\tx: Term,\n\tgoal: Goal,\n\tvalue: Term,\n\tcount: Term,\n): Goal {\n\treturn Subquery(\n\t\tgoal,\n\t\tx, // extract x from each subgoal result\n\t\tcount, // bind the count to this variable\n\t\t(extractedValues, originalSubst) => {\n\t\t\t// Walk the value in the original substitution context\n\t\t\tconst targetValue = walk(value, originalSubst);\n\t\t\t// Count how many extracted values match the target value\n\t\t\treturn extractedValues.filter(\n\t\t\t\t(val) => JSON.stringify(val) === JSON.stringify(targetValue),\n\t\t\t).length;\n\t\t},\n\t);\n}\n// export function aggregateRelFactory(\n//   aggFn: (results: Term[]) => any,\n//   dedup = false,\n// ) {\n//   return (x: Term, goal: Goal, out: Term): Goal => {\n//     const ToutAgg = lvar(\"ToutAgg\");\n//     const collect_rel = dedup ? collect_distinct_streamo : collect_streamo\n//     return and(\n//       goal,\n//       collect_rel(x, ToutAgg, false),\n//       lift(aggFn)(ToutAgg, out),\n//     )\n//   };\n// }\n/**\n * groupAggregateRelFactory(aggFn): returns a group-by aggregation goal constructor.\n * The returned function has signature (keyVar, valueVar, goal, outKey, outAgg, dedup?) => Goal\n * Example: const group_by_collecto = groupAggregateRelFactory(arrayToLogicList)\n */\n\nexport function groupAggregateRelFactory(\n\taggFn: (items: any[]) => any,\n\tdedup = false,\n) {\n\treturn (\n\t\tkeyVar: Term,\n\t\tvalueVar: Term,\n\t\tgoal: Goal,\n\t\toutValueAgg: Term,\n\t): Goal => {\n\t\tconst group_by_rel = dedup\n\t\t\t? group_by_collect_distinct_streamo\n\t\t\t: group_by_collect_streamo;\n\t\t// @ts-expect-error\n\t\tconst aggFnName = aggFn?.displayName || aggFn.name || \"unknown\";\n\t\treturn enrichGroupInput(\n\t\t\t`groupAggregateRelFactory ${aggFnName}`,\n\t\t\t[],\n\t\t\t[goal],\n\t\t\tfresh((in_outValueAgg) =>\n\t\t\t\tbranch(\n\t\t\t\t\tand(goal, group_by_rel(keyVar, valueVar, in_outValueAgg, true)),\n\t\t\t\t\t(observer, substs, subst) => {\n\t\t\t\t\t\tfor (const oneSubst of substs) {\n\t\t\t\t\t\t\tconst keyVal = walk(keyVar as Term, oneSubst);\n\t\t\t\t\t\t\tif (isVar(keyVal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst valueAggVal = walk(in_outValueAgg, oneSubst);\n\t\t\t\t\t\t\tif (isVar(valueAggVal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst convertedAgg = aggFn(valueAggVal as any[]);\n\t\t\t\t\t\t\tconst s2 = unify(keyVar, keyVal, subst);\n\t\t\t\t\t\t\tif (!s2) continue;\n\t\t\t\t\t\t\tconst s3 = unify(outValueAgg, convertedAgg, s2);\n\t\t\t\t\t\t\tif (!s3) continue;\n\t\t\t\t\t\t\tobserver.next(s3);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t};\n}\n\nexport const group_by_collecto = groupAggregateRelFactory(\n\tfunction group_by_collecto(x) {\n\t\treturn x;\n\t},\n);\nexport const group_by_counto = groupAggregateRelFactory(\n\tfunction group_by_counto(items: any[]) {\n\t\treturn logicListToArray(items).length;\n\t},\n);\n\n/**\n * Helper: deduplicate an array of items using JSON.stringify for deep equality.\n */\nfunction deduplicate<T>(items: T[]): T[] {\n\tconst seen = new Set<string>();\n\tconst result: T[] = [];\n\tfor (const item of items) {\n\t\tconst k = JSON.stringify(item);\n\t\tif (!seen.has(k)) {\n\t\t\tseen.add(k);\n\t\t\tresult.push(item);\n\t\t}\n\t}\n\treturn result;\n}\n","import util from \"node:util\";\nimport { SimpleObservable, flatMap, take } from \"@codespiral/observable\";\nimport { eq } from \"../core/combinators.js\";\nimport { enrichGroupInput, isVar, walk } from \"../core/kernel.js\";\nimport {\n  getSuspendsFromSubst,\n  SUSPENDED_CONSTRAINTS,\n} from \"../core/subst-suspends.js\";\nimport { CHECK_LATER, suspendable } from \"../core/suspend-helper.js\";\nimport type { ConsNode, Goal, Subst, Term } from \"../core/types.js\";\n\nexport const uniqueo = (t: Term, g: Goal): Goal =>\n  enrichGroupInput(\"uniqueo\", [g], [], (input$: SimpleObservable<Subst>) =>\n    input$.pipe(\n      flatMap((s: Subst) => {\n        const seen = new Set();\n        return g(SimpleObservable.of(s)).pipe(\n          flatMap((s2: Subst) => {\n            const w_t = walk(t, s2);\n            if (isVar(w_t)) {\n              return SimpleObservable.of(s2);\n            }\n            const key = JSON.stringify(w_t);\n            if (seen.has(key)) return SimpleObservable.empty();\n            seen.add(key);\n            return SimpleObservable.of(s2);\n          }),\n        );\n      }),\n    ),\n  );\n\nexport function not(goal: Goal): Goal {\n  return enrichGroupInput(\"not\", [], [goal], (input$) =>\n    input$.pipe(\n      flatMap((s: Subst) => {\n        return new SimpleObservable<Subst>((observer) => {\n          let hasSolutions = false;\n          const sub = goal(SimpleObservable.of(s)).subscribe({\n            next: (subst) => {\n              if (!subst.has(SUSPENDED_CONSTRAINTS)) {\n                hasSolutions = true;\n              }\n            },\n            error: (err) => observer.error?.(err),\n            complete: () => {\n              if (!hasSolutions) {\n                observer.next(s);\n              }\n              observer.complete?.();\n            },\n          });\n          return () => sub.unsubscribe();\n        });\n      }),\n    ),\n  );\n}\n\nexport function gv1_not(goal: Goal): Goal {\n  return enrichGroupInput(\n    \"not\",\n    [],\n    [goal],\n    (input$: SimpleObservable<Subst>) =>\n      input$.pipe(\n        flatMap((s: Subst) => {\n          return new SimpleObservable<Subst>((observer) => {\n            let hasSolutions = false;\n            const sub = goal(SimpleObservable.of(s)).subscribe({\n              next: () => {\n                hasSolutions = true; // Any solution means the goal succeeds, so not fails\n              },\n              error: (err) => observer.error?.(err),\n              complete: () => {\n                if (!hasSolutions) {\n                  observer.next(s); // No solutions means not succeeds\n                }\n                observer.complete?.();\n              },\n            });\n            return () => sub.unsubscribe();\n          });\n        }),\n      ),\n  );\n}\n\nexport function old_not(goal: Goal): Goal {\n  return enrichGroupInput(\n    \"not\",\n    [],\n    [goal],\n    (input$: SimpleObservable<Subst>) =>\n      input$.pipe(\n        flatMap((s: Subst) => {\n          let found = false;\n          return new SimpleObservable<Subst>((observer) => {\n            goal(SimpleObservable.of(s)).subscribe({\n              next: (subst) => {\n                let addedNewBindings = false;\n                for (const [key, value] of subst) {\n                  if (!s.has(key)) {\n                    addedNewBindings = true;\n                    break;\n                  }\n                }\n                if (!addedNewBindings) {\n                  found = true;\n                }\n              },\n              error: (e: Error) => observer.error(e),\n              complete: () => {\n                if (!found) observer.next(s);\n                observer.complete?.();\n              },\n            });\n          });\n        }),\n      ),\n  );\n}\n\nexport function neqo(x: Term<any>, y: Term<any>): Goal {\n  return suspendable(\n    [x, y],\n    (values, subst) => {\n      const [xVal, yVal] = values;\n      const xGrounded = !isVar(xVal);\n      const yGrounded = !isVar(yVal);\n\n      if (xGrounded && yGrounded) {\n        // Both terms are ground, check inequality\n        return xVal !== yVal ? subst : null;\n      }\n\n      if (!xGrounded && !yGrounded) {\n        if (xVal.id === yVal.id) {\n          return null;\n        }\n      }\n\n      // if(xGrounded) {\n      //   const newsubst = unify(yVal, xVal, subst)\n      //   console.log(newsubst);\n      //   if(newsubst === null) return subst;\n      //   return CHECK_LATER;\n      // }\n\n      // if(yGrounded) {\n      //   const newsubst = unify(xVal, yVal, subst)\n      //   console.log(newsubst);\n      //   if(newsubst === null) return subst;\n      //   return CHECK_LATER;\n      // }\n      return CHECK_LATER;\n    },\n    0,\n  );\n}\n\n// export const neqo = (x: Term, y: Term): Goal => not(eq(x, y));\nexport function old_neqo(x: Term<any>, y: Term<any>): Goal {\n  return suspendable(\n    [x, y],\n    (values, subst) => {\n      return CHECK_LATER;\n      const [xVal, yVal] = values;\n      const xGrounded = !isVar(xVal);\n      const yGrounded = !isVar(yVal);\n\n      // All grounded - check constraint\n      if (xGrounded && yGrounded) {\n        return xVal !== yVal ? subst : null;\n      }\n\n      // if(xGrounded) {\n      //   const s2 = unify(xVal, yVal, subst);\n      //   if(s2) return CHECK_LATER;\n      //   return subst;\n      // }\n\n      // if(yGrounded) {\n      //   const s2 = unify(yVal, xVal, subst);\n      //   if(s2) return CHECK_LATER;\n      //   return subst;\n      // }\n\n      return CHECK_LATER; // Still not enough variables bound\n    },\n    0,\n  );\n}\n\n/**\n * A goal that succeeds if the given goal succeeds exactly once.\n * Useful for cut-like behavior.\n */\nexport function onceo(goal: Goal): Goal {\n  return (input$: SimpleObservable<Subst>) => goal(input$).pipe(take(1));\n}\n\n/**\n * A goal that always succeeds with the given substitution.\n * Useful as a base case or for testing.\n */\nexport function succeedo(): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    input$.pipe(\n      flatMap(\n        (s: Subst) =>\n          new SimpleObservable<Subst>((observer) => {\n            observer.next(s);\n            observer.complete?.();\n          }),\n      ),\n    );\n}\n\n/**\n * A goal that always fails.\n * Useful for testing or as a base case.\n */\nexport function failo(): Goal {\n  return (_input$: SimpleObservable<Subst>) => SimpleObservable.empty();\n}\n\n/**\n * A goal that succeeds if the term is ground (contains no unbound variables).\n */\nexport function groundo(term: Term): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    input$.pipe(\n      flatMap(\n        (s: Subst) =>\n          new SimpleObservable<Subst>((observer) => {\n            const walked = walk(term, s);\n            function isGround(t: Term): boolean {\n              if (isVar(t)) return false;\n              if (Array.isArray(t)) {\n                return t.every(isGround);\n              }\n              if (t && typeof t === \"object\" && \"tag\" in t) {\n                if (t.tag === \"cons\") {\n                  const l = t as ConsNode;\n                  return isGround(l.head) && isGround(l.tail);\n                }\n                if (t.tag === \"nil\") {\n                  return true;\n                }\n              }\n              if (t && typeof t === \"object\" && !(\"tag\" in t)) {\n                return Object.values(t).every(isGround);\n              }\n              return true; // primitives are ground\n            }\n            if (isGround(walked)) {\n              observer.next(s);\n            }\n            observer.complete?.();\n          }),\n      ),\n    );\n}\n\n/**\n * A goal that succeeds if the term is not ground (contains unbound variables).\n */\nexport function nonGroundo(term: Term): Goal {\n  return not(groundo(term));\n}\n\n/**\n * A goal that logs each substitution it sees along with a message.\n */\nexport function substLog(msg: string, onlyVars = false): Goal {\n  return enrichGroupInput(\n    \"substLog\",\n    [],\n    [],\n    (input$: SimpleObservable<Subst>) =>\n      new SimpleObservable<Subst>((observer) => {\n        const sub = input$.subscribe({\n          next: (s) => {\n            const ns = onlyVars\n              ? Object.fromEntries(\n                  [...s.entries()].filter(([k, v]) => typeof k === \"string\"),\n                )\n              : s;\n            console.log(\n              `[substLog] ${msg}:`,\n              util.inspect(ns, {\n                depth: null,\n                colors: true,\n              }),\n            );\n            observer.next(s);\n          },\n          error: (e: Error) => observer.error(e),\n          complete: () => observer.complete(),\n        });\n        return () => sub.unsubscribe();\n      }),\n  );\n}\n\nlet thruCountId = 0;\nexport function thruCount(msg: string, level = 1000): Goal {\n  const id = ++thruCountId;\n  return enrichGroupInput(\n    \"thruCount\",\n    [],\n    [],\n    (input$: SimpleObservable<Subst>) =>\n      new SimpleObservable<Subst>((observer) => {\n        let cnt = 0;\n        const sub = input$.subscribe({\n          next: (s) => {\n            cnt++;\n\n            // Determine current level based on count\n            let currentLevel = 1;\n            if (cnt >= 10) currentLevel = 10;\n            if (cnt >= 100) currentLevel = 100;\n            if (cnt >= 1000) currentLevel = 1000;\n            // if (cnt >= 10000) currentLevel = 10000;\n            // if (cnt >= 100000) currentLevel = 100000;\n\n            if (cnt % currentLevel === 0) {\n              let nonSymbolKeyCount = 0;\n              for (const key of s.keys()) {\n                if (typeof key !== \"symbol\") nonSymbolKeyCount++;\n              }\n              const suspendedCount = getSuspendsFromSubst(s).length;\n              console.log(\"THRU\", id, msg, cnt, {\n                nonSymbolKeyCount,\n                suspendedCount,\n              });\n            }\n            observer.next(s);\n          },\n          error: (e: Error) => observer.error(e),\n          complete: () => {\n            console.log(\"THRU COMPLETE\", id, msg, cnt);\n            observer.complete?.();\n          },\n        });\n        return () => sub.unsubscribe();\n      }),\n  );\n}\n\nexport function fail(): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const sub = input$.subscribe({\n        next: (s) => {\n          /* pass */\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n      return () => sub.unsubscribe();\n    });\n}\n","import { and, eq } from \"../core/combinators.js\";\nimport {\n  cons,\n  enrichGroupInput,\n  isCons,\n  isLogicList,\n  isNil,\n  logicListToArray,\n  lvar,\n  nil,\n  unify,\n  walk,\n} from \"../core/kernel.js\";\nimport { SimpleObservable } from \"@codespiral/observable\";\nimport type { Goal, LogicList, Subst, Term } from \"../core/types.js\";\n\nexport function membero(x: Term, list: Term): Goal {\n  return enrichGroupInput(\n    \"membero\",\n    [],\n    [],\n    (input$) =>\n      new SimpleObservable<Subst>((observer) => {\n        const subscriptions: any[] = [];\n        let cancelled = false;\n        let active = 0;\n        let inputComplete = false;\n\n        const checkComplete = () => {\n          if (inputComplete && active === 0 && !cancelled) {\n            observer.complete?.();\n          }\n        };\n\n        const inputSub = input$.subscribe({\n          next: (s) => {\n            if (cancelled) return;\n\n            const l = walk(list, s);\n            // Fast path for arrays\n            if (Array.isArray(l)) {\n              for (let i = 0; i < l.length; i++) {\n                if (cancelled) break;\n                const item = l[i];\n                const s2 = unify(x, item, s);\n                if (s2) observer.next(s2);\n              }\n            } else if (\n              l &&\n              typeof l === \"object\" &&\n              \"tag\" in l &&\n              (l as any).tag === \"cons\"\n            ) {\n              if (cancelled) return;\n\n              const s1 = unify(x, (l as any).head, s);\n              if (s1) observer.next(s1);\n\n              active++;\n              // Recursive call for tail\n              const sub = membero(\n                x,\n                (l as any).tail,\n              )(SimpleObservable.of(s)).subscribe({\n                next: (result) => {\n                  if (!cancelled) observer.next(result);\n                },\n                error: (err) => {\n                  if (!cancelled) observer.error?.(err);\n                },\n                complete: () => {\n                  active--;\n                  checkComplete();\n                },\n              });\n              subscriptions.push(sub);\n            }\n            // If neither array nor cons, do nothing (no result)\n          },\n          error: (err) => {\n            if (!cancelled) observer.error?.(err);\n          },\n          complete: () => {\n            inputComplete = true;\n            checkComplete();\n          },\n        });\n\n        subscriptions.push(inputSub);\n\n        return () => {\n          cancelled = true;\n          subscriptions.forEach((sub) => {\n            try {\n              sub?.unsubscribe?.();\n            } catch (e) {\n              // Ignore cleanup errors\n            }\n          });\n          subscriptions.length = 0;\n        };\n      }),\n  );\n}\n\n/**\n * A goal that succeeds if `h` is the head of the logic list `l`.\n */\nexport function firsto(x: Term, xs: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const l = walk(xs, s);\n          if (isCons(l)) {\n            const consNode = l as { tag: \"cons\"; head: Term; tail: Term };\n            const s1 = unify(x, consNode.head, s);\n            if (s1) observer.next(s1);\n          }\n          observer.complete?.();\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n\n/**\n * A goal that succeeds if `t` is the tail of the logic list `l`.\n */\nexport function resto(xs: Term, tail: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const l = walk(xs, s);\n          if (isCons(l)) {\n            const consNode = l as { tag: \"cons\"; head: Term; tail: Term };\n            const s1 = unify(tail, consNode.tail, s);\n            if (s1) observer.next(s1);\n          }\n          observer.complete?.();\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n\n/**\n * A goal that succeeds if logic list `zs` is the result of appending\n * logic list `ys` to `xs`.\n */\nexport function appendo(xs: Term, ys: Term, zs: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const xsVal = walk(xs, s);\n          if (isCons(xsVal)) {\n            const consNode = xsVal as { tag: \"cons\"; head: Term; tail: Term };\n            const head = consNode.head;\n            const tail = consNode.tail;\n            const rest = lvar();\n            const s1 = unify(\n              zs,\n              {\n                tag: \"cons\",\n                head,\n                tail: rest,\n              },\n              s,\n            );\n            if (s1) {\n              appendo(\n                tail,\n                ys,\n                rest,\n              )(SimpleObservable.of(s1)).subscribe({\n                next: (v) => observer.next(v),\n                error: (e: Error) => observer.error(e),\n                complete: () => observer.complete(),\n              });\n              return;\n            }\n          } else if (isNil(xsVal)) {\n            const s1 = unify(ys, zs, s);\n            if (s1) observer.next(s1);\n          }\n          observer.complete?.();\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n\n/**\n * A goal that unifies the length of an array or logic list with a numeric value.\n * @param arrayOrList The array or logic list to measure\n * @param length The length to unify with\n */\nexport function lengtho(arrayOrList: Term, length: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const walkedArray = walk(arrayOrList, s);\n          const walkedLength = walk(length, s);\n          let actualLength: number;\n          if (isLogicList(walkedArray)) {\n            actualLength = logicListToArray(walkedArray).length;\n          } else if (Array.isArray(walkedArray)) {\n            actualLength = walkedArray.length;\n          } else {\n            // observer.complete?.();\n            return;\n          }\n          const unified = unify(actualLength, walkedLength, s);\n          if (unified !== null) {\n            observer.next(unified);\n          }\n          // observer.complete?.();\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n\nexport function permuteo(xs: Term, ys: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const xsVal = walk(xs, s);\n          if (isNil(xsVal)) {\n            eq(\n              ys,\n              nil,\n            )(SimpleObservable.of(s)).subscribe({\n              next: (v) => observer.next(v),\n              error: (e: Error) => observer.error(e),\n              complete: () => observer.complete(),\n            });\n            return;\n          }\n          if (isCons(xsVal)) {\n            const arr = logicListToArray(xsVal as LogicList);\n            let completedCount = 0;\n            for (const head of arr) {\n              const rest = lvar();\n              and(\n                removeFirsto(xsVal, head, rest),\n                permuteo(rest, lvar()),\n                eq(ys, cons(head, lvar())),\n              )(SimpleObservable.of(s)).subscribe({\n                next: (s1) => {\n                  const ysVal2 = walk(ys, s1);\n                  if (isCons(ysVal2)) {\n                    eq(\n                      ysVal2.tail,\n                      walk(lvar(), s1),\n                    )(SimpleObservable.of(s1)).subscribe({\n                      next: (v) => observer.next(v),\n                      error: (e: Error) => observer.error(e),\n                    });\n                  }\n                },\n                error: (e: Error) => observer.error(e),\n                complete: () => {\n                  completedCount++;\n                  if (completedCount === arr.length) {\n                    observer.complete?.();\n                  }\n                },\n              });\n            }\n            if (arr.length === 0) {\n              observer.complete?.();\n            }\n          } else {\n            observer.complete?.();\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n\nexport function mapo(\n  rel: (x: Term, y: Term) => Goal,\n  xs: Term,\n  ys: Term,\n): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const xsVal = walk(xs, s);\n          if (isNil(xsVal)) {\n            eq(\n              ys,\n              nil,\n            )(SimpleObservable.of(s)).subscribe({\n              next: (v) => observer.next(v),\n              error: (e: Error) => observer.error(e),\n              complete: () => {\n                active--;\n                if (completed && active === 0) observer.complete?.();\n              },\n            });\n            return;\n          }\n          if (isCons(xsVal)) {\n            const xHead = xsVal.head;\n            const xTail = xsVal.tail;\n            const yHead = lvar();\n            const yTail = lvar();\n            and(\n              eq(ys, cons(yHead, yTail)),\n              rel(xHead, yHead),\n              mapo(rel, xTail, yTail),\n            )(SimpleObservable.of(s)).subscribe({\n              next: (v) => observer.next(v),\n              error: (e: Error) => observer.error(e),\n              complete: () => {\n                active--;\n                if (completed && active === 0) observer.complete?.();\n              },\n            });\n          } else {\n            active--;\n            if (completed && active === 0) observer.complete?.();\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\nexport function removeFirsto(xs: Term, x: Term, ys: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const xsVal = walk(xs, s);\n          if (isNil(xsVal)) {\n            active--;\n            if (completed && active === 0) observer.complete?.();\n            return;\n          }\n          if (isCons(xsVal)) {\n            const walkedX = walk(x, s);\n            const walkedHead = walk(xsVal.head, s);\n            if (JSON.stringify(walkedHead) === JSON.stringify(walkedX)) {\n              eq(\n                ys,\n                xsVal.tail,\n              )(SimpleObservable.of(s)).subscribe({\n                next: (v) => observer.next(v),\n                error: (e: Error) => observer.error(e),\n                complete: () => {\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                },\n              });\n            } else {\n              const rest = lvar();\n              and(\n                eq(ys, cons(xsVal.head, rest)),\n                removeFirsto(xsVal.tail, x, rest),\n              )(SimpleObservable.of(s)).subscribe({\n                next: (v) => observer.next(v),\n                error: (e: Error) => observer.error(e),\n                complete: () => {\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                },\n              });\n            }\n          } else {\n            active--;\n            if (completed && active === 0) observer.complete?.();\n          }\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * alldistincto(xs): true if all elements of xs are distinct.\n */\nexport function alldistincto(xs: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const arr = walk(xs, s);\n          let jsArr: any[] = [];\n          if (arr && typeof arr === \"object\" && \"tag\" in arr) {\n            let cur: Term = arr;\n            while (isCons(cur)) {\n              jsArr.push(cur.head);\n              cur = cur.tail;\n            }\n          } else if (Array.isArray(arr)) {\n            jsArr = arr;\n          }\n          const seen = new Set();\n          let allDistinct = true;\n          for (const v of jsArr) {\n            const key = JSON.stringify(v);\n            if (seen.has(key)) {\n              allDistinct = false;\n              break;\n            }\n            seen.add(key);\n          }\n          if (allDistinct) observer.next(s);\n          observer.complete?.();\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => observer.complete(),\n      });\n    });\n}\n","import { SimpleObservable } from \"@codespiral/observable\";\nimport { isVar, unify, walk } from \"../core/kernel.js\";\nimport { CHECK_LATER, suspendable } from \"../core/suspend-helper.js\";\nimport type { Goal, Subst, Term } from \"../core/types.js\";\n\n/**\n * A goal that succeeds if the numeric value in the first term is greater than\n * the numeric value in the second term.\n */\nexport function gto(x: Term<number>, y: Term<number>): Goal {\n  return suspendable(\n    [x, y],\n    (values: Term<any>[], subst: Subst) => {\n      const [xVal, yVal] = values;\n      const xGrounded = !isVar(xVal);\n      const yGrounded = !isVar(yVal);\n\n      // All grounded - check constraint\n      if (xGrounded && yGrounded) {\n        return xVal > yVal ? subst : null;\n      }\n\n      return CHECK_LATER; // Still not enough variables bound\n    },\n    2,\n  );\n}\n\n/**\n * A goal that succeeds if the numeric value in the first term is less than\n * the numeric value in the second term.\n */\nexport function lto(x: Term<number>, y: Term<number>): Goal {\n  return suspendable(\n    [x, y],\n    (values: Term<any>[], subst: Subst) => {\n      const [xVal, yVal] = values;\n      const xGrounded = !isVar(xVal);\n      const yGrounded = !isVar(yVal);\n\n      // All grounded - check constraint\n      if (xGrounded && yGrounded) {\n        return xVal < yVal ? subst : null;\n      }\n\n      return CHECK_LATER; // Still not enough variables bound\n    },\n    2,\n  );\n}\n\n/**\n * A goal that succeeds if the numeric value in the first term is greater than or equal to\n * the numeric value in the second term.\n */\nexport function gteo(x: Term<number>, y: Term<number>): Goal {\n  return suspendable(\n    [x, y],\n    (values: Term<any>[], subst: Subst) => {\n      const [xVal, yVal] = values;\n      const xGrounded = !isVar(xVal);\n      const yGrounded = !isVar(yVal);\n\n      // All grounded - check constraint\n      if (xGrounded && yGrounded) {\n        return xVal >= yVal ? subst : null;\n      }\n\n      return CHECK_LATER; // Still not enough variables bound\n    },\n    2,\n  );\n}\n\n/**\n * A goal that succeeds if the numeric value in the first term is less than or equal to\n * the numeric value in the second term.\n */\nexport function lteo(x: Term<number>, y: Term<number>): Goal {\n  return suspendable(\n    [x, y],\n    (values: Term<any>[], subst: Subst) => {\n      const [xVal, yVal] = values;\n      const xGrounded = !isVar(xVal);\n      const yGrounded = !isVar(yVal);\n\n      // All grounded - check constraint\n      if (xGrounded && yGrounded) {\n        return xVal <= yVal ? subst : null;\n      }\n\n      return CHECK_LATER; // Still not enough variables bound\n    },\n    2,\n  );\n}\n\n/**\n * A goal that succeeds if z is the sum of x and y.\n * Can work in multiple directions if some variables are grounded.\n */\nexport function pluso(x: Term<number>, y: Term<number>, z: Term<number>): Goal {\n  return suspendable([x, y, z], (values: Term<any>[], subst: Subst) => {\n    const [xVal, yVal, zVal] = values;\n    const xGrounded = !isVar(xVal);\n    const yGrounded = !isVar(yVal);\n    const zGrounded = !isVar(zVal);\n\n    // All grounded - check constraint\n    if (xGrounded && yGrounded && zGrounded) {\n      return xVal + yVal === zVal ? subst : null;\n    }\n    // Two grounded - compute third\n    else if (xGrounded && yGrounded) {\n      return unify(z, xVal + yVal, subst);\n    } else if (xGrounded && zGrounded) {\n      return unify(y, zVal - xVal, subst);\n    } else if (yGrounded && zGrounded) {\n      return unify(x, zVal - yVal, subst);\n    }\n\n    return CHECK_LATER; // Still not enough variables bound\n  });\n}\nexport const minuso = (\n  x: Term<number>,\n  y: Term<number>,\n  z: Term<number>,\n): Goal => pluso(z, y, x);\n\n/**\n * A goal that succeeds if z is the product of x and y.\n * Can work in multiple directions if some variables are grounded.\n */\nexport function multo(x: Term<number>, y: Term<number>, z: Term<number>): Goal {\n  return suspendable([x, y, z], (values: Term<any>[], subst: Subst) => {\n    const [xVal, yVal, zVal] = values;\n    const xGrounded = !isVar(xVal);\n    const yGrounded = !isVar(yVal);\n    const zGrounded = !isVar(zVal);\n\n    if (xGrounded && yGrounded && zGrounded) {\n      return xVal * yVal === zVal ? subst : null;\n    }\n    if (xGrounded && yGrounded) {\n      return unify(z, xVal * yVal, subst);\n    }\n    if (zGrounded && zVal !== 0) {\n      if (xGrounded && xVal === 0) return null;\n      if (yGrounded && yVal === 0) return null;\n    }\n    if (xGrounded && zGrounded) {\n      return unify(y, zVal / xVal, subst);\n    } else if (yGrounded && zGrounded) {\n      return unify(x, zVal / yVal, subst);\n    }\n\n    return CHECK_LATER; // Still not enough variables bound\n  });\n}\nexport const dividebyo = (\n  x: Term<number>,\n  y: Term<number>,\n  z: Term<number>,\n): Goal => multo(z, y, x);\n\n/**\n * A goal that succeeds only for the substitution(s) that have the maximum value\n * for the given variable across all input substitutions.\n *\n * Usage: maxo($.movie_popularity) - selects the substitution with highest movie_popularity\n */\nexport function maxo(variable: Term): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const substitutions: Subst[] = [];\n\n      // First, collect all substitutions\n      const subscription = input$.subscribe({\n        next: (s) => {\n          substitutions.push(s);\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          if (substitutions.length === 0) {\n            observer.complete?.();\n            return;\n          }\n\n          // Find the maximum value and corresponding substitutions\n          let maxValue: number | undefined;\n          const maxSubstitutions: Subst[] = [];\n\n          for (const s of substitutions) {\n            const value = walk(variable, s);\n            if (typeof value === \"number\") {\n              if (maxValue === undefined || value > maxValue) {\n                maxValue = value;\n                maxSubstitutions.length = 0; // Clear array\n                maxSubstitutions.push(s);\n              } else if (value === maxValue) {\n                maxSubstitutions.push(s);\n              }\n            }\n          }\n\n          // Emit all substitutions that have the maximum value\n          for (const s of maxSubstitutions) {\n            observer.next(s);\n          }\n\n          observer.complete?.();\n        },\n      });\n\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * A goal that succeeds only for the substitution(s) that have the minimum value\n * for the given variable across all input substitutions.\n *\n * Usage: mino($.movie_popularity) - selects the substitution with lowest movie_popularity\n */\nexport function mino(variable: Term): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const substitutions: Subst[] = [];\n\n      // First, collect all substitutions\n      const subscription = input$.subscribe({\n        next: (s) => {\n          substitutions.push(s);\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          if (substitutions.length === 0) {\n            observer.complete?.();\n            return;\n          }\n\n          // Find the minimum value and corresponding substitutions\n          let minValue: number | undefined;\n          const minSubstitutions: Subst[] = [];\n\n          for (const s of substitutions) {\n            const value = walk(variable, s);\n            if (typeof value === \"number\") {\n              if (minValue === undefined || value < minValue) {\n                minValue = value;\n                minSubstitutions.length = 0; // Clear array\n                minSubstitutions.push(s);\n              } else if (value === minValue) {\n                minSubstitutions.push(s);\n              }\n            }\n          }\n\n          // Emit all substitutions that have the minimum value\n          for (const s of minSubstitutions) {\n            observer.next(s);\n          }\n\n          observer.complete?.();\n        },\n      });\n\n      return () => subscription.unsubscribe?.();\n    });\n}\n","import { SimpleObservable, flatMap } from \"@codespiral/observable\";\nimport { isVar, unify, walk } from \"../core/kernel.js\";\nimport type { Goal, Subst, Term } from \"../core/types.js\";\n\n/**\n * A goal that extracts specific keys from an object and unifies them with logic variables.\n * This is a simpler alternative to projectJsonata for basic object key extraction.\n *\n * Usage:\n *   extract($.input_object, {\n *     name: $.output_name,\n *     age: $.output_age,\n *     nested: {\n *       city: $.output_city,\n *       country: $.output_country\n *     }\n *   })\n *\n * If the mapping value is a logic variable, it unifies directly.\n * If the mapping value is an object/array, it recursively extracts from nested structures.\n */\nexport function extract(inputVar: Term, mapping: Record<string, Term>): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    input$.pipe(\n      flatMap(\n        (s: Subst) =>\n          new SimpleObservable<Subst>((observer) => {\n            const inputValue: Term<any> = walk(inputVar, s);\n\n            // Input must be resolved to an object\n            if (typeof inputValue !== \"object\" || inputValue === null) {\n              observer.complete?.();\n              return;\n            }\n\n            // Helper function to recursively extract values\n            const extractRecursive = (\n              sourceValue: any,\n              targetMapping: any,\n              currentSubst: Subst,\n            ): Subst | null => {\n              if (isVar(targetMapping)) {\n                // If target is a logic variable, unify directly\n                return unify(targetMapping, sourceValue, currentSubst);\n              } else if (Array.isArray(targetMapping)) {\n                // If target is an array, source should also be an array\n                if (\n                  !Array.isArray(sourceValue) ||\n                  sourceValue.length !== targetMapping.length\n                ) {\n                  return null;\n                }\n                let resultSubst = currentSubst;\n                for (let i = 0; i < targetMapping.length; i++) {\n                  const nextSubst = extractRecursive(\n                    sourceValue[i],\n                    targetMapping[i],\n                    resultSubst,\n                  );\n                  if (nextSubst === null) return null;\n                  resultSubst = nextSubst;\n                }\n                return resultSubst;\n              } else if (\n                typeof targetMapping === \"object\" &&\n                targetMapping !== null\n              ) {\n                // If target is an object, recursively extract each key\n                if (typeof sourceValue !== \"object\" || sourceValue === null) {\n                  return null;\n                }\n                let resultSubst = currentSubst;\n                for (const [key, targetValue] of Object.entries(\n                  targetMapping,\n                )) {\n                  const sourceNestedValue = sourceValue[key];\n                  const nextSubst = extractRecursive(\n                    sourceNestedValue,\n                    targetValue,\n                    resultSubst,\n                  );\n                  if (nextSubst === null) return null;\n                  resultSubst = nextSubst;\n                }\n                return resultSubst;\n              } else {\n                // If target is a literal value, check for equality\n                return sourceValue === targetMapping ? currentSubst : null;\n              }\n            };\n\n            // Extract each key and unify with corresponding variable/structure\n            let currentSubst = s;\n            for (const [key, outputMapping] of Object.entries(mapping)) {\n              const value = inputValue[key];\n              const nextSubst = extractRecursive(\n                value,\n                outputMapping,\n                currentSubst,\n              );\n              if (nextSubst === null) {\n                // If any extraction fails, skip this result\n                observer.complete?.();\n                return;\n              }\n              currentSubst = nextSubst;\n            }\n\n            observer.next(currentSubst);\n            observer.complete?.();\n          }),\n      ),\n    );\n}\n\n/**\n * A goal that combines membero() and extract() - iterates over an array and extracts\n * specific keys from each element, creating one substitution per array element.\n *\n * Usage:\n *   extractEach($.array_of_objects, {\n *     name: $.item_name,\n *     age: $.item_age,\n *     email: $.item_email\n *   })\n *\n * This is equivalent to:\n *   membero($.item, $.array_of_objects),\n *   extract($.item, { name: $.item_name, age: $.item_age, email: $.item_email })\n *\n * But more concise and clearer in intent.\n */\nexport function extractEach(\n  arrayVar: Term,\n  mapping: Record<string, Term>,\n): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    input$.pipe(\n      flatMap(\n        (s: Subst) =>\n          new SimpleObservable<Subst>((observer) => {\n            const arrayValue = walk(arrayVar, s);\n\n            // Input must be resolved to an array\n            if (!Array.isArray(arrayValue)) {\n              observer.complete?.();\n              return;\n            }\n\n            // For each element in the array, extract the specified keys\n            for (const element of arrayValue) {\n              if (typeof element === \"object\" && element !== null) {\n                // Extract each key and unify with corresponding variable\n                let currentSubst = s;\n                let allUnified = true;\n\n                for (const [key, outputVar] of Object.entries(mapping)) {\n                  const value = element[key];\n                  const unified = unify(outputVar, value, currentSubst);\n                  if (unified !== null) {\n                    currentSubst = unified;\n                  } else {\n                    // If any unification fails, skip this element\n                    allUnified = false;\n                    break;\n                  }\n                }\n\n                if (allUnified) {\n                  observer.next(currentSubst);\n                }\n              }\n            }\n\n            observer.complete?.();\n          }),\n      ),\n    );\n}\n","import util from \"node:util\";\n\nconst DEFAULT_CONFIG = {\n  enabled: false,\n  allowedIds: new Set<string>([\n    // \"FLUSH_BATCH\",\n    // \"FLUSH_BATCH_COMPLETE\",\n    // \"GOAL_NEXT\",\n    // \"UPSTREAM_GOAL_COMPLETE\",\n    // \"GOAL_COMPLETE\",\n    // \"GOAL_CANCELLED\",\n    // \"FLUSH_BATCH_CANCELLED_AFTER_QUERY\",\n    // \"FLUSH_BATCH_CANCELLED_DURING_ROWS\",\n    // \"FLUSH_BATCH_CANCELLED_DURING_SUBST\",\n    // \"DB_QUERY_BATCH\",\n    // \"CACHE_HIT\",\n    // \"CACHE_MISS\",\n    // \"UNIFY_SUCCESS\",\n    // \"UNIFY_FAILURE\",\n    // \"GOAL_BATCH_KEY_UPDATED\",\n    // \"ABOUT_TO_CALL_CACHE_OR_QUERY\",\n    // \"CACHE_OR_QUERY_START\",\n    // \"COMPATIBLE_GOALS\",\n    // \"ABOUT_TO_PROCESS_GOAL\",\n    // \"GOAL_GROUP_INFO\",\n    // \"DB_ROWS\",\n    // \"DB_NO_ROWS\",\n    // \"FLUSH_BATCH\",\n    // \"COMPATIBLE_MERGE_GOALS\",\n    // \"DB_QUERY_MERGED\",\n    // \"DB_ROWS_MERGED\",\n    // \"ABOUT_TO_CALL_CACHE_OR_QUERY\",\n    // \"USING_GOAL_MERGING\",\n    // \"USING_GOAL_CACHING\",\n    // \"USING_SUBSTITUTION_BATCHING\",\n    // \"CACHE_PERFORMANCE\",\n    // \"BATCH_PERFORMANCE\",\n    // \"CACHE_HIT_IMMEDIATE\",\n    // \"CACHE_MISS_TO_BATCH\",\n    // \"PROCESSING_CACHE_MISSES\",\n    // \"EXECUTING_QUERY_FOR_CACHE_MISSES\",\n    // \"SINGLE_CACHE_MISS_WITH_GOAL_MERGING\",\n    // \"EXECUTING_UNIFIED_QUERY\",\n    // \"DB_QUERY_UNIFIED\",\n    // \"POPULATING_CACHE_FOR_COMPATIBLE_GOALS\",\n    // \"MERGING_COMPATIBLE_GOALS\",\n    // \"COMPATIBLE_GOALS\",\n    // \"CACHED_FOR_OTHER_GOAL\",\n    // \"CROSS_GROUP_CACHE_CHECK\",\n    // \"OUTER_GROUP_CACHE_POPULATION\",\n    // \"GOAL_STARTED\",\n    // \"FOUND_RELATED_GOALS\",\n    // \"MERGE_COMPATIBILITY_CHECK\",\n    // \"CACHE_COMPATIBILITY_CHECK\",\n    // \"SINGLE_QUERY_COLUMN_SELECTION\",\n    // \"MERGED_QUERY_COLUMN_SELECTION\",\n    // \"GOAL_CREATED\",\n  ]), // empty means allow all\n  deniedIds: new Set<string>([\n    // \"FACT_ADDED\",\n    // \"UNIFY_FAILED\",\n    // \"THIS_GOAL_ROWS\",\n    // \"ALL_GOAL_ROWS\",\n    // \"COMMON_GOALS\",\n    // \"DB_QUERY\",\n    // \"GOAL_CREATED\",\n    // \"SAW_CACHE\",\n    // \"SHARED_GOALS\", // Disabled to reduce noise\n    // \"DB_QUERY\", // Disabled to reduce noise\n    // \"DB_NO_ROWS\",\n    // \"DB_ROWS\",\n    // \"GOAL_CREATED\", // Disabled to reduce noise\n    // \"MERGEABLE_CHECK\", // Disabled to reduce noise\n    // \"PENDING_QUERIES_DEBUG\", // Disabled to reduce noise\n    // \"MERGE_DEBUG\", // Disabled to reduce noise\n    // \"PENDING_ADD\", // Disabled to reduce noise\n    // \"CACHE_HIT\", // Enabled to see cache hits\n    // \"SHARED_UNIFY\", // Enabled to see shared unification\n  ]), // specific ids to deny\n};\n\nexport interface LoggerConfig {\n  enabled: boolean;\n  allowedIds: Set<string>;\n  deniedIds: Set<string>;\n}\n\nexport class Logger {\n  constructor(private config: LoggerConfig) {}\n\n  log(\n    id: string,\n    data: Record<string, any> | string | (() => Record<string, any> | string),\n  ): void {\n    if (!this.config.enabled) return;\n    if (this.config.deniedIds.has(id)) return;\n    if (this.config.allowedIds.size > 0 && !this.config.allowedIds.has(id))\n      return;\n\n    let out: Record<string, any> | string;\n    if (typeof data === \"function\") {\n      out = data();\n    } else {\n      out = data;\n    }\n\n    if (typeof out === \"string\") {\n      console.log(`[${id}] ${out}`);\n    } else {\n      console.log(\n        `[${id}]`,\n        util.inspect(out, {\n          depth: null,\n          colors: true,\n        }),\n      );\n    }\n    // console.log();\n  }\n}\n\nlet defaultLoggerInstance: Logger | null = null;\n\nexport function getDefaultLogger(): Logger {\n  if (!defaultLoggerInstance) {\n    defaultLoggerInstance = new Logger(DEFAULT_CONFIG);\n  }\n  return defaultLoggerInstance;\n}\n","import { isVar, unify, walk } from \"../core/kernel.js\";\nimport type { Subst, Term, Var } from \"../core/types.js\";\nimport type { WhereClause } from \"./types.js\";\n\nexport const queryUtils = {\n\t/**\n\t * Walk all keys of an object with a substitution and return a new object\n\t */\n\twalkAllKeys<T extends Record<string, Term>>(\n\t\tobj: T,\n\t\tsubst: Subst,\n\t): Record<string, Term> {\n\t\tconst result: Record<string, Term> = {};\n\t\tconst keys = Object.keys(obj);\n\n\t\tfor (const key of keys) {\n\t\t\tresult[key] = walk(obj[key], subst);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Walk all values in an array with a substitution\n\t */\n\twalkAllArray(arr: Term[], subst: Subst): Term[] {\n\t\treturn arr.map((term) => walk(term, subst));\n\t},\n\n\t/**\n\t * Check if all query parameters are grounded (no variables)\n\t */\n\tallParamsGrounded(params: Record<string, Term>): boolean {\n\t\tconst values = Object.values(params);\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tif (isVar(values[i])) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Check if all array elements are grounded (no variables)\n\t */\n\tallArrayGrounded(arr: Term[]): boolean {\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif (isVar(arr[i])) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Build query parts from parameters and substitution\n\t */\n\tbuildQueryParts(params: Record<string, Term>, subst: Subst) {\n\t\tconst selectCols = Object.keys(params).sort();\n\t\tconst walkedQ: Record<string, Term> = {};\n\t\tconst whereClauses: WhereClause[] = [];\n\n\t\tfor (const col of selectCols) {\n\t\t\twalkedQ[col] = walk(params[col], subst);\n\t\t\tif (!isVar(walkedQ[col])) {\n\t\t\t\twhereClauses.push({\n\t\t\t\t\tcolumn: col,\n\t\t\t\t\tvalue: walkedQ[col],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectCols,\n\t\t\twhereClauses,\n\t\t\twalkedQ,\n\t\t};\n\t},\n\n\tonlyGrounded<T>(params: Record<string, Term<T>>) {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(params).filter(([key, value]) => !isVar(value)),\n\t\t) as Record<string, T>;\n\t},\n\n\tonlyVars(params: Record<string, Term>) {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(params).filter(([key, value]) => isVar(value)),\n\t\t) as Record<string, Var>;\n\t},\n};\n\nexport const unificationUtils = {\n\t/**\n\t * Unify all selectCols in a row with walkedQ and subst\n\t */\n\tunifyRowWithWalkedQ(\n\t\tselectCols: string[],\n\t\twalkedQ: Record<string, Term>,\n\t\trow: Record<string, any>,\n\t\tsubst: Subst,\n\t): Subst | null {\n\t\tlet s2: Subst = subst;\n\t\tlet needsClone = true;\n\n\t\tfor (let i = 0; i < selectCols.length; i++) {\n\t\t\tconst col = selectCols[i];\n\t\t\tif (!isVar(walkedQ[col])) {\n\t\t\t\tif (walkedQ[col] !== row[col]) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (needsClone) {\n\t\t\t\t\ts2 = new Map(subst);\n\t\t\t\t\tneedsClone = false;\n\t\t\t\t}\n\n\t\t\t\tconst unified = unify(walkedQ[col], row[col], s2);\n\t\t\t\tif (unified) {\n\t\t\t\t\ts2 = unified;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn s2;\n\t},\n\n\t/**\n\t * Unify arrays element by element\n\t */\n\tunifyArrays(\n\t\tqueryArray: Term[],\n\t\tfactArray: Term[],\n\t\tsubst: Subst,\n\t): Subst | null {\n\t\tif (queryArray.length !== factArray.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn unify(queryArray, factArray, subst);\n\t},\n};\n\nexport const patternUtils = {\n\t/**\n\t * Check if all select columns are tags (have id property)\n\t */\n\tallSelectColsAreTags(cols: Record<string, Term>): boolean {\n\t\tconst values = Object.values(cols);\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tif (!(values[i] as any).id) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Separate query object into select and where columns\n\t */\n\tseparateQueryColumns(queryObj: Record<string, Term>) {\n\t\tconst selectCols: Record<string, Term> = {};\n\t\tconst whereCols: Record<string, Term> = {};\n\t\tconst entries = Object.entries(queryObj);\n\n\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\tconst [key, value] = entries[i];\n\t\t\tif (isVar(value)) {\n\t\t\t\tselectCols[key] = value;\n\t\t\t} else {\n\t\t\t\twhereCols[key] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectCols,\n\t\t\twhereCols,\n\t\t};\n\t},\n\n\t/**\n\t * Separate array query into select and where terms\n\t */\n\tseparateArrayQuery(queryArray: Term[]) {\n\t\tconst selectTerms: Term[] = [];\n\t\tconst whereTerms: Term[] = [];\n\t\tconst positions: number[] = [];\n\n\t\tfor (let i = 0; i < queryArray.length; i++) {\n\t\t\tconst term = queryArray[i];\n\t\t\tif (isVar(term)) {\n\t\t\t\tselectTerms.push(term);\n\t\t\t\tpositions.push(i);\n\t\t\t} else {\n\t\t\t\twhereTerms.push(term);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectTerms,\n\t\t\twhereTerms,\n\t\t\tpositions,\n\t\t};\n\t},\n\n\t/**\n\t * Separate symmetric query values into select and where - optimized\n\t */\n\tseparateSymmetricColumns(queryObj: Record<string, Term>) {\n\t\tconst selectCols: Term[] = [];\n\t\tconst whereCols: Term[] = [];\n\t\tconst values = Object.values(queryObj);\n\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst value = values[i];\n\t\t\tif (isVar(value)) {\n\t\t\t\tselectCols.push(value);\n\t\t\t} else {\n\t\t\t\twhereCols.push(value);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectCols,\n\t\t\twhereCols,\n\t\t};\n\t},\n};\n\nexport const indexUtils = {\n\t/**\n\t * Returns the intersection of two sets\n\t */\n\tintersect<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n\t\tconst result = new Set<T>();\n\t\tsetA.forEach((item) => {\n\t\t\tif (setB.has(item)) {\n\t\t\t\tresult.add(item);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t},\n\n\t/**\n\t * Returns true if a value is indexable (string, number, boolean, or null)\n\t */\n\tisIndexable(v: any): boolean {\n\t\treturn (\n\t\t\ttypeof v === \"string\" ||\n\t\t\ttypeof v === \"number\" ||\n\t\t\ttypeof v === \"boolean\" ||\n\t\t\tv === null\n\t\t);\n\t},\n\n\t/**\n\t * Create an index for a specific position/key\n\t */\n\tcreateIndex<T>(): Map<T, Set<number>> {\n\t\treturn new Map<T, Set<number>>();\n\t},\n\n\t/**\n\t * Add a value to an index\n\t */\n\taddToIndex<T>(index: Map<T, Set<number>>, key: T, factIndex: number): void {\n\t\tlet set = index.get(key);\n\t\tif (!set) {\n\t\t\tset = new Set<number>();\n\t\t\tindex.set(key, set);\n\t\t}\n\t\tset.add(factIndex);\n\t},\n};\n\n// Export individual functions for backward compatibility\nexport const intersect = indexUtils.intersect;\nexport const isIndexable = indexUtils.isIndexable;\n","import { SimpleObservable } from \"@codespiral/observable\";\nimport { walk } from \"../core/kernel.js\";\nimport type { Goal, Subst, Term, Var } from \"../core/types.js\";\n\n/**\n * Aggregates all possible values of a logic variable into an array and binds to sourceVar in a single solution.\n */\nexport function aggregateVar(sourceVar: Var, subgoal: Goal): Goal {\n  return (input$) =>\n    new SimpleObservable((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const results: Term[] = [];\n          let subgoalEmitted = false;\n          subgoal(SimpleObservable.of(s)).subscribe({\n            next: (subst) => {\n              subgoalEmitted = true;\n              results.push(walk(sourceVar, subst));\n            },\n            error: (e: Error) => observer.error(e),\n            complete: () => {\n              const s2 = new Map(s);\n              s2.set(sourceVar.id, results);\n              observer.next(s2);\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            },\n          });\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * For each unique combination of groupVars, aggregate all values of each aggVar in aggVars, and yield a substitution with arrays bound to each aggVar.\n */\nexport function aggregateVarMulti(\n  groupVars: Var[],\n  aggVars: Var[],\n  subgoal: Goal,\n): Goal {\n  return (input$) =>\n    new SimpleObservable((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const groupMap = new Map<string, Term[][]>();\n          subgoal(SimpleObservable.of(s)).subscribe({\n            next: (subst) => {\n              const groupKey = JSON.stringify(\n                groupVars.map((v) => walk(v, subst)),\n              );\n              let aggArrays = groupMap.get(groupKey);\n              if (!aggArrays) {\n                aggArrays = aggVars.map(() => []);\n                groupMap.set(groupKey, aggArrays);\n              }\n              for (let i = 0; i < aggVars.length; i++) {\n                const value = walk(aggVars[i], subst);\n                aggArrays[i].push(value);\n              }\n            },\n            error: (e: Error) => observer.error(e),\n            complete: () => {\n              if (groupMap.size === 0) {\n                const s2 = new Map(s);\n                aggVars.forEach((v, i) => s2.set(v.id, []));\n                observer.next(s2);\n              } else {\n                for (const [groupKey, aggArrays] of groupMap.entries()) {\n                  const groupValues = JSON.parse(groupKey);\n                  const s2 = new Map(s);\n                  groupVars.forEach((v, index) =>\n                    s2.set(v.id, groupValues[index]),\n                  );\n                  aggVars.forEach((v, index) => s2.set(v.id, aggArrays[index]));\n                  observer.next(s2);\n                }\n              }\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            },\n          });\n        },\n        error: (e: Error) => observer.error(e),\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n"],"mappings":";AAAA,OAAO,aAAa;AAEpB,SAAS,oBAAAA,mBAAkB,SAAS,OAAO,YAAY;;;ACFvD,SAAS,oBAAAC,mBAAkB,WAAW;;;ACAtC,SAAS,wBAAwB;AAK1B,IAAM,cAAc,OAAO,IAAI,wBAAwB;AAMvD,SAAS,mBACd,MACA,WAIA,aACA;AACA,SAAO,SAAS,cAAc,OAA4B;AACxD,UAAM,SAAS,KAAK,IAAI,CAAC,MAAM,KAAK,GAAG,KAAK,CAAC;AAC7C,UAAM,gBAAgB,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE;AAEtD,QAAI,iBAAiB,aAAa;AAChC,YAAM,SAAS,UAAU,QAAQ,KAAK;AACtC,UAAI,WAAW,MAAM;AACnB,eAAO;AAAA,MACT;AACA,UAAI,WAAW,aAAa;AAC1B,eAAO;AAAA,MACT;AAAA,IAEF;AAGA,UAAM,cAAwB,KAC3B,OAAO,CAAC,MAAM,MAAM,CAAC,CAAC,EACtB,IAAI,CAAC,MAAO,EAAU,EAAE;AAC3B,QAAI,YAAY,SAAS,GAAG;AAC1B,aAAO,kBAAkB,OAAO,eAAe,WAAW;AAAA,IAC5D;AACA,WAAO;AAAA,EACT;AACF;AAEO,SAAS,YACd,MACA,WAIA,cAAc,KAAK,SAAS,GACtB;AACN,QAAM,gBAAgB,mBAAmB,MAAM,WAAW,WAAW;AAErE,SAAO,CAAC,WACN,IAAI,iBAAwB,CAAC,aAAa;AACxC,UAAM,MAAM,OAAO,UAAU;AAAA,MAC3B,MAAM,CAAC,UAAU;AACf,YAAI;AACF,gBAAM,SAAS,cAAc,KAAK;AAClC,cAAI,WAAW,MAAM;AACnB,qBAAS,KAAK,MAAM;AACpB;AAAA,UACF;AAAA,QAEF,SAAS,OAAO;AACd,mBAAS,QAAQ,KAAK;AAAA,QACxB;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAED,WAAO,MAAM,IAAI,YAAY;AAAA,EAC/B,CAAC;AACL;;;ACxEO,IAAM,wBAAwB,OAAO,uBAAuB;AAQnE,IAAI,oBAAoB;AACxB,IAAM,cAAc;AAEb,SAAS,kBACd,OACA,UACA,aACO;AACP,QAAM,WACH,MAAM,IAAI,qBAAqB,KAA+B,CAAC;AAGlE,QAAM,oBAAoB,YAAY,OAAO,CAAC,UAAU;AACtD,UAAM,QAAQ,KAAK,EAAE,KAAK,OAAO,IAAI,MAAM,GAAG,KAAK;AACnD,WAAO,MAAM,KAAK;AAAA,EACpB,CAAC;AAGD,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO;AAAA,EACT;AAGA,MAAI,qBAAqB,aAAa;AACpC,wBAAoB;AAAA,EACtB;AAEA,QAAM,aAAkC;AAAA,IACtC,IAAI,cAAc,mBAAmB;AAAA,IACrC;AAAA;AAAA,IAEA;AAAA,EACF;AAEA,QAAM,WAAW,IAAI,IAAI,KAAK;AAC9B,WAAS,IAAI,uBAAuB,CAAC,GAAG,UAAU,UAAU,CAAC;AAC7D,SAAO;AACT;AAEO,SAAS,qBAAqB,OAAqC;AACxE,SAAQ,MAAM,IAAI,qBAAqB,KAA+B,CAAC;AACzE;AAEO,SAAS,uBACd,OACA,YACO;AACP,QAAM,WAAW,qBAAqB,KAAK;AAC3C,QAAM,mBAAmB,SAAS,OAAO,CAAC,MAAM,CAAC,WAAW,SAAS,EAAE,EAAE,CAAC;AAE1E,QAAM,WAAW,IAAI,IAAI,KAAK;AAC9B,MAAI,iBAAiB,WAAW,GAAG;AACjC,aAAS,OAAO,qBAAqB;AAAA,EACvC,OAAO;AACL,aAAS,IAAI,uBAAuB,gBAAgB;AAAA,EACtD;AACA,SAAO;AACT;AAEO,SAAS,eACd,OACA,gBACc;AACd,QAAM,WAAW,qBAAqB,KAAK;AAC3C,MAAI,SAAS,WAAW,GAAG;AACzB,WAAO;AAAA,EACT;AAGA,QAAM,CAAC,QAAQ,MAAM,IAAI,SAAS;AAAA,IAGhC,CAAC,CAAC,MAAM,IAAI,GAAG,MACb,EAAE,YAAY,KAAK,CAAC,MAAM,eAAe,SAAS,CAAC,CAAC,IAChD,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,IAAI,IACnB,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,IACzB,CAAC,CAAC,GAAG,CAAC,CAAC;AAAA,EACT;AAIA,MAAI,eAAe;AAEnB,aAAW,WAAW,QAAQ;AAC5B,UAAM,SAAS,QAAQ,SAAS,YAAY;AAC5C,QAAI,WAAW,MAAM;AACnB,aAAO;AAAA,IACT,WAAW,WAAW,aAAa;AAEjC,aAAO,KAAK,OAAO;AAAA,IACrB,OAAO;AACL,aAAO,KAAK,OAAO;AAEnB,qBAAe;AAAA,IACjB;AAAA,EACF;AAUA,SAAO;AACT;;;AFzGO,IAAM,gBAAgB,OAAO,eAAe;AAC5C,IAAM,kBAAkB,OAAO,iBAAiB;AAChD,IAAM,wBAAwB,OAAO,uBAAuB;AAC5D,IAAM,uBAAuB,OAAO,sBAAsB;AAEjE,IAAI,aAAa;AACjB,IAAI,eAAe;AACZ,SAAS,cAAc;AAC5B,SAAO;AACT;AAMO,SAAS,KAAK,OAAO,IAAS;AACnC,SAAO;AAAA,IACL,KAAK;AAAA,IACL,IAAI,GAAG,IAAI,IAAI,YAAY;AAAA,EAC7B;AACF;AAKO,SAAS,kBAAwB;AACtC,eAAa;AACf;AAQO,SAAS,KAAK,GAAS,GAAgB;AAC5C,MAAI,UAAU;AAEd,MACE,CAAC,MAAM,OAAO,KACd,CAAC,OAAO,OAAO,KACf,CAAC,MAAM,QAAQ,OAAO,KACtB,OAAO,YAAY,UACnB;AACA,WAAO;AAAA,EACT;AAGA,SAAO,MAAM,OAAO,KAAK,EAAE,IAAI,QAAQ,EAAE,GAAG;AAC1C,cAAU,EAAE,IAAI,QAAQ,EAAE;AAAA,EAC5B;AAGA,MAAI,OAAO,OAAO,GAAG;AAEnB,WAAO,KAAK,KAAK,QAAQ,MAAM,CAAC,GAAG,KAAK,QAAQ,MAAM,CAAC,CAAC;AAAA,EAC1D;AAEA,MAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,WAAO,QAAQ,IAAI,CAAC,MAAM,KAAK,GAAG,CAAC,CAAC;AAAA,EACtC;AAEA,MACE,WACA,OAAO,YAAY,YACnB,CAAC,MAAM,OAAO,KACd,CAAC,YAAY,OAAO,GACpB;AACA,UAAM,MAA4B,CAAC;AACnC,eAAW,KAAK,SAAS;AACvB,UAAI,OAAO,OAAO,SAAS,CAAC,GAAG;AAC7B,YAAI,CAAC,IAAI,KAAM,QAAgB,CAAC,GAAG,CAAC;AAAA,MACtC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKO,SAAS,YAAY,GAAQ,KAAW,GAAwB;AACrE,MAAI,YAAY,GAAG,KAAK,CAAC,GAAG;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,KAAK,IAAI,IAAI,CAAC;AACpB,KAAG,IAAI,EAAE,IAAI,GAAG;AAChB,SAAO;AACT;AAKA,SAAS,YAAY,GAAQ,GAAS,GAAmB;AACvD,QAAM,YAAY,KAAK,GAAG,CAAC;AAC3B,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO,EAAE,OAAO,UAAU;AAAA,EAC5B;AACA,MAAI,OAAO,SAAS,GAAG;AACrB,WACE,YAAY,GAAG,UAAU,MAAM,CAAC,KAAK,YAAY,GAAG,UAAU,MAAM,CAAC;AAAA,EAEzE;AACA,MAAI,MAAM,QAAQ,SAAS,GAAG;AAC5B,eAAW,QAAQ,WAAW;AAC5B,UAAI,YAAY,GAAG,MAAM,CAAC,GAAG;AAC3B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAMO,SAAS,UAAU,GAAS,GAAS,GAA+B;AACzE,MAAI,MAAM,MAAM;AACd,WAAO;AAAA,EACT;AAGA,MAAI,MAAM,GAAG;AACX,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,KAAK,GAAG,CAAC;AACzB,QAAM,UAAU,KAAK,GAAG,CAAC;AAGzB,MAAI,YAAY,SAAS;AACvB,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,OAAO,EAAG,QAAO,YAAY,SAAS,SAAS,CAAC;AAC1D,MAAI,MAAM,OAAO,EAAG,QAAO,YAAY,SAAS,SAAS,CAAC;AAG1D,MAAI,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU;AAC9D,WAAO,YAAY,UAAU,IAAI;AAAA,EACnC;AAEA,MAAI,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU;AAC9D,WAAO,YAAY,UAAU,IAAI;AAAA,EACnC;AAEA,MAAI,MAAM,OAAO,KAAK,MAAM,OAAO,EAAG,QAAO;AAC7C,MAAI,OAAO,OAAO,KAAK,OAAO,OAAO,GAAG;AACtC,UAAM,KAAK,MAAM,QAAQ,MAAM,QAAQ,MAAM,CAAC;AAC9C,QAAI,OAAO,KAAM,QAAO;AACxB,WAAO,MAAM,QAAQ,MAAM,QAAQ,MAAM,EAAE;AAAA,EAC7C;AAEA,MACE,MAAM,QAAQ,OAAO,KACrB,MAAM,QAAQ,OAAO,KACrB,QAAQ,WAAW,QAAQ,QAC3B;AACA,QAAI,eAA6B;AACjC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,qBAAe,MAAM,QAAQ,CAAC,GAAG,QAAQ,CAAC,GAAG,YAAY;AACzD,UAAI,iBAAiB,KAAM,QAAO;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAEA,MAAI,KAAK,UAAU,OAAO,MAAM,KAAK,UAAU,OAAO,GAAG;AACvD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAMO,SAAS,qBACd,GACA,GACA,GACc;AACd,QAAM,SAAS,UAAU,GAAG,GAAG,CAAC;AAEhC,MAAI,WAAW,QAAQ,MAAM,MAAM;AAEjC,QAAI,CAAC,OAAO,IAAI,qBAAqB,GAAG;AACtC,aAAO;AAAA,IACT;AAGA,UAAM,iBAA2B,CAAC;AAClC,eAAW,CAAC,GAAG,KAAK,QAAQ;AAC1B,UAAI,CAAC,EAAE,IAAI,GAAG,KAAK,OAAO,QAAQ,UAAU;AAC1C,uBAAe,KAAK,GAAG;AAAA,MACzB;AAAA,IACF;AAGA,QAAI,eAAe,SAAS,GAAG;AAC7B,aAAO,eAAe,QAAQ,cAAc;AAAA,IAC9C;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,QAAQ;AAMd,SAAS,MAAM,GAAmB;AACvC,SAAO,OAAO,MAAM,YAAY,MAAM,QAAS,EAAU,QAAQ;AACnE;AAKO,IAAM,MAAe,EAAE,KAAK,MAAM;AAKlC,SAAS,KAAK,MAAY,MAAsB;AACrD,SAAO;AAAA,IACL,KAAK;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAKO,SAAS,iBAAiB,KAAwB;AACvD,SAAO,IAAI,YAAuB,CAAC,MAAM,SAAS,KAAK,MAAM,IAAI,GAAG,GAAG;AACzE;AAKO,SAAS,aAA0B,OAAuB;AAC/D,SAAO,iBAAiB,KAAK;AAC/B;AAKO,SAAS,OAAO,GAAwB;AAC7C,SAAO,OAAO,MAAM,YAAY,MAAM,QAAS,EAAe,QAAQ;AACxE;AAKO,SAAS,MAAM,GAAuB;AAC3C,SAAO,OAAO,MAAM,YAAY,MAAM,QAAS,EAAc,QAAQ;AACvE;AAKO,SAAS,YAAY,GAAyB;AACnD,SAAO,OAAO,CAAC,KAAK,MAAM,CAAC;AAC7B;AAKO,SAAS,iBAAiB,MAAoB;AACnD,QAAM,MAAM,CAAC;AACb,MAAI,MAAM;AACV,SACE,OACA,OAAO,QAAQ,YACf,SAAS,OACR,IAAY,QAAQ,QACrB;AACA,QAAI,KAAM,IAAY,IAAI;AAC1B,UAAO,IAAY;AAAA,EACrB;AACA,SAAO;AACT;AAGO,SAAS,SACd,YACM;AACN,QAAM,YAAY,WAAW,QAAQ;AACrC,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC;AAAA,IACD,CAAC,WACC,IAAIC,kBAAiB,CAAC,aAAa;AACjC,YAAM,OAAO,OAAO,UAAU;AAAA,QAC5B,MAAM,CAAC,MAAM;AACX,gBAAM,OAAO,WAAW,CAAC;AACzB,eAAK,UAAU;AAAA,YACb,MAAM,CAAC,OAAO,SAAS,KAAK,EAAE;AAAA,YAC9B,OAAO,CAAC,MAAM,SAAS,QAAQ,CAAC;AAAA,YAChC,UAAU,MAAM;AAAA,YAEhB;AAAA;AAAA,UACF,CAAC;AAAA,QACH;AAAA,QACA,OAAO,CAAC,MAAM,SAAS,QAAQ,CAAC;AAAA,QAChC,UAAU,MAAM,SAAS,WAAW;AAAA,MACtC,CAAC;AACD,aAAO,MAAM,KAAK,cAAc;AAAA,IAClC,CAAC;AAAA,EACL;AACF;AAGO,SAAS,WACd,OACA,UACyB;AACzB,SAAO,MAAM,OAAO,CAAC,QAAQ,SAAS,KAAK,MAAM,GAAG,QAAQ;AAC9D;AAKO,SAAS,oBACd,GACA,MACA,WACA,WACAC,SACO;AACP,QAAM,UAAU,YAAY;AAC5B,QAAM,aAAc,EAAE,IAAI,eAAe,KAAe,CAAC;AACzD,QAAM,UAAU;AAAA,IACd,GAAG;AAAA,IACH;AAAA,MACE,MAAM,OAAO,IAAI;AAAA,MACjB,IAAI;AAAA,MACJ,GAAIA,YAAW,SAAY,EAAE,QAAAA,QAAO,IAAI,CAAC;AAAA,IAC3C;AAAA,EACF;AACA,QAAM,mBAAoB,EAAE,IAAI,oBAAoB,KAAgB,CAAC;AAErE,WAAS,yBAAyB,OAAuB;AACvD,WAAO,MAAM,QAAQ,CAAC,SAAS;AAC7B,YAAM,aAAc,MAAc,aAAc,CAAC;AACjD,UAAI,cAAc,WAAW,SAAS,GAAG;AACvC,eAAO,CAAC,GAAG,yBAAyB,UAAU,CAAC;AAAA,MACjD,OAAO;AACL,eAAO,CAAC,IAAI;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH;AACA,WAAS,qBAAqB,OAAuB;AACnD,WAAO,MAAM,QAAQ,CAAC,SAAS;AAC7B,YAAM,iBAAkB,MAAc,aAAc,CAAC;AACrD,YAAM,iBAAkB,MAAc,aAAc,CAAC;AACrD,YAAM,aAAa,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAG,gBAAgB,GAAG,cAAc,CAAC,CAAC;AACtE,UAAI,cAAc,WAAW,SAAS,GAAG;AACvC,eAAO,CAAC,GAAG,qBAAqB,UAAU,CAAC;AAAA,MAC7C,OAAO;AACL,eAAO,CAAC,IAAI;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,WAAW,CAAC,GAAG,WAAW,GAAG,SAAS;AAC5C,QAAM,gBAAgB,yBAAyB,SAAS;AACxD,QAAM,eAAe,qBAAqB,QAAQ;AAElD,QAAM,WAAW,IAAI,IAAI,CAAC;AAC1B,WAAS,IAAI,eAAe,OAAO;AACnC,WAAS,IAAI,iBAAiB,OAAO;AACrC,WAAS,IAAI,uBAAuB;AAAA,IAClC,GAAG,oBAAI,IAAI,CAAC,GAAG,WAAW,GAAG,aAAa,CAAC;AAAA,EAC7C,CAAC;AACD,WAAS,IAAI,sBAAsB;AAAA,IACjC,GAAG,oBAAI,IAAI;AAAA,MACT,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACL,CAAC;AAAA,EACH,CAAC;AACD,SAAO;AACT;AAKO,SAAS,iBACd,MACA,WACA,WACA,IACA;AACA,WAAS,UAAU,QAAiC;AAClD,UAAM,iBAAiB,OAAO;AAAA,MAC5B,IAAI,CAAC,MAAM,oBAAoB,GAAG,MAAM,WAAW,SAAS,CAAC;AAAA,IAC/D;AACA,WAAO,GAAG,cAAc;AAAA,EAC1B;AACA,EAAC,UAAkB,YAAY;AAC/B,EAAC,UAAkB,YAAY;AAC/B,SAAO,eAAe,WAAW,QAAQ,EAAE,OAAO,KAAK,CAAC;AACxD,SAAO;AACT;;;ADnYO,SAAS,GAAG,GAAS,GAAe;AACzC,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC;AAAA,IACD,CAAC,WACC,IAAIC,kBAAiB,CAAC,aAAa;AACjC,YAAM,MAAM,OAAO,UAAU;AAAA,QAC3B,OAAO,CAAC,QAAe,SAAS,MAAM,GAAG;AAAA,QACzC,UAAU,MAAM,SAAS,SAAS;AAAA,QAClC,MAAM,CAAC,UAAU;AACf,gBAAM,KAAK,MAAM,GAAG,GAAG,KAAK;AAC5B,cAAI,IAAI;AACN,qBAAS,KAAK,EAAE;AAAA,UAClB;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO,MAAM,IAAI,YAAY;AAAA,IAC/B,CAAC;AAAA,EACL;AACF;AA+BO,SAAS,MAAM,GAAmC;AACvD,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX;AACA,cAAM,YAAY,MAAM,KAAK,EAAE,QAAQ,EAAE,OAAO,GAAG,MAAM,KAAK,CAAC;AAC/D,cAAM,UAAU,EAAE,GAAG,SAAS;AAC9B,gBAAQA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,UACxC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,UAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,UACrC,UAAU,MAAM;AACd;AACA,gBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,UACrD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,OAAO,CAAC,QAAe,SAAS,MAAM,GAAG;AAAA,MACzC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAKO,SAAS,KAAK,IAAU,IAAgB;AAC7C,SAAO,GAAG,IAAI,EAAE;AAClB;AAKO,SAAS,KAAK,IAAU,IAAgB;AAC7C,SAAO,IAAI,IAAI,EAAE;AACnB;AAOO,IAAM,MAAM,IAAI,UAAwB;AAC7C,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,CAAC,WAAW;AAAA,EACrB;AACA,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,MAAM,CAAC;AAAA,EAChB;AACA,SAAO;AAAA,IAAiB;AAAA,IAAO;AAAA,IAAO,CAAC;AAAA,IAAG,CAAC,mBACzC,MAAM,OAAO,CAAC,KAAK,SAAS,KAAK,GAAG,GAAG,cAAc;AAAA,EACvD;AACF;AAOO,IAAM,KAAK,IAAI,UAAwB;AAC5C,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,MAAMA,kBAAiB,MAAM;AAAA,EACtC;AACA,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,MAAM,CAAC;AAAA,EAChB;AAEA,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD;AAAA,IACA,CAAC,WAAoC;AACnC,aAAO,IAAIA,kBAAwB,CAAC,aAAa;AAE/C,cAAM,eAAe,OAAO,KAAK,MAAM,CAAC;AAExC,YAAI,iBAAiB;AACrB,cAAM,gBAAgC,CAAC;AAEvC,cAAM,iBAAiB;AAAA,UACrB,MAAM,CAAC,UAAiB,SAAS,KAAK,KAAK;AAAA,UAC3C,OAAO,CAAC,QAAe,SAAS,MAAM,GAAG;AAAA,UACzC,UAAU,MAAM;AACd;AACA,gBAAI,mBAAmB,MAAM,QAAQ;AACnC,uBAAS,SAAS;AAAA,YACpB;AAAA,UACF;AAAA,QACF;AACA,mBAAW,QAAQ,OAAO;AACxB,gBAAM,mBAAmB,KAAK,YAAY,EAAE,UAAU,cAAc;AACpE,wBAAc,KAAK,gBAAgB;AAAA,QACrC;AAgBA,eAAO,MAAM;AACX,wBAAc,QAAQ,CAAC,QAAQ,IAAI,cAAc,CAAC;AAAA,QACpD;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAKO,SAAS,SAAS,SAAyB;AAChD,QAAM,cAAc,QAAQ,IAAI,CAAC,WAAW,IAAI,GAAG,MAAM,CAAC;AAC1D,SAAO,GAAG,GAAG,WAAW;AAC1B;AAKO,SAAS,KACd,IACkB;AAClB,SAAQ,IAAI,SAA4B;AAEtC,UAAM,MAAM,KAAK,KAAK,SAAS,CAAC;AAChC,UAAM,YAAY,KAAK,MAAM,GAAG,EAAE;AAClC,WAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,YAAM,eAAe,OAAO,UAAU;AAAA,QACpC,MAAM,CAAC,MAAM;AACX,cAAI;AAEF,kBAAM,eAAe,UAAU,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,CAAC;AAExD,kBAAM,eAAe,aAAa,KAAK,CAAC,QAAQ,MAAM,GAAG,CAAC;AAC1D,gBAAI,CAAC,cAAc;AAEjB,oBAAM,SAAS,GAAG,GAAG,YAAY;AAEjC,oBAAM,UAAU,MAAM,KAAK,QAAQ,CAAC;AACpC,kBAAI,YAAY,MAAM;AACpB,yBAAS,KAAK,OAAO;AAAA,cACvB;AAAA,YACF;AAAA,UACF,SAAS,OAAO;AACd,qBAAS,QAAQ,KAAK;AAAA,UACxB;AAAA,QACF;AAAA,QACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,QACrC,UAAU,MAAM,SAAS,SAAS;AAAA,MACpC,CAAC;AACD,aAAO,MAAM,aAAa,cAAc;AAAA,IAC1C,CAAC;AAAA,EACL;AACF;AAMO,SAAS,SAAS,WAAiB,YAAwB;AAChE,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,SAAS;AACb,QAAI,YAAY;AAEhB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX;AACA,YAAI,aAAa;AACjB,cAAM,UAAmB,CAAC;AAE1B,kBAAUA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,UAC1C,MAAM,CAAC,OAAO;AACZ,yBAAa;AACb,oBAAQ,KAAK,EAAE;AAAA,UACjB;AAAA,UACA,UAAU,MAAM;AACd,gBAAI,YAAY;AAEd,yBAAW,UAAU,SAAS;AAC5B,yBAAS,KAAK,MAAM;AAAA,cACtB;AAAA,YACF,OAAO;AAEL,yBAAWA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,gBAC3C,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,gBAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,gBACrC,UAAU,MAAM;AACd;AACA,sBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,gBACrD;AAAA,cACF,CAAC;AACD;AAAA,YACF;AACA;AACA,gBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,UACrD;AAAA,UACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AAED,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAKO,SAAS,KAAK,QAAc,UAAgB,UAAsB;AACvE,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,YAAI,YAAY;AAChB,cAAM,UAAmB,CAAC;AAC1B,eAAOA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,UACvC,MAAM,CAAC,OAAO;AACZ,wBAAY;AACZ,oBAAQ,KAAK,EAAE;AAAA,UACjB;AAAA,UACA,UAAU,MAAM;AACd,gBAAI,WAAW;AACb,kBAAI,YAAY;AAChB,yBAAW,MAAM,SAAS;AACxB,yBAASA,kBAAiB,GAAG,EAAE,CAAC,EAAE,UAAU;AAAA,kBAC1C,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,kBAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,kBACrC,UAAU,MAAM;AACd;AACA,wBAAI,cAAc,QAAQ,QAAQ;AAChC,+BAAS,WAAW;AAAA,oBACtB;AAAA,kBACF;AAAA,gBACF,CAAC;AAAA,cACH;AACA,kBAAI,QAAQ,WAAW,GAAG;AACxB,yBAAS,WAAW;AAAA,cACtB;AAAA,YACF,OAAO;AACL,uBAASA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,gBACzC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,gBAC5B,UAAU,MAAM,SAAS,SAAS;AAAA,gBAClC,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,cACvC,CAAC;AAAA,YACH;AAAA,UACF;AAAA,UACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;AAKO,SAAS,KAAK,MAAkB;AACrC,SAAO,CAAC,WAAW,KAAK,MAAM,EAAE,KAAK,KAAK,CAAC,CAAC;AAC9C;AAKO,SAAS,QAAQ,MAAY,WAAyB;AAC3D,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,YAAY;AAChB,UAAM,QAAQ,WAAW,MAAM;AAC7B,UAAI,CAAC,WAAW;AACd,oBAAY;AACZ,iBAAS,QAAQ,IAAI,MAAM,wBAAwB,SAAS,IAAI,CAAC;AAAA,MACnE;AAAA,IACF,GAAG,SAAS;AACZ,SAAK,MAAM,EAAE,UAAU;AAAA,MACrB,MAAM,CAAC,WAAW;AAChB,YAAI,CAAC,WAAW;AACd,mBAAS,KAAK,MAAM;AAAA,QACtB;AAAA,MACF;AAAA,MACA,UAAU,MAAM;AACd,YAAI,CAAC,WAAW;AACd,sBAAY;AACZ,uBAAa,KAAK;AAClB,mBAAS,WAAW;AAAA,QACtB;AAAA,MACF;AAAA,MACA,OAAO,CAAC,UAAU;AAChB,YAAI,CAAC,WAAW;AACd,sBAAY;AACZ,uBAAa,KAAK;AAClB,mBAAS,QAAQ,KAAK;AAAA,QACxB;AAAA,MACF;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AACX,mBAAa,KAAK;AAAA,IACpB;AAAA,EACF,CAAC;AACL;AAKO,SAAS,IACd,MACA,YACA,WAC2E;AAC3E,SAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,UAAM,UAAmB,CAAC;AAC1B,QAAI,YAAY;AAChB,QAAI;AACJ,UAAM,gBAAgB,YAAY,QAAQ,MAAM,SAAS,IAAI;AAC7D,UAAM,cAAc,aAChB,CAAC,WACC,cAAc,MAAM,EAAE,KAAK,KAAK,UAAU,CAAC,IAC7C;AACJ,gBAAYA,kBAAiB,GAAG,oBAAI,IAAI,CAAC,CAAC,EAAE,UAAU;AAAA,MACpD,MAAM,CAAC,WAAW;AAChB,gBAAQ,KAAK,MAAM;AAAA,MACrB;AAAA,MACA,UAAU,MAAM;AACd,oBAAY;AACZ,gBAAQ;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,OAAO,CAAC,QAAQ;AACd,gBAAQ;AACR,gBAAQ;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AASA,SAAS,UAAU,KAAc,MAAuB;AACtD,MAAI,CAAC,KAAM,QAAO;AAClB,QAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,MAAI,UAAmB;AACvB,aAAW,QAAQ,OAAO;AACxB,QAAI,CAAC,QAAS,QAAO;AACrB,UAAM,QAAQ,KAAK,MAAM,0CAA0C;AACnE,QAAI,OAAO;AACT,YAAM,CAAC,GAAG,QAAQ,WAAW,SAAS,IAAI;AAC1C,YAAM,aAAa;AACnB,YAAM,QAAQ,WAAW,MAAM;AAC/B,iBAAW,SAAS,CAAC,GAAG,KAAK,CAAC,MAAe;AAC3C,cAAM,OAAO;AACb,eAAO,OAAO,SAAS,MAAM;AAAA,MAC/B,CAAC;AAAA,IACH,WAAW,KAAK,SAAS,GAAG,GAAG;AAC7B,YAAM,WAAW,KAAK,MAAM,kBAAkB;AAC9C,UAAI,UAAU;AACZ,cAAM,CAAC,GAAG,QAAQ,GAAG,IAAI;AACzB,cAAM,aAAa;AACnB,cAAM,QAAQ,WAAW,MAAM;AAC/B,mBAAW,SAAS,CAAC,GAAG,SAAS,GAAG,CAAC;AAAA,MACvC,OAAO;AACL,cAAM,aAAa;AACnB,kBAAU,WAAW,IAAI;AAAA,MAC3B;AAAA,IACF,OAAO;AACL,YAAM,aAAa;AACnB,gBAAU,WAAW,IAAI;AAAA,IAC3B;AAAA,EACF;AACA,SAAO;AACT;AAIO,SAAS,QACd,UACA,WACA,WACM;AACN,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX,cAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,YAAI,MAAM,KAAK,EAAG;AAClB,YAAI,UAAU,OAAW;AACzB,YAAI,OAAO,cAAc,UAAU;AACjC,gBAAM,QAAQ,UAAU,OAAO,SAAS;AACxC,gBAAM,UAAU,MAAM,WAAW,OAAO,CAAC;AACzC,cAAI,YAAY,KAAM,UAAS,KAAK,OAAO;AAAA,QAC7C,OAAO;AACL,gBAAM,SAAkC,CAAC;AACzC,qBAAW,OAAO,WAAW;AAC3B,mBAAO,GAAG,IAAI,UAAU,OAAO,UAAU,GAAG,CAAC;AAAA,UAC/C;AACA,gBAAM,UAAU,MAAM,WAAW,QAAQ,CAAC;AAC1C,cAAI,YAAY,KAAM,UAAS,KAAK,OAAO;AAAA,QAC7C;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAaO,SAAS,eACd,WACA,aACA,YACM;AACN,QAAM,OAAO,QAAQ,WAAW;AAChC,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,OAAO,MAAM;AACjB;AAEA,YAAI;AACJ,YACE,OAAO,cAAc,YACrB,cAAc,QACd,CAAC,MAAM,SAAS,GAChB;AACA,gBAAM,WAAoC,CAAC;AAC3C,gBAAM,kBAAkB;AACxB,qBAAW,OAAO,iBAAiB;AACjC,qBAAS,GAAG,IAAI,KAAK,gBAAgB,GAAG,GAAG,CAAC;AAAA,UAC9C;AACA,qBAAW;AAAA,QACb,OAAO;AACL,qBAAW,KAAK,WAAW,CAAC;AAAA,QAC9B;AAEA,YAAI;AACJ,YAAI;AACF,mBAAS,MAAM,KAAK,SAAS,QAAQ;AAAA,QACvC,SAAS,GAAG;AACV,mBAAS,QAAQ,CAAC;AAClB;AACA,cAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AACnD;AAAA,QACF;AAEA,YACE,OAAO,eAAe,YACtB,eAAe,QACf,CAAC,MAAM,UAAU,GACjB;AACA,gBAAM,mBAAmB;AACzB,cACE,UACA,OAAO,WAAW,YAClB,UAAU,UACV,OAAQ,OAA6B,SAAS,YAC9C;AACA,YAAC,OACE,KAAK,CAAC,aAAsB;AAC3B,kBAAI,eAAe;AACnB,yBAAW,OAAO,kBAAkB;AAClC,sBAAM,QACJ,YACA,OAAO,aAAa,YACpB,aAAa,OACR,SAAqC,GAAG,IACzC;AACN,sBAAM,UAAU;AAAA,kBACd,iBAAiB,GAAG;AAAA,kBACpB;AAAA,kBACA;AAAA,gBACF;AACA,oBAAI,YAAY,MAAM;AACpB,iCAAe;AAAA,gBACjB,OAAO;AAEL;AACA,sBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AACnD;AAAA,gBACF;AAAA,cACF;AACA,uBAAS,KAAK,YAAY;AAC1B;AACA,kBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,YACrD,CAAC,EACA,MAAM,CAAC,MAAe;AACrB,uBAAS,QAAQ,CAAC;AAClB;AACA,kBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,YACrD,CAAC;AAAA,UACL,OAAO;AACL,kBAAM,WAAW;AACjB,gBAAI,eAAe;AACnB,uBAAW,OAAO,kBAAkB;AAClC,oBAAM,QACJ,YAAY,OAAO,aAAa,YAAY,aAAa,OACpD,SAAqC,GAAG,IACzC;AACN,oBAAM,UAAU;AAAA,gBACd,iBAAiB,GAAG;AAAA,gBACpB;AAAA,gBACA;AAAA,cACF;AACA,kBAAI,YAAY,MAAM;AACpB,+BAAe;AAAA,cACjB,OAAO;AAEL;AACA,oBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AACnD;AAAA,cACF;AAAA,YACF;AACA,qBAAS,KAAK,YAAY;AAC1B;AACA,gBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,UACrD;AAAA,QACF,OAAO;AACL,cACE,UACA,OAAO,WAAW,YAClB,UAAU,UACV,OAAQ,OAA6B,SAAS,YAC9C;AACA,YAAC,OACE,KAAK,CAAC,aAAsB;AAC3B,oBAAM,UAAU,MAAM,YAAY,UAAU,CAAC;AAC7C,kBAAI,YAAY,KAAM,UAAS,KAAK,OAAO;AAC3C;AACA,kBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,YACrD,CAAC,EACA,MAAM,CAAC,MAAe;AACrB,uBAAS,QAAQ,CAAC;AAClB;AACA,kBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,YACrD,CAAC;AAAA,UACL,OAAO;AACL,kBAAM,UAAU,MAAM,YAAY,QAAQ,CAAC;AAC3C,gBAAI,YAAY,KAAM,UAAS,KAAK,OAAO;AAC3C;AACA,gBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,UACrD;AAAA,QACF;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAgBO,SAAS,SACd,MACA,YACA,SACA,aAAoE,CAClE,SACA,MACG,iBAAiB,OAAO,GACvB;AACN,SAAO;AAAA,IAAiB;AAAA,IAAY,CAAC;AAAA,IAAG,CAAC,IAAI;AAAA,IAAG,CAAC,WAC/C,OAAO;AAAA,MACL,QAAQ,CAAC,MAAa;AACpB,cAAM,YAAuB,CAAC;AAE9B,eAAO,IAAIA,kBAAwB,CAAC,aAAa;AAC/C,gBAAM,sBAAsB,KAAKA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YACjE,MAAM,CAAC,cAAc;AAEnB,oBAAM,QAAQ,KAAK,YAAY,SAAS;AACxC,wBAAU,KAAK,KAAK;AAAA,YACtB;AAAA,YACA,OAAO,CAAC,UAAU;AAChB,wBAAU,SAAS;AACnB,uBAAS,QAAQ,KAAK;AAAA,YACxB;AAAA,YACA,UAAU,MAAM;AAGd,oBAAM,aAAa,WAAW,WAAW,CAAC;AAC1C,oBAAM,UAAU,MAAM,SAAS,YAAY,CAAC;AAC5C,kBAAI,YAAY,MAAM;AACpB,yBAAS,KAAK,OAAO;AAAA,cACvB;AACA,wBAAU,SAAS;AACnB,uBAAS,WAAW;AAAA,YACtB;AAAA,UACF,CAAC;AAED,iBAAO,MAAM;AACX,gCAAoB,cAAc;AAClC,sBAAU,SAAS;AAAA,UACrB;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAEO,SAAS,OACd,MACA,YAKM;AACN,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC,IAAI;AAAA,IACL,CAAC,WACC,IAAIA,kBAAwB,CAAC,aAAa;AACxC,YAAM,WAA2B,CAAC;AAClC,YAAM,WAAW,OAAO,UAAU;AAAA,QAChC,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,QACrC,UAAU,MAAM,SAAS,SAAS;AAAA,QAClC,MAAM,CAAC,eAAe;AACpB,gBAAM,kBAA2B,CAAC;AAClC,gBAAM,UAAU,KAAKA,kBAAiB,GAAG,UAAU,CAAC,EAAE,UAAU;AAAA,YAC9D,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,YACrC,UAAU,MAAM;AACd,yBAAW,UAAU,iBAAiB,UAAU;AAEhD,8BAAgB,SAAS;AAAA,YAC3B;AAAA,YACA,MAAM,CAAC,cAAc;AACnB,8BAAgB,KAAK,SAAS;AAAA,YAChC;AAAA,UACF,CAAC;AACD,mBAAS,KAAK,OAAO;AAAA,QACvB;AAAA,MACF,CAAC;AAED,aAAO,MAAM;AACX,iBAAS,QAAQ,CAAC,YAAY,QAAQ,YAAY,CAAC;AACnD,iBAAS,YAAY;AAAA,MACvB;AAAA,IACF,CAAC;AAAA,EACL;AACF;;;AItxBA,SAAS,oBAAAC,yBAAwB;AAQjC,SAAS,aAAa,KAAe;AACnC,MAAI,YAAY,GAAG,GAAG;AACpB,WAAO,iBAAiB,GAAG,EAAE,IAAI,YAAY;AAAA,EAC/C,WAAW,MAAM,QAAQ,GAAG,GAAG;AAC7B,WAAO,IAAI,IAAI,YAAY;AAAA,EAC7B,WAAW,OAAO,OAAO,QAAQ,YAAY,CAAC,MAAM,GAAG,GAAG;AACxD,UAAM,MAAW,CAAC;AAClB,eAAW,KAAK,KAAK;AACnB,UAAI,OAAO,OAAO,KAAK,CAAC,GAAG;AACzB,YAAI,CAAC,IAAI,aAAa,IAAI,CAAC,CAAC;AAAA,MAC9B;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAKO,SAAS,oBACd,SAAS,IACuC;AAChD,QAAM,SAAS,oBAAI,IAAY;AAC/B,QAAM,QAAQ,IAAI,MAAM,CAAC,GAAqB;AAAA,IAC5C,IAAI,SAAS,MAAS;AACpB,UAAI,OAAO,SAAS,SAAU,QAAO;AACrC,UAAI,SAAS,IAAK,QAAO,KAAK;AAC9B,UAAI,CAAC,OAAO,IAAI,IAAI,GAAG;AACrB,eAAO,IAAI,MAAM,KAAK,GAAG,MAAM,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC;AAAA,MACnD;AACA,aAAO,OAAO,IAAI,IAAI;AAAA,IACxB;AAAA,IACA,KAAK,MAAM;AAAA,IACX,SAAS,MAAM,MAAM,KAAK,OAAO,KAAK,CAAC;AAAA,IACvC,0BAA0B,OAAO;AAAA,MAC/B,YAAY;AAAA,MACZ,cAAc;AAAA,IAChB;AAAA,EACF,CAAC;AACD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAKA,SAAS,oBACP,QACA,WACA,OAC4B;AAE5B,QAAM,gBACJ,UAAU,WAAW,SAAU,OAAe,KAAK,KAAK;AAC1D,SAAO,IAAIC,kBAAiB,CAAC,aAAa;AACxC,UAAM,QAAQ,cAAc,UAAU;AAAA,MACpC,MAAM,CAAC,MAAa;AAClB,cAAM,SAAkC,CAAC;AACzC,mBAAW,OAAO,WAAW;AAC3B,cAAI,IAAI,WAAW,GAAG,EAAG;AACzB,gBAAM,OAAO,UAAU,GAAG;AAC1B,iBAAO,GAAG,IAAI,KAAK,MAAM,CAAC;AAAA,QAC5B;AAEA,iBAAS,KAAK,aAAa,MAAM,CAAmB;AAAA,MACtD;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AACD,QAAI,OAAO,UAAU,WAAY,QAAO;AACxC,QAAI,SAAS,OAAO,MAAM,gBAAgB;AACxC,aAAO,MAAM,MAAM,YAAY;AACjC,WAAO,SAAS,OAAO;AAAA,IAEvB;AAAA,EACF,CAAC;AACH;AAWA,IAAM,QAAN,MAAkD;AAAA,EACxC,aAA+C;AAAA,EAC/C,eAAoB;AAAA,EACpB,SAAiB,CAAC;AAAA,EAClB,SAAS;AAAA,EACA;AAAA,EACT,iBAAiB;AAAA,EAEzB,cAAc;AACZ,UAAM,EAAE,MAAM,IAAI,oBAAoB,IAAI;AAC1C,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAWA,OAAe,UAAmC;AAChD,QAAI,aAAa,KAAK;AACpB,WAAK,aAAa;AAClB,WAAK,eAAe;AACpB,WAAK,iBAAiB;AAAA,IACxB,WAAW,OAAO,aAAa,YAAY;AACzC,WAAK,eAAe;AACpB,WAAK,iBAAiB;AACtB,WAAK,aAAa,SAAS,KAAK,cAAc;AAAA,IAChD,OAAO;AACL,WAAK,aAAa;AAClB,WAAK,iBAAiB;AACtB,WAAK,eAAe;AAAA,IACtB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAA6D;AACjE,UAAM,SAAS,OAAO,KAAK,cAAc;AACzC,SAAK,OAAO,KAAK,GAAI,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM,CAAE;AAC/D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,GAAiB;AACrB,SAAK,SAAS;AACd,WAAO;AAAA,EACT;AAAA,EAEA,oBAAoB;AAClB,UAAM,eAAsB,oBAAI,IAAI;AACpC,UAAM,eAAe,IAAI,GAAG,KAAK,MAAM;AAEvC,UAAM,cAAc,aAAaA,kBAAiB,GAAG,YAAY,CAAC;AAClE,WAAO;AAAA,EACT;AAAA,EAEQ,gBAAiC;AACvC,QAAI,KAAK,OAAO,WAAW,GAAG;AAC5B,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,YAA6C,KAAK;AACtD,QAAI,KAAK,gBAAgB;AACvB,kBAAY;AAAA,QACV,GAAG,KAAK;AAAA,MACV;AAAA,IACF,WAAW,KAAK,cAAc;AAC5B,kBAAY;AAAA,QACV,QAAQ,KAAK;AAAA,MACf;AAAA,IACF,WAAW,CAAC,WAAW;AACrB,kBAAY;AAAA,QACV,GAAG,KAAK;AAAA,MACV;AAAA,IACF;AAEA,UAAM,eAAsB,oBAAI,IAAI;AACpC,UAAM,eAAe,IAAI,GAAG,KAAK,MAAM;AAEvC,UAAM,cAAc,aAAaA,kBAAiB,GAAG,YAAY,CAAC;AAClE,UAAM,UAAU,oBAAoB,aAAa,WAAW,KAAK,MAAM;AAEvE,UAAM,cAAc,KAAK;AACzB,WAAO,IAAIA,kBAAiB,CAAC,aAAa;AACxC,YAAM,MAAM,QAAQ,UAAU;AAAA,QAC5B,MAAM,CAAC,WAAW;AAChB,cAAI,aAAa;AACf,qBAAS,KAAK,OAAO,MAAM;AAAA,UAC7B,OAAO;AACL,qBAAS,KAAK,MAAM;AAAA,UACtB;AAAA,QACF;AAAA,QACA,OAAO,CAAC,QAAe,SAAS,MAAM,GAAG;AAAA,QACzC,UAAU,MAAM,SAAS,SAAS;AAAA,MACpC,CAAC;AAED,aAAO,MAAM,IAAI,YAAY;AAAA,IAC/B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,OAAO,aAAa,IAA2C;AACrE,UAAM,aAAa,KAAK,cAAc;AACtC,UAAM,QAAiC,CAAC;AACxC,QAAI,YAAY;AAChB,QAAI,QAAa;AACjB,QAAI,cAAmC;AAGvC,UAAM,cAAc,MAClB,IAAI,QAAc,CAAC,YAAY;AAC7B,oBAAc;AAAA,IAChB,CAAC;AAEH,UAAM,cAAc,WAAW,UAAU;AAAA,MACvC,MAAM,CAAC,WAAW;AAChB,cAAM,KAAK,MAAM;AACjB,YAAI,aAAa;AACf,sBAAY;AACZ,wBAAc;AAAA,QAChB;AAAA,MACF;AAAA,MACA,OAAO,CAAC,QAAQ;AACd,gBAAQ;AACR,oBAAY;AACZ,YAAI,aAAa;AACf,sBAAY;AACZ,wBAAc;AAAA,QAChB;AAAA,MACF;AAAA,MACA,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,aAAa;AACf,sBAAY;AACZ,wBAAc;AAAA,QAChB;AAAA,MACF;AAAA,IACF,CAAC;AAED,QAAI;AACF,aAAO,CAAC,aAAa,MAAM,SAAS,GAAG;AACrC,YAAI,MAAM,WAAW,GAAG;AACtB,gBAAM,YAAY;AAAA,QACpB;AACA,eAAO,MAAM,SAAS,GAAG;AACvB,gBAAM,OAAO,MAAM,MAAM;AACzB,cAAI,SAAS,QAAW;AACtB,kBAAM;AAAA,UACR;AAAA,QACF;AACA,YAAI,MAAO,OAAM;AAAA,MACnB;AAAA,IACF,UAAE;AACA,kBAAY,cAAc;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAA4C;AAChD,UAAM,aAAa,KAAK,cAAc;AACtC,UAAM,UAAmC,CAAC;AAE1C,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,iBAAW,UAAU;AAAA,QACnB,MAAM,CAAC,WAAW;AAChB,kBAAQ,KAAK,MAAM;AAAA,QACrB;AAAA,QACA,OAAO;AAAA,QACP,UAAU,MAAM,QAAQ,OAAO;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,eAAkD;AAChD,WAAO,KAAK,cAAc;AAAA,EAC5B;AACF;AAKO,SAAS,QAAyB;AACvC,SAAO,IAAI,MAAW;AACxB;;;AC1SA,SAAS,oBAAAC,yBAAwB;;;ACWjC,SAAS,oBAAAC,yBAAwB;AAY1B,SAAS,yBACd,WACM;AACN,SAAO,CAAC,WACN,IAAIC,kBAAwB,CAAC,aAAa;AACxC,UAAM,SAAkB,CAAC;AAEzB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,SAAS,OAAO,KAAK,IAAI;AAAA,MAChC,OAAO,CAAC,UAAU;AAChB,eAAO,SAAS;AAChB,iBAAS,QAAQ,KAAK;AAAA,MACxB;AAAA,MACA,UAAU,MAAM;AACd,kBAAU,QAAQ,QAAQ;AAC1B,eAAO,SAAS;AAChB,iBAAS,WAAW;AAAA,MACtB;AAAA,IACF,CAAC;AAED,WAAO,MAAM;AACX,mBAAa,cAAc;AAC3B,aAAO,SAAS;AAAA,IAClB;AAAA,EACF,CAAC;AACL;AAaO,SAAS,sBACd,QACA,UACA,QACA,MACA,YACM;AACN,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AAExC,UAAM,SAAS,oBAAI,IAGjB;AAEF,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX,cAAM,MAAM,KAAK,QAAQ,CAAC;AAC1B,cAAM,SAAS,KAAK,UAAU,GAAG;AAEjC,YAAI,CAAC,OAAO,IAAI,MAAM,GAAG;AACvB,iBAAO,IAAI,QAAQ;AAAA,YACjB;AAAA,YACA,QAAQ,CAAC;AAAA,YACT,eAAe,CAAC;AAAA,UAClB,CAAC;AAAA,QACH;AACA,cAAM,QAAQ,OAAO,IAAI,MAAM;AAC/B,YAAI,aAAa,MAAM;AACrB,gBAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,gBAAM,OAAO,KAAK,KAAK;AAAA,QACzB;AACA,cAAM,cAAc,KAAK,CAAC;AAAA,MAC5B;AAAA,MACA,OAAO,CAAC,UAAU;AAChB,eAAO,MAAM;AACb,iBAAS,QAAQ,KAAK;AAAA,MACxB;AAAA,MACA,UAAU,MAAM;AAEd,YAAI,MAAM;AAER,qBAAW,EAAE,KAAK,QAAQ,cAAc,KAAK,OAAO,OAAO,GAAG;AAC5D,kBAAM,aAAa,WAAW,QAAQ,aAAa;AACnD,kBAAM,QAAQ,oBAAI,IAAI;AACtB,kBAAM,SAAS,MAAM,QAAQ,KAAK,KAAK;AACvC,gBAAI,WAAW,KAAM;AACrB,kBAAM,SAAS,MAAM,QAAQ,YAAY,MAAM;AAC/C,gBAAI,WAAW,KAAM;AACrB,qBAAS,KAAK,MAAe;AAAA,UAC/B;AAAA,QACF,OAAO;AAEL,qBAAW,EAAE,KAAK,QAAQ,cAAc,KAAK,OAAO,OAAO,GAAG;AAC5D,kBAAM,aAAa,WAAW,QAAQ,aAAa;AACnD,uBAAW,SAAS,eAAe;AACjC,oBAAM,SAAS,MAAM,QAAQ,KAAK,KAAK;AACvC,kBAAI,WAAW,KAAM;AACrB,oBAAM,SAAS,MAAM,QAAQ,YAAY,MAAM;AAC/C,kBAAI,WAAW,KAAM;AACrB,uBAAS,KAAK,MAAe;AAAA,YAC/B;AAAA,UACF;AAAA,QACF;AACA,eAAO,MAAM;AACb,iBAAS,WAAW;AAAA,MACtB;AAAA,IACF,CAAC;AAED,WAAO,MAAM;AACX,mBAAa,cAAc;AAC3B,aAAO,MAAM;AAAA,IACf;AAAA,EACF,CAAC;AACL;;;ADvHO,SAAS,oBAAoB,GAAS,OAAa,OAAmB;AAC3E,SAAO,CAAC,WACN,IAAIC,kBAAwB,CAAC,aAAa;AACxC,UAAM,gBAAyB,CAAC;AAEhC,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM,cAAc,KAAK,CAAC;AAAA,MACjC,OAAO,CAAC,UAAU;AAEhB,sBAAc,SAAS;AACvB,iBAAS,QAAQ,KAAK;AAAA,MACxB;AAAA,MACA,UAAU,MAAM;AACd,YAAI,IAAI;AACR,mBAAW,KAAK,eAAe;AAC7B,gBAAM,MAAM,KAAK,GAAG,CAAC;AACrB,gBAAM,SAAS,KAAK,OAAO,CAAC;AAC5B,cAAI,KAAK,UAAU,GAAG,MAAM,KAAK,UAAU,MAAM,EAAG;AAAA,QACtD;AAEA;AAAA,UACE;AAAA,UACA;AAAA,QACF,EAAEA,kBAAiB,GAAG,oBAAI,IAAI,CAAC,CAAC,EAAE,UAAU;AAAA,UAC1C,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,UAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,UACrC,UAAU,MAAM;AAEd,0BAAc,SAAS;AACvB,qBAAS,WAAW;AAAA,UACtB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAGD,WAAO,MAAM;AACX,mBAAa,cAAc;AAC3B,oBAAc,SAAS;AAAA,IACzB;AAAA,EACF,CAAC;AACL;AAYO,SAAS,uBACd,GACA,OACA,OAAO,OACD;AACN,SAAO;AAAA,IACL;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA,CAAC,GAAG,kBAAkB,cAAc;AAAA;AAAA,EACtC;AACF;AAWO,SAAS,gBACd,GACA,WACM;AACN,SAAO;AAAA,IACL,CAAC,QAAiB,aAA2C;AAE3D,YAAM,QAAQ,OAAO,IAAI,CAAC,WAAW;AAAA,QACnC,OAAO,KAAK,GAAG,KAAK;AAAA,QACpB;AAAA,MACF,EAAE;AAGF,YAAM,WAAW,MAAM;AACrB,YAAI,OAAO,cAAc,YAAY;AACnC,iBAAO;AAAA,QACT;AACA,YAAI,OAAO,cAAc,UAAU;AACjC,cAAI,cAAc,QAAQ;AACxB,mBAAO;AAAA,UACT;AAAA,QACF;AACA,eAAO;AAAA,MACT,GAAG;AAEH,YAAM,aAAa,CAAC,GAAmB,MACrC,QAAQ,EAAE,OAAO,EAAE,KAAK;AAG1B,YAAM,KAAK,UAAU;AACrB,iBAAW,EAAE,MAAM,KAAK,OAAO;AAC7B,iBAAS,KAAK,KAAK;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,iBAAiB,CAAI,GAAM,MAAS;AACxC,MAAI,IAAI,EAAG,QAAO;AAClB,MAAI,IAAI,EAAG,QAAO;AAClB,SAAO;AACT;AAEA,IAAM,gBAAgB,CAAI,GAAM,MAAS;AACvC,MAAI,IAAI,EAAG,QAAO;AAClB,MAAI,IAAI,EAAG,QAAO;AAClB,SAAO;AACT;AAOO,SAAS,aAAa,GAAiB;AAC5C,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,QAAQ;AAEZ,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,SAAS;AACd,YAAI,QAAQ,GAAG;AACb,mBAAS,KAAK,IAAI;AAClB;AACA,cAAI,UAAU,GAAG;AACf,qBAAS,WAAW;AACpB,yBAAa,cAAc;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAED,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAaO,SAAS,yBACd,QACA,UACA,SACA,OAAO,OACD;AACN,SAAO;AAAA,IACL;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA,CAAC,QAAQ,MAAM,iBAAiB,MAAM;AAAA;AAAA,EACxC;AACF;AAEO,SAAS,kCACd,QACA,UACA,SACA,OAAO,OACD;AACN,SAAO;AAAA,IACL;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA,CAAC,QAAQ,MAAM,iBAAiB,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC,CAAC;AAAA;AAAA,EACtD;AACF;AAEO,SAAS,gBACd,UACA,SACA,OAAO,OACD;AACN,SAAO,yBAAyB,CAAC,QAAQ,aAAa;AACpD,UAAM,UAAU,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC;AACnD,QAAI;AACJ,QAAI,MAAM;AACR,UAAI,oBAAI,IAAI;AAAA,IACd,OAAO;AACL,UAAI,OAAO,CAAC,KAAK,oBAAI,IAAI;AAAA,IAC3B;AACA,UAAM,WAAW,MAAM,SAAS,SAAS,CAAC;AAC1C,QAAI,UAAU;AACZ,eAAS,KAAK,QAAQ;AAAA,IACxB;AAAA,EACF,CAAC;AACH;;;AE3MO,SAAS,oBACf,OACA,QAAQ,OACP;AACD,SAAO,CAAC,GAAS,MAAY,QAAoB;AAChD,WAAO;AAAA,MACN;AAAA,MACA,CAAC;AAAA,MACD,CAAC,IAAI;AAAA,MACL;AAAA,QACC;AAAA,QACA;AAAA;AAAA,QACA;AAAA;AAAA,QACA,CAAC,iBAAiB,MAAM;AACvB,gBAAM,SAAS,QAAQ,YAAY,eAAe,IAAI;AACtD,iBAAO,MAAM,MAAM;AAAA,QACpB;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAOO,IAAM,WAAW;AAAA,EACvB,CAAC,QAAQ,iBAAiB,GAAG;AAAA,EAC7B;AACD;AAOO,IAAM,oBAAoB;AAAA,EAChC,CAAC,QAAQ,iBAAiB,GAAG;AAAA,EAC7B;AACD;AAOO,IAAM,SAAS,oBAAoB,CAAC,QAAQ,IAAI,QAAQ,KAAK;AAE7D,IAAM,kBAAkB,oBAAoB,CAAC,QAAQ,IAAI,QAAQ,IAAI;AAWrE,SAAS,aACf,GACA,MACA,OACA,OACO;AACP,SAAO;AAAA,IACN;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA,CAAC,iBAAiB,kBAAkB;AAEnC,YAAM,cAAc,KAAK,OAAO,aAAa;AAE7C,aAAO,gBAAgB;AAAA,QACtB,CAAC,QAAQ,KAAK,UAAU,GAAG,MAAM,KAAK,UAAU,WAAW;AAAA,MAC5D,EAAE;AAAA,IACH;AAAA,EACD;AACD;AAqBO,SAAS,yBACf,OACA,QAAQ,OACP;AACD,SAAO,CACN,QACA,UACA,MACA,gBACU;AACV,UAAM,eAAe,QAClB,oCACA;AAEH,UAAM,YAAY,OAAO,eAAe,MAAM,QAAQ;AACtD,WAAO;AAAA,MACN,4BAA4B,SAAS;AAAA,MACrC,CAAC;AAAA,MACD,CAAC,IAAI;AAAA,MACL;AAAA,QAAM,CAAC,mBACN;AAAA,UACC,IAAI,MAAM,aAAa,QAAQ,UAAU,gBAAgB,IAAI,CAAC;AAAA,UAC9D,CAAC,UAAU,QAAQ,UAAU;AAC5B,uBAAW,YAAY,QAAQ;AAC9B,oBAAM,SAAS,KAAK,QAAgB,QAAQ;AAC5C,kBAAI,MAAM,MAAM,GAAG;AAClB;AAAA,cACD;AACA,oBAAM,cAAc,KAAK,gBAAgB,QAAQ;AACjD,kBAAI,MAAM,WAAW,GAAG;AACvB;AAAA,cACD;AACA,oBAAM,eAAe,MAAM,WAAoB;AAC/C,oBAAM,KAAK,MAAM,QAAQ,QAAQ,KAAK;AACtC,kBAAI,CAAC,GAAI;AACT,oBAAM,KAAK,MAAM,aAAa,cAAc,EAAE;AAC9C,kBAAI,CAAC,GAAI;AACT,uBAAS,KAAK,EAAE;AAAA,YACjB;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAEO,IAAM,oBAAoB;AAAA,EAChC,SAASC,mBAAkB,GAAG;AAC7B,WAAO;AAAA,EACR;AACD;AACO,IAAM,kBAAkB;AAAA,EAC9B,SAASC,iBAAgB,OAAc;AACtC,WAAO,iBAAiB,KAAK,EAAE;AAAA,EAChC;AACD;AAKA,SAAS,YAAe,OAAiB;AACxC,QAAM,OAAO,oBAAI,IAAY;AAC7B,QAAM,SAAc,CAAC;AACrB,aAAW,QAAQ,OAAO;AACzB,UAAM,IAAI,KAAK,UAAU,IAAI;AAC7B,QAAI,CAAC,KAAK,IAAI,CAAC,GAAG;AACjB,WAAK,IAAI,CAAC;AACV,aAAO,KAAK,IAAI;AAAA,IACjB;AAAA,EACD;AACA,SAAO;AACR;;;ACtMA,OAAO,UAAU;AACjB,SAAS,oBAAAC,mBAAkB,WAAAC,UAAS,QAAAC,aAAY;AAUzC,IAAM,UAAU,CAAC,GAAS,MAC/B;AAAA,EAAiB;AAAA,EAAW,CAAC,CAAC;AAAA,EAAG,CAAC;AAAA,EAAG,CAAC,WACpC,OAAO;AAAA,IACLC,SAAQ,CAAC,MAAa;AACpB,YAAM,OAAO,oBAAI,IAAI;AACrB,aAAO,EAAEC,kBAAiB,GAAG,CAAC,CAAC,EAAE;AAAA,QAC/BD,SAAQ,CAAC,OAAc;AACrB,gBAAM,MAAM,KAAK,GAAG,EAAE;AACtB,cAAI,MAAM,GAAG,GAAG;AACd,mBAAOC,kBAAiB,GAAG,EAAE;AAAA,UAC/B;AACA,gBAAM,MAAM,KAAK,UAAU,GAAG;AAC9B,cAAI,KAAK,IAAI,GAAG,EAAG,QAAOA,kBAAiB,MAAM;AACjD,eAAK,IAAI,GAAG;AACZ,iBAAOA,kBAAiB,GAAG,EAAE;AAAA,QAC/B,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEK,SAAS,IAAI,MAAkB;AACpC,SAAO;AAAA,IAAiB;AAAA,IAAO,CAAC;AAAA,IAAG,CAAC,IAAI;AAAA,IAAG,CAAC,WAC1C,OAAO;AAAA,MACLD,SAAQ,CAAC,MAAa;AACpB,eAAO,IAAIC,kBAAwB,CAAC,aAAa;AAC/C,cAAI,eAAe;AACnB,gBAAM,MAAM,KAAKA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YACjD,MAAM,CAAC,UAAU;AACf,kBAAI,CAAC,MAAM,IAAI,qBAAqB,GAAG;AACrC,+BAAe;AAAA,cACjB;AAAA,YACF;AAAA,YACA,OAAO,CAAC,QAAQ,SAAS,QAAQ,GAAG;AAAA,YACpC,UAAU,MAAM;AACd,kBAAI,CAAC,cAAc;AACjB,yBAAS,KAAK,CAAC;AAAA,cACjB;AACA,uBAAS,WAAW;AAAA,YACtB;AAAA,UACF,CAAC;AACD,iBAAO,MAAM,IAAI,YAAY;AAAA,QAC/B,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAEO,SAAS,QAAQ,MAAkB;AACxC,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC,IAAI;AAAA,IACL,CAAC,WACC,OAAO;AAAA,MACLD,SAAQ,CAAC,MAAa;AACpB,eAAO,IAAIC,kBAAwB,CAAC,aAAa;AAC/C,cAAI,eAAe;AACnB,gBAAM,MAAM,KAAKA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YACjD,MAAM,MAAM;AACV,6BAAe;AAAA,YACjB;AAAA,YACA,OAAO,CAAC,QAAQ,SAAS,QAAQ,GAAG;AAAA,YACpC,UAAU,MAAM;AACd,kBAAI,CAAC,cAAc;AACjB,yBAAS,KAAK,CAAC;AAAA,cACjB;AACA,uBAAS,WAAW;AAAA,YACtB;AAAA,UACF,CAAC;AACD,iBAAO,MAAM,IAAI,YAAY;AAAA,QAC/B,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACJ;AACF;AAEO,SAAS,QAAQ,MAAkB;AACxC,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC,IAAI;AAAA,IACL,CAAC,WACC,OAAO;AAAA,MACLD,SAAQ,CAAC,MAAa;AACpB,YAAI,QAAQ;AACZ,eAAO,IAAIC,kBAAwB,CAAC,aAAa;AAC/C,eAAKA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YACrC,MAAM,CAAC,UAAU;AACf,kBAAI,mBAAmB;AACvB,yBAAW,CAAC,KAAK,KAAK,KAAK,OAAO;AAChC,oBAAI,CAAC,EAAE,IAAI,GAAG,GAAG;AACf,qCAAmB;AACnB;AAAA,gBACF;AAAA,cACF;AACA,kBAAI,CAAC,kBAAkB;AACrB,wBAAQ;AAAA,cACV;AAAA,YACF;AAAA,YACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,YACrC,UAAU,MAAM;AACd,kBAAI,CAAC,MAAO,UAAS,KAAK,CAAC;AAC3B,uBAAS,WAAW;AAAA,YACtB;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACJ;AACF;AAEO,SAAS,KAAK,GAAc,GAAoB;AACrD,SAAO;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,QAAQ,UAAU;AACjB,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,YAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,YAAM,YAAY,CAAC,MAAM,IAAI;AAE7B,UAAI,aAAa,WAAW;AAE1B,eAAO,SAAS,OAAO,QAAQ;AAAA,MACjC;AAEA,UAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,YAAI,KAAK,OAAO,KAAK,IAAI;AACvB,iBAAO;AAAA,QACT;AAAA,MACF;AAeA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAGO,SAAS,SAAS,GAAc,GAAoB;AACzD,SAAO;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,QAAQ,UAAU;AACjB,aAAO;AACP,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,YAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,YAAM,YAAY,CAAC,MAAM,IAAI;AAG7B,UAAI,aAAa,WAAW;AAC1B,eAAO,SAAS,OAAO,QAAQ;AAAA,MACjC;AAcA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAMO,SAAS,MAAM,MAAkB;AACtC,SAAO,CAAC,WAAoC,KAAK,MAAM,EAAE,KAAKC,MAAK,CAAC,CAAC;AACvE;AAMO,SAAS,WAAiB;AAC/B,SAAO,CAAC,WACN,OAAO;AAAA,IACLF;AAAA,MACE,CAAC,MACC,IAAIC,kBAAwB,CAAC,aAAa;AACxC,iBAAS,KAAK,CAAC;AACf,iBAAS,WAAW;AAAA,MACtB,CAAC;AAAA,IACL;AAAA,EACF;AACJ;AAMO,SAAS,QAAc;AAC5B,SAAO,CAAC,YAAqCA,kBAAiB,MAAM;AACtE;AAKO,SAAS,QAAQ,MAAkB;AACxC,SAAO,CAAC,WACN,OAAO;AAAA,IACLD;AAAA,MACE,CAAC,MACC,IAAIC,kBAAwB,CAAC,aAAa;AACxC,cAAM,SAAS,KAAK,MAAM,CAAC;AAC3B,iBAAS,SAAS,GAAkB;AAClC,cAAI,MAAM,CAAC,EAAG,QAAO;AACrB,cAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,mBAAO,EAAE,MAAM,QAAQ;AAAA,UACzB;AACA,cAAI,KAAK,OAAO,MAAM,YAAY,SAAS,GAAG;AAC5C,gBAAI,EAAE,QAAQ,QAAQ;AACpB,oBAAM,IAAI;AACV,qBAAO,SAAS,EAAE,IAAI,KAAK,SAAS,EAAE,IAAI;AAAA,YAC5C;AACA,gBAAI,EAAE,QAAQ,OAAO;AACnB,qBAAO;AAAA,YACT;AAAA,UACF;AACA,cAAI,KAAK,OAAO,MAAM,YAAY,EAAE,SAAS,IAAI;AAC/C,mBAAO,OAAO,OAAO,CAAC,EAAE,MAAM,QAAQ;AAAA,UACxC;AACA,iBAAO;AAAA,QACT;AACA,YAAI,SAAS,MAAM,GAAG;AACpB,mBAAS,KAAK,CAAC;AAAA,QACjB;AACA,iBAAS,WAAW;AAAA,MACtB,CAAC;AAAA,IACL;AAAA,EACF;AACJ;AAKO,SAAS,WAAW,MAAkB;AAC3C,SAAO,IAAI,QAAQ,IAAI,CAAC;AAC1B;AAKO,SAAS,SAAS,KAAa,WAAW,OAAa;AAC5D,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC;AAAA,IACD,CAAC,WACC,IAAIA,kBAAwB,CAAC,aAAa;AACxC,YAAM,MAAM,OAAO,UAAU;AAAA,QAC3B,MAAM,CAAC,MAAM;AACX,gBAAM,KAAK,WACP,OAAO;AAAA,YACL,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,OAAO,MAAM,QAAQ;AAAA,UAC3D,IACA;AACJ,kBAAQ;AAAA,YACN,cAAc,GAAG;AAAA,YACjB,KAAK,QAAQ,IAAI;AAAA,cACf,OAAO;AAAA,cACP,QAAQ;AAAA,YACV,CAAC;AAAA,UACH;AACA,mBAAS,KAAK,CAAC;AAAA,QACjB;AAAA,QACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,QACrC,UAAU,MAAM,SAAS,SAAS;AAAA,MACpC,CAAC;AACD,aAAO,MAAM,IAAI,YAAY;AAAA,IAC/B,CAAC;AAAA,EACL;AACF;AAEA,IAAI,cAAc;AACX,SAAS,UAAU,KAAa,QAAQ,KAAY;AACzD,QAAM,KAAK,EAAE;AACb,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC;AAAA,IACD,CAAC,WACC,IAAIA,kBAAwB,CAAC,aAAa;AACxC,UAAI,MAAM;AACV,YAAM,MAAM,OAAO,UAAU;AAAA,QAC3B,MAAM,CAAC,MAAM;AACX;AAGA,cAAI,eAAe;AACnB,cAAI,OAAO,GAAI,gBAAe;AAC9B,cAAI,OAAO,IAAK,gBAAe;AAC/B,cAAI,OAAO,IAAM,gBAAe;AAIhC,cAAI,MAAM,iBAAiB,GAAG;AAC5B,gBAAI,oBAAoB;AACxB,uBAAW,OAAO,EAAE,KAAK,GAAG;AAC1B,kBAAI,OAAO,QAAQ,SAAU;AAAA,YAC/B;AACA,kBAAM,iBAAiB,qBAAqB,CAAC,EAAE;AAC/C,oBAAQ,IAAI,QAAQ,IAAI,KAAK,KAAK;AAAA,cAChC;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AACA,mBAAS,KAAK,CAAC;AAAA,QACjB;AAAA,QACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,QACrC,UAAU,MAAM;AACd,kBAAQ,IAAI,iBAAiB,IAAI,KAAK,GAAG;AACzC,mBAAS,WAAW;AAAA,QACtB;AAAA,MACF,CAAC;AACD,aAAO,MAAM,IAAI,YAAY;AAAA,IAC/B,CAAC;AAAA,EACL;AACF;AAEO,SAAS,OAAa;AAC3B,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,UAAM,MAAM,OAAO,UAAU;AAAA,MAC3B,MAAM,CAAC,MAAM;AAAA,MAEb;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AACD,WAAO,MAAM,IAAI,YAAY;AAAA,EAC/B,CAAC;AACL;;;AC/VA,SAAS,oBAAAE,yBAAwB;AAG1B,SAAS,QAAQ,GAAS,MAAkB;AACjD,SAAO;AAAA,IACL;AAAA,IACA,CAAC;AAAA,IACD,CAAC;AAAA,IACD,CAAC,WACC,IAAIA,kBAAwB,CAAC,aAAa;AACxC,YAAM,gBAAuB,CAAC;AAC9B,UAAI,YAAY;AAChB,UAAI,SAAS;AACb,UAAI,gBAAgB;AAEpB,YAAM,gBAAgB,MAAM;AAC1B,YAAI,iBAAiB,WAAW,KAAK,CAAC,WAAW;AAC/C,mBAAS,WAAW;AAAA,QACtB;AAAA,MACF;AAEA,YAAM,WAAW,OAAO,UAAU;AAAA,QAChC,MAAM,CAAC,MAAM;AACX,cAAI,UAAW;AAEf,gBAAM,IAAI,KAAK,MAAM,CAAC;AAEtB,cAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,qBAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,kBAAI,UAAW;AACf,oBAAM,OAAO,EAAE,CAAC;AAChB,oBAAM,KAAK,MAAM,GAAG,MAAM,CAAC;AAC3B,kBAAI,GAAI,UAAS,KAAK,EAAE;AAAA,YAC1B;AAAA,UACF,WACE,KACA,OAAO,MAAM,YACb,SAAS,KACR,EAAU,QAAQ,QACnB;AACA,gBAAI,UAAW;AAEf,kBAAM,KAAK,MAAM,GAAI,EAAU,MAAM,CAAC;AACtC,gBAAI,GAAI,UAAS,KAAK,EAAE;AAExB;AAEA,kBAAM,MAAM;AAAA,cACV;AAAA,cACC,EAAU;AAAA,YACb,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,cAClC,MAAM,CAAC,WAAW;AAChB,oBAAI,CAAC,UAAW,UAAS,KAAK,MAAM;AAAA,cACtC;AAAA,cACA,OAAO,CAAC,QAAQ;AACd,oBAAI,CAAC,UAAW,UAAS,QAAQ,GAAG;AAAA,cACtC;AAAA,cACA,UAAU,MAAM;AACd;AACA,8BAAc;AAAA,cAChB;AAAA,YACF,CAAC;AACD,0BAAc,KAAK,GAAG;AAAA,UACxB;AAAA,QAEF;AAAA,QACA,OAAO,CAAC,QAAQ;AACd,cAAI,CAAC,UAAW,UAAS,QAAQ,GAAG;AAAA,QACtC;AAAA,QACA,UAAU,MAAM;AACd,0BAAgB;AAChB,wBAAc;AAAA,QAChB;AAAA,MACF,CAAC;AAED,oBAAc,KAAK,QAAQ;AAE3B,aAAO,MAAM;AACX,oBAAY;AACZ,sBAAc,QAAQ,CAAC,QAAQ;AAC7B,cAAI;AACF,iBAAK,cAAc;AAAA,UACrB,SAAS,GAAG;AAAA,UAEZ;AAAA,QACF,CAAC;AACD,sBAAc,SAAS;AAAA,MACzB;AAAA,IACF,CAAC;AAAA,EACL;AACF;AAKO,SAAS,OAAO,GAAS,IAAgB;AAC9C,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,cAAM,IAAI,KAAK,IAAI,CAAC;AACpB,YAAI,OAAO,CAAC,GAAG;AACb,gBAAM,WAAW;AACjB,gBAAM,KAAK,MAAM,GAAG,SAAS,MAAM,CAAC;AACpC,cAAI,GAAI,UAAS,KAAK,EAAE;AAAA,QAC1B;AACA,iBAAS,WAAW;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;AAKO,SAAS,MAAM,IAAU,MAAkB;AAChD,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,cAAM,IAAI,KAAK,IAAI,CAAC;AACpB,YAAI,OAAO,CAAC,GAAG;AACb,gBAAM,WAAW;AACjB,gBAAM,KAAK,MAAM,MAAM,SAAS,MAAM,CAAC;AACvC,cAAI,GAAI,UAAS,KAAK,EAAE;AAAA,QAC1B;AACA,iBAAS,WAAW;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;AAMO,SAAS,QAAQ,IAAU,IAAU,IAAgB;AAC1D,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,cAAM,QAAQ,KAAK,IAAI,CAAC;AACxB,YAAI,OAAO,KAAK,GAAG;AACjB,gBAAM,WAAW;AACjB,gBAAM,OAAO,SAAS;AACtB,gBAAM,OAAO,SAAS;AACtB,gBAAM,OAAO,KAAK;AAClB,gBAAM,KAAK;AAAA,YACT;AAAA,YACA;AAAA,cACE,KAAK;AAAA,cACL;AAAA,cACA,MAAM;AAAA,YACR;AAAA,YACA;AAAA,UACF;AACA,cAAI,IAAI;AACN;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,YACF,EAAEA,kBAAiB,GAAG,EAAE,CAAC,EAAE,UAAU;AAAA,cACnC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,cAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,cACrC,UAAU,MAAM,SAAS,SAAS;AAAA,YACpC,CAAC;AACD;AAAA,UACF;AAAA,QACF,WAAW,MAAM,KAAK,GAAG;AACvB,gBAAM,KAAK,MAAM,IAAI,IAAI,CAAC;AAC1B,cAAI,GAAI,UAAS,KAAK,EAAE;AAAA,QAC1B;AACA,iBAAS,WAAW;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;AAOO,SAAS,QAAQ,aAAmB,QAAoB;AAC7D,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,cAAM,cAAc,KAAK,aAAa,CAAC;AACvC,cAAM,eAAe,KAAK,QAAQ,CAAC;AACnC,YAAI;AACJ,YAAI,YAAY,WAAW,GAAG;AAC5B,yBAAe,iBAAiB,WAAW,EAAE;AAAA,QAC/C,WAAW,MAAM,QAAQ,WAAW,GAAG;AACrC,yBAAe,YAAY;AAAA,QAC7B,OAAO;AAEL;AAAA,QACF;AACA,cAAM,UAAU,MAAM,cAAc,cAAc,CAAC;AACnD,YAAI,YAAY,MAAM;AACpB,mBAAS,KAAK,OAAO;AAAA,QACvB;AAAA,MAEF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;AAEO,SAAS,SAAS,IAAU,IAAgB;AACjD,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,cAAM,QAAQ,KAAK,IAAI,CAAC;AACxB,YAAI,MAAM,KAAK,GAAG;AAChB;AAAA,YACE;AAAA,YACA;AAAA,UACF,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YAClC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,YAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,YACrC,UAAU,MAAM,SAAS,SAAS;AAAA,UACpC,CAAC;AACD;AAAA,QACF;AACA,YAAI,OAAO,KAAK,GAAG;AACjB,gBAAM,MAAM,iBAAiB,KAAkB;AAC/C,cAAI,iBAAiB;AACrB,qBAAW,QAAQ,KAAK;AACtB,kBAAM,OAAO,KAAK;AAClB;AAAA,cACE,aAAa,OAAO,MAAM,IAAI;AAAA,cAC9B,SAAS,MAAM,KAAK,CAAC;AAAA,cACrB,GAAG,IAAI,KAAK,MAAM,KAAK,CAAC,CAAC;AAAA,YAC3B,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,cAClC,MAAM,CAAC,OAAO;AACZ,sBAAM,SAAS,KAAK,IAAI,EAAE;AAC1B,oBAAI,OAAO,MAAM,GAAG;AAClB;AAAA,oBACE,OAAO;AAAA,oBACP,KAAK,KAAK,GAAG,EAAE;AAAA,kBACjB,EAAEA,kBAAiB,GAAG,EAAE,CAAC,EAAE,UAAU;AAAA,oBACnC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,oBAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,kBACvC,CAAC;AAAA,gBACH;AAAA,cACF;AAAA,cACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,cACrC,UAAU,MAAM;AACd;AACA,oBAAI,mBAAmB,IAAI,QAAQ;AACjC,2BAAS,WAAW;AAAA,gBACtB;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AACA,cAAI,IAAI,WAAW,GAAG;AACpB,qBAAS,WAAW;AAAA,UACtB;AAAA,QACF,OAAO;AACL,mBAAS,WAAW;AAAA,QACtB;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;AAEO,SAAS,KACd,KACA,IACA,IACM;AACN,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX;AACA,cAAM,QAAQ,KAAK,IAAI,CAAC;AACxB,YAAI,MAAM,KAAK,GAAG;AAChB;AAAA,YACE;AAAA,YACA;AAAA,UACF,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YAClC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,YAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,YACrC,UAAU,MAAM;AACd;AACA,kBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,YACrD;AAAA,UACF,CAAC;AACD;AAAA,QACF;AACA,YAAI,OAAO,KAAK,GAAG;AACjB,gBAAM,QAAQ,MAAM;AACpB,gBAAM,QAAQ,MAAM;AACpB,gBAAM,QAAQ,KAAK;AACnB,gBAAM,QAAQ,KAAK;AACnB;AAAA,YACE,GAAG,IAAI,KAAK,OAAO,KAAK,CAAC;AAAA,YACzB,IAAI,OAAO,KAAK;AAAA,YAChB,KAAK,KAAK,OAAO,KAAK;AAAA,UACxB,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,YAClC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,YAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,YACrC,UAAU,MAAM;AACd;AACA,kBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,YACrD;AAAA,UACF,CAAC;AAAA,QACH,OAAO;AACL;AACA,cAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,QACrD;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAEO,SAAS,aAAa,IAAU,GAAS,IAAgB;AAC9D,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX;AACA,cAAM,QAAQ,KAAK,IAAI,CAAC;AACxB,YAAI,MAAM,KAAK,GAAG;AAChB;AACA,cAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AACnD;AAAA,QACF;AACA,YAAI,OAAO,KAAK,GAAG;AACjB,gBAAM,UAAU,KAAK,GAAG,CAAC;AACzB,gBAAM,aAAa,KAAK,MAAM,MAAM,CAAC;AACrC,cAAI,KAAK,UAAU,UAAU,MAAM,KAAK,UAAU,OAAO,GAAG;AAC1D;AAAA,cACE;AAAA,cACA,MAAM;AAAA,YACR,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,cAClC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,cAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,cACrC,UAAU,MAAM;AACd;AACA,oBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,cACrD;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AACL,kBAAM,OAAO,KAAK;AAClB;AAAA,cACE,GAAG,IAAI,KAAK,MAAM,MAAM,IAAI,CAAC;AAAA,cAC7B,aAAa,MAAM,MAAM,GAAG,IAAI;AAAA,YAClC,EAAEA,kBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,cAClC,MAAM,CAAC,MAAM,SAAS,KAAK,CAAC;AAAA,cAC5B,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,cACrC,UAAU,MAAM;AACd;AACA,oBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,cACrD;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,OAAO;AACL;AACA,cAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,QACrD;AAAA,MACF;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAKO,SAAS,aAAa,IAAgB;AAC3C,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,WAAO,UAAU;AAAA,MACf,MAAM,CAAC,MAAM;AACX,cAAM,MAAM,KAAK,IAAI,CAAC;AACtB,YAAI,QAAe,CAAC;AACpB,YAAI,OAAO,OAAO,QAAQ,YAAY,SAAS,KAAK;AAClD,cAAI,MAAY;AAChB,iBAAO,OAAO,GAAG,GAAG;AAClB,kBAAM,KAAK,IAAI,IAAI;AACnB,kBAAM,IAAI;AAAA,UACZ;AAAA,QACF,WAAW,MAAM,QAAQ,GAAG,GAAG;AAC7B,kBAAQ;AAAA,QACV;AACA,cAAM,OAAO,oBAAI,IAAI;AACrB,YAAI,cAAc;AAClB,mBAAW,KAAK,OAAO;AACrB,gBAAM,MAAM,KAAK,UAAU,CAAC;AAC5B,cAAI,KAAK,IAAI,GAAG,GAAG;AACjB,0BAAc;AACd;AAAA,UACF;AACA,eAAK,IAAI,GAAG;AAAA,QACd;AACA,YAAI,YAAa,UAAS,KAAK,CAAC;AAChC,iBAAS,WAAW;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM,SAAS,SAAS;AAAA,IACpC,CAAC;AAAA,EACH,CAAC;AACL;;;AC5bA,SAAS,oBAAAC,yBAAwB;AAS1B,SAAS,IAAI,GAAiB,GAAuB;AAC1D,SAAO;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,QAAqB,UAAiB;AACrC,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,YAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,YAAM,YAAY,CAAC,MAAM,IAAI;AAG7B,UAAI,aAAa,WAAW;AAC1B,eAAO,OAAO,OAAO,QAAQ;AAAA,MAC/B;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAMO,SAAS,IAAI,GAAiB,GAAuB;AAC1D,SAAO;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,QAAqB,UAAiB;AACrC,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,YAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,YAAM,YAAY,CAAC,MAAM,IAAI;AAG7B,UAAI,aAAa,WAAW;AAC1B,eAAO,OAAO,OAAO,QAAQ;AAAA,MAC/B;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAMO,SAAS,KAAK,GAAiB,GAAuB;AAC3D,SAAO;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,QAAqB,UAAiB;AACrC,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,YAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,YAAM,YAAY,CAAC,MAAM,IAAI;AAG7B,UAAI,aAAa,WAAW;AAC1B,eAAO,QAAQ,OAAO,QAAQ;AAAA,MAChC;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAMO,SAAS,KAAK,GAAiB,GAAuB;AAC3D,SAAO;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,QAAqB,UAAiB;AACrC,YAAM,CAAC,MAAM,IAAI,IAAI;AACrB,YAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,YAAM,YAAY,CAAC,MAAM,IAAI;AAG7B,UAAI,aAAa,WAAW;AAC1B,eAAO,QAAQ,OAAO,QAAQ;AAAA,MAChC;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAMO,SAAS,MAAM,GAAiB,GAAiB,GAAuB;AAC7E,SAAO,YAAY,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,QAAqB,UAAiB;AACnE,UAAM,CAAC,MAAM,MAAM,IAAI,IAAI;AAC3B,UAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,UAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,UAAM,YAAY,CAAC,MAAM,IAAI;AAG7B,QAAI,aAAa,aAAa,WAAW;AACvC,aAAO,OAAO,SAAS,OAAO,QAAQ;AAAA,IACxC,WAES,aAAa,WAAW;AAC/B,aAAO,MAAM,GAAG,OAAO,MAAM,KAAK;AAAA,IACpC,WAAW,aAAa,WAAW;AACjC,aAAO,MAAM,GAAG,OAAO,MAAM,KAAK;AAAA,IACpC,WAAW,aAAa,WAAW;AACjC,aAAO,MAAM,GAAG,OAAO,MAAM,KAAK;AAAA,IACpC;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AACO,IAAM,SAAS,CACpB,GACA,GACA,MACS,MAAM,GAAG,GAAG,CAAC;AAMjB,SAAS,MAAM,GAAiB,GAAiB,GAAuB;AAC7E,SAAO,YAAY,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,QAAqB,UAAiB;AACnE,UAAM,CAAC,MAAM,MAAM,IAAI,IAAI;AAC3B,UAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,UAAM,YAAY,CAAC,MAAM,IAAI;AAC7B,UAAM,YAAY,CAAC,MAAM,IAAI;AAE7B,QAAI,aAAa,aAAa,WAAW;AACvC,aAAO,OAAO,SAAS,OAAO,QAAQ;AAAA,IACxC;AACA,QAAI,aAAa,WAAW;AAC1B,aAAO,MAAM,GAAG,OAAO,MAAM,KAAK;AAAA,IACpC;AACA,QAAI,aAAa,SAAS,GAAG;AAC3B,UAAI,aAAa,SAAS,EAAG,QAAO;AACpC,UAAI,aAAa,SAAS,EAAG,QAAO;AAAA,IACtC;AACA,QAAI,aAAa,WAAW;AAC1B,aAAO,MAAM,GAAG,OAAO,MAAM,KAAK;AAAA,IACpC,WAAW,aAAa,WAAW;AACjC,aAAO,MAAM,GAAG,OAAO,MAAM,KAAK;AAAA,IACpC;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AACO,IAAM,YAAY,CACvB,GACA,GACA,MACS,MAAM,GAAG,GAAG,CAAC;AAQjB,SAAS,KAAK,UAAsB;AACzC,SAAO,CAAC,WACN,IAAIC,kBAAwB,CAAC,aAAa;AACxC,UAAM,gBAAyB,CAAC;AAGhC,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX,sBAAc,KAAK,CAAC;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,YAAI,cAAc,WAAW,GAAG;AAC9B,mBAAS,WAAW;AACpB;AAAA,QACF;AAGA,YAAI;AACJ,cAAM,mBAA4B,CAAC;AAEnC,mBAAW,KAAK,eAAe;AAC7B,gBAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,cAAI,OAAO,UAAU,UAAU;AAC7B,gBAAI,aAAa,UAAa,QAAQ,UAAU;AAC9C,yBAAW;AACX,+BAAiB,SAAS;AAC1B,+BAAiB,KAAK,CAAC;AAAA,YACzB,WAAW,UAAU,UAAU;AAC7B,+BAAiB,KAAK,CAAC;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AAGA,mBAAW,KAAK,kBAAkB;AAChC,mBAAS,KAAK,CAAC;AAAA,QACjB;AAEA,iBAAS,WAAW;AAAA,MACtB;AAAA,IACF,CAAC;AAED,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAQO,SAAS,KAAK,UAAsB;AACzC,SAAO,CAAC,WACN,IAAIA,kBAAwB,CAAC,aAAa;AACxC,UAAM,gBAAyB,CAAC;AAGhC,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX,sBAAc,KAAK,CAAC;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,YAAI,cAAc,WAAW,GAAG;AAC9B,mBAAS,WAAW;AACpB;AAAA,QACF;AAGA,YAAI;AACJ,cAAM,mBAA4B,CAAC;AAEnC,mBAAW,KAAK,eAAe;AAC7B,gBAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,cAAI,OAAO,UAAU,UAAU;AAC7B,gBAAI,aAAa,UAAa,QAAQ,UAAU;AAC9C,yBAAW;AACX,+BAAiB,SAAS;AAC1B,+BAAiB,KAAK,CAAC;AAAA,YACzB,WAAW,UAAU,UAAU;AAC7B,+BAAiB,KAAK,CAAC;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AAGA,mBAAW,KAAK,kBAAkB;AAChC,mBAAS,KAAK,CAAC;AAAA,QACjB;AAEA,iBAAS,WAAW;AAAA,MACtB;AAAA,IACF,CAAC;AAED,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;;;AC9QA,SAAS,oBAAAC,oBAAkB,WAAAC,gBAAe;AAqBnC,SAAS,QAAQ,UAAgB,SAAqC;AAC3E,SAAO,CAAC,WACN,OAAO;AAAA,IACLC;AAAA,MACE,CAAC,MACC,IAAIC,mBAAwB,CAAC,aAAa;AACxC,cAAM,aAAwB,KAAK,UAAU,CAAC;AAG9C,YAAI,OAAO,eAAe,YAAY,eAAe,MAAM;AACzD,mBAAS,WAAW;AACpB;AAAA,QACF;AAGA,cAAM,mBAAmB,CACvB,aACA,eACAC,kBACiB;AACjB,cAAI,MAAM,aAAa,GAAG;AAExB,mBAAO,MAAM,eAAe,aAAaA,aAAY;AAAA,UACvD,WAAW,MAAM,QAAQ,aAAa,GAAG;AAEvC,gBACE,CAAC,MAAM,QAAQ,WAAW,KAC1B,YAAY,WAAW,cAAc,QACrC;AACA,qBAAO;AAAA,YACT;AACA,gBAAI,cAAcA;AAClB,qBAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,oBAAM,YAAY;AAAA,gBAChB,YAAY,CAAC;AAAA,gBACb,cAAc,CAAC;AAAA,gBACf;AAAA,cACF;AACA,kBAAI,cAAc,KAAM,QAAO;AAC/B,4BAAc;AAAA,YAChB;AACA,mBAAO;AAAA,UACT,WACE,OAAO,kBAAkB,YACzB,kBAAkB,MAClB;AAEA,gBAAI,OAAO,gBAAgB,YAAY,gBAAgB,MAAM;AAC3D,qBAAO;AAAA,YACT;AACA,gBAAI,cAAcA;AAClB,uBAAW,CAAC,KAAK,WAAW,KAAK,OAAO;AAAA,cACtC;AAAA,YACF,GAAG;AACD,oBAAM,oBAAoB,YAAY,GAAG;AACzC,oBAAM,YAAY;AAAA,gBAChB;AAAA,gBACA;AAAA,gBACA;AAAA,cACF;AACA,kBAAI,cAAc,KAAM,QAAO;AAC/B,4BAAc;AAAA,YAChB;AACA,mBAAO;AAAA,UACT,OAAO;AAEL,mBAAO,gBAAgB,gBAAgBA,gBAAe;AAAA,UACxD;AAAA,QACF;AAGA,YAAI,eAAe;AACnB,mBAAW,CAAC,KAAK,aAAa,KAAK,OAAO,QAAQ,OAAO,GAAG;AAC1D,gBAAM,QAAQ,WAAW,GAAG;AAC5B,gBAAM,YAAY;AAAA,YAChB;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,cAAI,cAAc,MAAM;AAEtB,qBAAS,WAAW;AACpB;AAAA,UACF;AACA,yBAAe;AAAA,QACjB;AAEA,iBAAS,KAAK,YAAY;AAC1B,iBAAS,WAAW;AAAA,MACtB,CAAC;AAAA,IACL;AAAA,EACF;AACJ;AAmBO,SAAS,YACd,UACA,SACM;AACN,SAAO,CAAC,WACN,OAAO;AAAA,IACLF;AAAA,MACE,CAAC,MACC,IAAIC,mBAAwB,CAAC,aAAa;AACxC,cAAM,aAAa,KAAK,UAAU,CAAC;AAGnC,YAAI,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC9B,mBAAS,WAAW;AACpB;AAAA,QACF;AAGA,mBAAW,WAAW,YAAY;AAChC,cAAI,OAAO,YAAY,YAAY,YAAY,MAAM;AAEnD,gBAAI,eAAe;AACnB,gBAAI,aAAa;AAEjB,uBAAW,CAAC,KAAK,SAAS,KAAK,OAAO,QAAQ,OAAO,GAAG;AACtD,oBAAM,QAAQ,QAAQ,GAAG;AACzB,oBAAM,UAAU,MAAM,WAAW,OAAO,YAAY;AACpD,kBAAI,YAAY,MAAM;AACpB,+BAAe;AAAA,cACjB,OAAO;AAEL,6BAAa;AACb;AAAA,cACF;AAAA,YACF;AAEA,gBAAI,YAAY;AACd,uBAAS,KAAK,YAAY;AAAA,YAC5B;AAAA,UACF;AAAA,QACF;AAEA,iBAAS,WAAW;AAAA,MACtB,CAAC;AAAA,IACL;AAAA,EACF;AACJ;;;AClLA,OAAOE,WAAU;AAEjB,IAAM,iBAAiB;AAAA,EACrB,SAAS;AAAA,EACT,YAAY,oBAAI,IAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqD5B,CAAC;AAAA;AAAA,EACD,WAAW,oBAAI,IAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoB3B,CAAC;AAAA;AACH;AAQO,IAAM,SAAN,MAAa;AAAA,EAClB,YAAoB,QAAsB;AAAtB;AAAA,EAAuB;AAAA,EAE3C,IACE,IACA,MACM;AACN,QAAI,CAAC,KAAK,OAAO,QAAS;AAC1B,QAAI,KAAK,OAAO,UAAU,IAAI,EAAE,EAAG;AACnC,QAAI,KAAK,OAAO,WAAW,OAAO,KAAK,CAAC,KAAK,OAAO,WAAW,IAAI,EAAE;AACnE;AAEF,QAAI;AACJ,QAAI,OAAO,SAAS,YAAY;AAC9B,YAAM,KAAK;AAAA,IACb,OAAO;AACL,YAAM;AAAA,IACR;AAEA,QAAI,OAAO,QAAQ,UAAU;AAC3B,cAAQ,IAAI,IAAI,EAAE,KAAK,GAAG,EAAE;AAAA,IAC9B,OAAO;AACL,cAAQ;AAAA,QACN,IAAI,EAAE;AAAA,QACNA,MAAK,QAAQ,KAAK;AAAA,UAChB,OAAO;AAAA,UACP,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EAEF;AACF;AAEA,IAAI,wBAAuC;AAEpC,SAAS,mBAA2B;AACzC,MAAI,CAAC,uBAAuB;AAC1B,4BAAwB,IAAI,OAAO,cAAc;AAAA,EACnD;AACA,SAAO;AACT;;;AC5HO,IAAM,aAAa;AAAA;AAAA;AAAA;AAAA,EAIzB,YACC,KACA,OACuB;AACvB,UAAM,SAA+B,CAAC;AACtC,UAAM,OAAO,OAAO,KAAK,GAAG;AAE5B,eAAW,OAAO,MAAM;AACvB,aAAO,GAAG,IAAI,KAAK,IAAI,GAAG,GAAG,KAAK;AAAA,IACnC;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,KAAa,OAAsB;AAC/C,WAAO,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,KAAK,CAAC;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,QAAuC;AACxD,UAAM,SAAS,OAAO,OAAO,MAAM;AACnC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,UAAI,MAAM,OAAO,CAAC,CAAC,EAAG,QAAO;AAAA,IAC9B;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,KAAsB;AACtC,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,UAAI,MAAM,IAAI,CAAC,CAAC,EAAG,QAAO;AAAA,IAC3B;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,QAA8B,OAAc;AAC3D,UAAM,aAAa,OAAO,KAAK,MAAM,EAAE,KAAK;AAC5C,UAAM,UAAgC,CAAC;AACvC,UAAM,eAA8B,CAAC;AAErC,eAAW,OAAO,YAAY;AAC7B,cAAQ,GAAG,IAAI,KAAK,OAAO,GAAG,GAAG,KAAK;AACtC,UAAI,CAAC,MAAM,QAAQ,GAAG,CAAC,GAAG;AACzB,qBAAa,KAAK;AAAA,UACjB,QAAQ;AAAA,UACR,OAAO,QAAQ,GAAG;AAAA,QACnB,CAAC;AAAA,MACF;AAAA,IACD;AAEA,WAAO;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA,EAEA,aAAgB,QAAiC;AAChD,WAAO,OAAO;AAAA,MACb,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,MAAM,KAAK,CAAC;AAAA,IAC9D;AAAA,EACD;AAAA,EAEA,SAAS,QAA8B;AACtC,WAAO,OAAO;AAAA,MACb,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,KAAK,KAAK,MAAM,MAAM,KAAK,CAAC;AAAA,IAC7D;AAAA,EACD;AACD;AAEO,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA,EAI/B,oBACC,YACA,SACA,KACA,OACe;AACf,QAAI,KAAY;AAChB,QAAI,aAAa;AAEjB,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,YAAM,MAAM,WAAW,CAAC;AACxB,UAAI,CAAC,MAAM,QAAQ,GAAG,CAAC,GAAG;AACzB,YAAI,QAAQ,GAAG,MAAM,IAAI,GAAG,GAAG;AAC9B,iBAAO;AAAA,QACR;AAAA,MACD,OAAO;AACN,YAAI,YAAY;AACf,eAAK,IAAI,IAAI,KAAK;AAClB,uBAAa;AAAA,QACd;AAEA,cAAM,UAAU,MAAM,QAAQ,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE;AAChD,YAAI,SAAS;AACZ,eAAK;AAAA,QACN,OAAO;AACN,iBAAO;AAAA,QACR;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,YACC,YACA,WACA,OACe;AACf,QAAI,WAAW,WAAW,UAAU,QAAQ;AAC3C,aAAO;AAAA,IACR;AAEA,WAAO,MAAM,YAAY,WAAW,KAAK;AAAA,EAC1C;AACD;AAEO,IAAM,eAAe;AAAA;AAAA;AAAA;AAAA,EAI3B,qBAAqB,MAAqC;AACzD,UAAM,SAAS,OAAO,OAAO,IAAI;AACjC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,UAAI,CAAE,OAAO,CAAC,EAAU,GAAI,QAAO;AAAA,IACpC;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB,UAAgC;AACpD,UAAM,aAAmC,CAAC;AAC1C,UAAM,YAAkC,CAAC;AACzC,UAAM,UAAU,OAAO,QAAQ,QAAQ;AAEvC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,YAAM,CAAC,KAAK,KAAK,IAAI,QAAQ,CAAC;AAC9B,UAAI,MAAM,KAAK,GAAG;AACjB,mBAAW,GAAG,IAAI;AAAA,MACnB,OAAO;AACN,kBAAU,GAAG,IAAI;AAAA,MAClB;AAAA,IACD;AAEA,WAAO;AAAA,MACN;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,YAAoB;AACtC,UAAM,cAAsB,CAAC;AAC7B,UAAM,aAAqB,CAAC;AAC5B,UAAM,YAAsB,CAAC;AAE7B,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC3C,YAAM,OAAO,WAAW,CAAC;AACzB,UAAI,MAAM,IAAI,GAAG;AAChB,oBAAY,KAAK,IAAI;AACrB,kBAAU,KAAK,CAAC;AAAA,MACjB,OAAO;AACN,mBAAW,KAAK,IAAI;AAAA,MACrB;AAAA,IACD;AAEA,WAAO;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,UAAgC;AACxD,UAAM,aAAqB,CAAC;AAC5B,UAAM,YAAoB,CAAC;AAC3B,UAAM,SAAS,OAAO,OAAO,QAAQ;AAErC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,MAAM,KAAK,GAAG;AACjB,mBAAW,KAAK,KAAK;AAAA,MACtB,OAAO;AACN,kBAAU,KAAK,KAAK;AAAA,MACrB;AAAA,IACD;AAEA,WAAO;AAAA,MACN;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACD;AAEO,IAAM,aAAa;AAAA;AAAA;AAAA;AAAA,EAIzB,UAAa,MAAc,MAAsB;AAChD,UAAM,SAAS,oBAAI,IAAO;AAC1B,SAAK,QAAQ,CAAC,SAAS;AACtB,UAAI,KAAK,IAAI,IAAI,GAAG;AACnB,eAAO,IAAI,IAAI;AAAA,MAChB;AAAA,IACD,CAAC;AACD,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,GAAiB;AAC5B,WACC,OAAO,MAAM,YACb,OAAO,MAAM,YACb,OAAO,MAAM,aACb,MAAM;AAAA,EAER;AAAA;AAAA;AAAA;AAAA,EAKA,cAAsC;AACrC,WAAO,oBAAI,IAAoB;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAc,OAA4B,KAAQ,WAAyB;AAC1E,QAAI,MAAM,MAAM,IAAI,GAAG;AACvB,QAAI,CAAC,KAAK;AACT,YAAM,oBAAI,IAAY;AACtB,YAAM,IAAI,KAAK,GAAG;AAAA,IACnB;AACA,QAAI,IAAI,SAAS;AAAA,EAClB;AACD;AAGO,IAAM,YAAY,WAAW;AAC7B,IAAM,cAAc,WAAW;;;ACjRtC,SAAS,oBAAAC,0BAAwB;AAO1B,SAAS,aAAa,WAAgB,SAAqB;AAChE,SAAO,CAAC,WACN,IAAIC,mBAAiB,CAAC,aAAa;AACjC,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX;AACA,cAAM,UAAkB,CAAC;AACzB,YAAI,iBAAiB;AACrB,gBAAQA,mBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,UACxC,MAAM,CAAC,UAAU;AACf,6BAAiB;AACjB,oBAAQ,KAAK,KAAK,WAAW,KAAK,CAAC;AAAA,UACrC;AAAA,UACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,UACrC,UAAU,MAAM;AACd,kBAAM,KAAK,IAAI,IAAI,CAAC;AACpB,eAAG,IAAI,UAAU,IAAI,OAAO;AAC5B,qBAAS,KAAK,EAAE;AAChB;AACA,gBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,UACrD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;AAKO,SAAS,kBACd,WACA,SACA,SACM;AACN,SAAO,CAAC,WACN,IAAIA,mBAAiB,CAAC,aAAa;AACjC,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,MAAM;AACX;AACA,cAAM,WAAW,oBAAI,IAAsB;AAC3C,gBAAQA,mBAAiB,GAAG,CAAC,CAAC,EAAE,UAAU;AAAA,UACxC,MAAM,CAAC,UAAU;AACf,kBAAM,WAAW,KAAK;AAAA,cACpB,UAAU,IAAI,CAAC,MAAM,KAAK,GAAG,KAAK,CAAC;AAAA,YACrC;AACA,gBAAI,YAAY,SAAS,IAAI,QAAQ;AACrC,gBAAI,CAAC,WAAW;AACd,0BAAY,QAAQ,IAAI,MAAM,CAAC,CAAC;AAChC,uBAAS,IAAI,UAAU,SAAS;AAAA,YAClC;AACA,qBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,oBAAM,QAAQ,KAAK,QAAQ,CAAC,GAAG,KAAK;AACpC,wBAAU,CAAC,EAAE,KAAK,KAAK;AAAA,YACzB;AAAA,UACF;AAAA,UACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,UACrC,UAAU,MAAM;AACd,gBAAI,SAAS,SAAS,GAAG;AACvB,oBAAM,KAAK,IAAI,IAAI,CAAC;AACpB,sBAAQ,QAAQ,CAAC,GAAG,MAAM,GAAG,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AAC1C,uBAAS,KAAK,EAAE;AAAA,YAClB,OAAO;AACL,yBAAW,CAAC,UAAU,SAAS,KAAK,SAAS,QAAQ,GAAG;AACtD,sBAAM,cAAc,KAAK,MAAM,QAAQ;AACvC,sBAAM,KAAK,IAAI,IAAI,CAAC;AACpB,0BAAU;AAAA,kBAAQ,CAAC,GAAG,UACpB,GAAG,IAAI,EAAE,IAAI,YAAY,KAAK,CAAC;AAAA,gBACjC;AACA,wBAAQ,QAAQ,CAAC,GAAG,UAAU,GAAG,IAAI,EAAE,IAAI,UAAU,KAAK,CAAC,CAAC;AAC5D,yBAAS,KAAK,EAAE;AAAA,cAClB;AAAA,YACF;AACA;AACA,gBAAI,aAAa,WAAW,EAAG,UAAS,WAAW;AAAA,UACrD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,OAAO,CAAC,MAAa,SAAS,MAAM,CAAC;AAAA,MACrC,UAAU,MAAM;AACd,oBAAY;AACZ,YAAI,WAAW,EAAG,UAAS,WAAW;AAAA,MACxC;AAAA,IACF,CAAC;AACD,WAAO,MAAM,aAAa,cAAc;AAAA,EAC1C,CAAC;AACL;","names":["SimpleObservable","SimpleObservable","SimpleObservable","branch","SimpleObservable","SimpleObservable","SimpleObservable","SimpleObservable","SimpleObservable","SimpleObservable","SimpleObservable","group_by_collecto","group_by_counto","SimpleObservable","flatMap","take","flatMap","SimpleObservable","take","SimpleObservable","SimpleObservable","SimpleObservable","SimpleObservable","flatMap","flatMap","SimpleObservable","currentSubst","util","SimpleObservable","SimpleObservable"]}