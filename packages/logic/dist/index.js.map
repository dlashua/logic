{"version":3,"sources":["../src/core/combinators.ts","../src/core/operators.ts","../src/core/observable.ts","../src/core/suspend-helper.ts","../src/core/subst-suspends.ts","../src/core/kernel.ts","../src/core/query.ts","../src/relations/aggregates-base.ts","../src/relations/aggregates.ts","../src/relations/aggregates-subqueries.ts","../src/relations/control.ts","../src/relations/lists.ts","../src/relations/numeric.ts","../src/relations/objects.ts","../src/shared/logger.ts","../src/shared/utils.ts","../src/util/procedural-helpers.ts"],"sourcesContent":["import jsonata from \"jsonata\";\nimport {\n  arrayToLogicList,\n  enrichGroupInput,\n  isVar,\n  lvar,\n  unify,\n  walk,\n} from \"./kernel.js\";\nimport { SimpleObservable } from \"./observable.js\";\nimport type {\n  Goal,\n  LiftableFunction,\n  LiftedArgs,\n  Observer,\n  Subscription,\n  Subst,\n  Term,\n  Var,\n} from \"./types.js\";\n\n/**\n * A goal that succeeds if two terms can be unified.\n */\n// export function eq(u: Term, v: Term): Goal {\n//   return liftGoal(function eq (s: Subst){\n//     return new SimpleObservable<Subst>((observer) => {\n//       try {\n//         const result = unify(u, v, s);\n//         if (result !== null) {\n//           observer.next(result);\n//         }\n//         observer.complete?.();\n//       } catch (error) {\n//         observer.error?.(error);\n//       }\n//     });\n//   });\n// }\nexport function eq(x: Term, y: Term): Goal {\n  return enrichGroupInput(\n    \"eq\",\n    [],\n    [],\n    (input$) =>\n      new SimpleObservable((observer) => {\n        const sub = input$.subscribe({\n          complete: observer.complete,\n          error: observer.error,\n          next: (subst) => {\n            const s2 = unify(x, y, subst);\n            if (s2) {\n              observer.next(s2);\n            }\n          },\n        });\n\n        return () => sub.unsubscribe();\n      }),\n  );\n}\n// export function eq(x: Term<any>, y: Term<any>): Goal {\n//   return suspendable([x, y], (values, subst) => {\n//     const [xVal, yVal] = values;\n//     const xGrounded = !isVar(xVal);\n//     const yGrounded = !isVar(yVal);\n\n//     // All grounded - check constraint\n//     if (xGrounded && yGrounded) {\n//       return (xVal === yVal) ? subst : null;\n//     }\n\n//     if(xGrounded) {\n//       const s2 = unify(xVal, yVal, subst);\n//       if(s2) return s2;\n//       return null;\n//     }\n\n//     if(yGrounded) {\n//       const s2 = unify(yVal, xVal, subst);\n//       if(s2) return s2;\n//       return null;\n//     }\n\n//     return CHECK_LATER; // Still not enough variables bound\n//   });\n// }\n\n/**\n * Introduces new (fresh) logic variables into a sub-goal.\n */\nexport function fresh(f: (...vars: Var[]) => Goal): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const freshVars = Array.from({ length: f.length }, () => lvar());\n          const subGoal = f(...freshVars);\n          subGoal(SimpleObservable.of(s)).subscribe({\n            next: observer.next,\n            error: observer.error,\n            complete: () => {\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            },\n          });\n        },\n        error: observer.error,\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * Logical disjunction (OR).\n */\nexport function disj(g1: Goal, g2: Goal): Goal {\n  return or(g1, g2);\n}\n\n/**\n * Logical conjunction (AND).\n */\nexport function conj(g1: Goal, g2: Goal): Goal {\n  return and(g1, g2);\n}\n\n/**\n * Helper for combining multiple goals with logical AND.\n * Creates a single group containing all goals for optimal SQL merging.\n */\n\nexport const and = (...goals: Goal[]): Goal => {\n  if (goals.length === 0) {\n    return (input$) => input$;\n  }\n  if (goals.length === 1) {\n    return goals[0];\n  }\n  return enrichGroupInput(\"and\", goals, [], (enrichedInput$) =>\n    goals.reduce((acc, goal) => goal(acc), enrichedInput$),\n  );\n};\n\n/**\n * Helper for combining multiple goals with logical OR.\n * Creates a single group containing all goals for optimal SQL merging.\n */\n\nexport const or = (...goals: Goal[]): Goal => {\n  if (goals.length === 0) {\n    return () => SimpleObservable.empty<Subst>();\n  }\n  if (goals.length === 1) {\n    return goals[0];\n  }\n\n  return enrichGroupInput(\n    \"or\",\n    [],\n    goals,\n    (input$: SimpleObservable<Subst>) => {\n      return new SimpleObservable<Subst>((observer) => {\n        // Use the improved share() method that replays values for logic programming\n        const sharedInput$ = input$.share();\n\n        let completedGoals = 0;\n        const subscriptions: Subscription[] = [];\n\n        const sharedObserver = {\n          next: observer.next,\n          error: observer.error,\n          complete: () => {\n            completedGoals++;\n            if (completedGoals === goals.length) {\n              observer.complete?.();\n            }\n          },\n        };\n        for (const goal of goals) {\n          const goalSubscription = goal(sharedInput$).subscribe(sharedObserver);\n          subscriptions.push(goalSubscription);\n        }\n\n        // for (const goal of goals) {\n        //   const goalSubscription = goal(sharedInput$).subscribe({\n        //     next: observer.next,\n        //     error: observer.error,\n        //     complete: () => {\n        //       completedGoals++;\n        //       if (completedGoals === goals.length) {\n        //         observer.complete?.();\n        //       }\n        //     }\n        //   });\n        //   subscriptions.push(goalSubscription);\n        // }\n\n        return () => {\n          subscriptions.forEach((sub) => sub.unsubscribe?.());\n        };\n      });\n    },\n  );\n};\n\n/**\n * Multi-clause disjunction (OR).\n */\nexport function conde(...clauses: Goal[][]): Goal {\n  const clauseGoals = clauses.map((clause) => and(...clause));\n  return or(...clauseGoals);\n}\n\n/**\n * Lifts a pure JavaScript function into a Goal function.\n */\nexport function lift<U, T extends LiftableFunction<U>>(\n  fn: T,\n): LiftedArgs<T, U> {\n  return ((...args: [Term[], Term<U>]) => {\n    // Extract the 'out' parameter (last argument)\n    const out = args[args.length - 1];\n    const inputArgs = args.slice(0, -1);\n    return (input$: SimpleObservable<Subst>) =>\n      new SimpleObservable<Subst>((observer) => {\n        const subscription = input$.subscribe({\n          next: (s) => {\n            try {\n              // Walk all input arguments to resolve any variables\n              const resolvedArgs = inputArgs.map((arg) => walk(arg, s));\n              // Check if all arguments are ground (no variables)\n              const hasVariables = resolvedArgs.some((arg) => isVar(arg));\n              if (!hasVariables) {\n                // All arguments are ground, we can call the function\n                const result = fn(...resolvedArgs);\n                // Unify the result with the output parameter\n                const unified = unify(out, result, s);\n                if (unified !== null) {\n                  observer.next(unified);\n                }\n              }\n            } catch (error) {\n              observer.error?.(error);\n            }\n          },\n          error: observer.error,\n          complete: observer.complete,\n        });\n        return () => subscription.unsubscribe?.();\n      });\n  }) as LiftedArgs<T, U>;\n}\n\n/**\n * Either-or combinator: tries the first goal, and only if it produces no results,\n * tries the second goal. This is different from `or` which tries both goals.\n */\nexport function eitherOr(firstGoal: Goal, secondGoal: Goal): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          let hasResults = false;\n          const results: Subst[] = [];\n\n          firstGoal(SimpleObservable.of(s)).subscribe({\n            next: (s1) => {\n              hasResults = true;\n              results.push(s1);\n            },\n            complete: () => {\n              if (hasResults) {\n                // First goal succeeded, emit all its results\n                for (const result of results) {\n                  observer.next(result);\n                }\n              } else {\n                // First goal failed, try second goal\n                secondGoal(SimpleObservable.of(s)).subscribe({\n                  next: observer.next,\n                  error: observer.error,\n                  complete: () => {\n                    active--;\n                    if (completed && active === 0) observer.complete?.();\n                  },\n                });\n                return; // Skip the active-- below since secondGoal will handle it\n              }\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            },\n            error: observer.error,\n          });\n        },\n        error: observer.error,\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * Soft-cut if-then-else combinator.\n */\nexport function ifte(ifGoal: Goal, thenGoal: Goal, elseGoal: Goal): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          let succeeded = false;\n          const results: Subst[] = [];\n          ifGoal(SimpleObservable.of(s)).subscribe({\n            next: (s1) => {\n              succeeded = true;\n              results.push(s1);\n            },\n            complete: () => {\n              if (succeeded) {\n                let completed = 0;\n                for (const s1 of results) {\n                  thenGoal(SimpleObservable.of(s1)).subscribe({\n                    next: observer.next,\n                    error: observer.error,\n                    complete: () => {\n                      completed++;\n                      if (completed === results.length) {\n                        observer.complete?.();\n                      }\n                    },\n                  });\n                }\n                if (results.length === 0) {\n                  observer.complete?.();\n                }\n              } else {\n                elseGoal(SimpleObservable.of(s)).subscribe({\n                  next: observer.next,\n                  complete: observer.complete,\n                  error: observer.error,\n                });\n              }\n            },\n            error: observer.error,\n          });\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n\n/**\n * Succeeds exactly once with the given substitution (useful for cut-like behavior)\n */\nexport function once(goal: Goal): Goal {\n  return (input$) => goal(input$).take(1);\n}\n\n/**\n * Apply a goal with a timeout\n */\nexport function timeout(goal: Goal, timeoutMs: number): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let completed = false;\n      const timer = setTimeout(() => {\n        if (!completed) {\n          completed = true;\n          observer.error?.(new Error(`Goal timed out after ${timeoutMs}ms`));\n        }\n      }, timeoutMs);\n      goal(input$).subscribe({\n        next: (result) => {\n          if (!completed) {\n            observer.next(result);\n          }\n        },\n        complete: () => {\n          if (!completed) {\n            completed = true;\n            clearTimeout(timer);\n            observer.complete?.();\n          }\n        },\n        error: (error) => {\n          if (!completed) {\n            completed = true;\n            clearTimeout(timer);\n            observer.error?.(error);\n          }\n        },\n      });\n      return () => {\n        clearTimeout(timer);\n      };\n    });\n}\n\n/**\n * Run a goal and collect results with optional limits\n */\nexport function run(\n  goal: Goal,\n  maxResults?: number,\n  timeoutMs?: number,\n): Promise<{ results: Subst[]; completed: boolean; error?: string | Error }> {\n  return new Promise((resolve) => {\n    const results: Subst[] = [];\n    let completed = false;\n    let error: string | Error;\n    const effectiveGoal = timeoutMs ? timeout(goal, timeoutMs) : goal;\n    const limitedGoal = maxResults\n      ? (input$: SimpleObservable<Subst>) =>\n          effectiveGoal(input$).take(maxResults)\n      : effectiveGoal;\n    limitedGoal(SimpleObservable.of(new Map())).subscribe({\n      next: (result) => {\n        results.push(result);\n      },\n      complete: () => {\n        completed = true;\n        resolve({\n          results,\n          completed,\n          error,\n        });\n      },\n      error: (err) => {\n        error = err;\n        resolve({\n          results,\n          completed,\n          error,\n        });\n      },\n    });\n  });\n}\n\n/**\n * project: Declarative data transformation relation for logic engine.\n * Allows extracting or mapping fields from an object using a path string or mapping object.\n * Example:\n *   project($.input, \"species.name\", $.species_name)\n *   project($.input, { genus: \"genera[0].genus\" }, $.output)\n */\nfunction getByPath(obj: unknown, path: string): unknown {\n  if (!path) return obj;\n  const parts = path.split(\".\");\n  let current: unknown = obj;\n  for (const part of parts) {\n    if (!current) return undefined;\n    const match = part.match(/^(\\w+)\\[\\?\\(@\\.(.+?)==['\"](.+?)['\"]\\)\\]$/);\n    if (match) {\n      const [_, arrKey, filterKey, filterVal] = match;\n      const currentObj = current as Record<string, unknown>;\n      const array = currentObj[arrKey] as unknown[];\n      current = (array || []).find((x: unknown) => {\n        const item = x as Record<string, unknown>;\n        return item?.[filterKey] === filterVal;\n      });\n    } else if (part.endsWith(\"]\")) {\n      const arrMatch = part.match(/^(\\w+)\\[(\\d+)\\]$/);\n      if (arrMatch) {\n        const [_, arrKey, idx] = arrMatch;\n        const currentObj = current as Record<string, unknown>;\n        const array = currentObj[arrKey] as unknown[];\n        current = (array || [])[parseInt(idx)];\n      } else {\n        const currentObj = current as Record<string, unknown>;\n        current = currentObj[part];\n      }\n    } else {\n      const currentObj = current as Record<string, unknown>;\n      current = currentObj[part];\n    }\n  }\n  return current;\n}\n\n// project(input, \"field.path\", outputVar)\n// project(input, { out1: \"path1\", out2: \"path2\" }, outputObjVar)\nexport function project(\n  inputVar: Term,\n  pathOrMap: string | Record<string, string>,\n  outputVar: Term,\n): Goal {\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const subscription = input$.subscribe({\n        next: (s) => {\n          const input = walk(inputVar, s);\n          if (isVar(input)) return;\n          if (input === undefined) return;\n          if (typeof pathOrMap === \"string\") {\n            const value = getByPath(input, pathOrMap);\n            const unified = unify(outputVar, value, s);\n            if (unified !== null) observer.next(unified);\n          } else {\n            const outObj: Record<string, unknown> = {};\n            for (const key in pathOrMap) {\n              outObj[key] = getByPath(input, pathOrMap[key]);\n            }\n            const unified = unify(outputVar, outObj, s);\n            if (unified !== null) observer.next(unified);\n          }\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * projectJsonata: Declarative data transformation using JSONata expressions.\n *\n * @param inputVars - An object mapping keys to logic vars, or a single logic var.\n * @param jsonataExpr - The JSONata template string.\n * @param outputVars - An object mapping output keys to logic vars, or a single logic var.\n *\n * Example:\n *   projectJsonata({ x: $.some_var, y: $.some_other_var }, \"{ thing: x, thang: y }\", { thing: $.thing_here, thang: $.thang_here })\n *   projectJsonata($.input, \"$value + 1\", $.output)\n */\nexport function projectJsonata(\n  inputVars: Term | Record<string, Term>,\n  jsonataExpr: string,\n  outputVars: Term | Record<string, Term>,\n): Goal {\n  const expr = jsonata(jsonataExpr);\n  return (input$: SimpleObservable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: async (s) => {\n          active++;\n          // Prepare input for JSONata\n          let inputObj: unknown;\n          if (\n            typeof inputVars === \"object\" &&\n            inputVars !== null &&\n            !isVar(inputVars)\n          ) {\n            const objInput: Record<string, unknown> = {};\n            const inputVarsRecord = inputVars as Record<string, Term>;\n            for (const key in inputVarsRecord) {\n              objInput[key] = walk(inputVarsRecord[key], s);\n            }\n            inputObj = objInput;\n          } else {\n            inputObj = walk(inputVars, s);\n          }\n          // Evaluate JSONata\n          let result: unknown;\n          try {\n            result = await expr.evaluate(inputObj);\n          } catch (e) {\n            observer.error?.(e);\n            active--;\n            if (completed && active === 0) observer.complete?.();\n            return;\n          }\n          // Unify result to output logic vars\n          if (\n            typeof outputVars === \"object\" &&\n            outputVars !== null &&\n            !isVar(outputVars)\n          ) {\n            const outputVarsRecord = outputVars as Record<string, Term>;\n            if (\n              result &&\n              typeof result === \"object\" &&\n              \"then\" in result &&\n              typeof (result as { then: unknown }).then === \"function\"\n            ) {\n              (result as Promise<unknown>)\n                .then((resolved: unknown) => {\n                  let currentSubst = s;\n                  for (const key in outputVarsRecord) {\n                    const value =\n                      resolved &&\n                      typeof resolved === \"object\" &&\n                      resolved !== null\n                        ? (resolved as Record<string, unknown>)[key]\n                        : undefined;\n                    const unified = unify(\n                      outputVarsRecord[key],\n                      value,\n                      currentSubst,\n                    );\n                    if (unified !== null) {\n                      currentSubst = unified;\n                    } else {\n                      // If any unification fails, skip this result\n                      active--;\n                      if (completed && active === 0) observer.complete?.();\n                      return;\n                    }\n                  }\n                  observer.next(currentSubst);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                })\n                .catch((e: unknown) => {\n                  observer.error?.(e);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                });\n            } else {\n              const resolved = result;\n              let currentSubst = s;\n              for (const key in outputVarsRecord) {\n                const value =\n                  resolved && typeof resolved === \"object\" && resolved !== null\n                    ? (resolved as Record<string, unknown>)[key]\n                    : undefined;\n                const unified = unify(\n                  outputVarsRecord[key],\n                  value,\n                  currentSubst,\n                );\n                if (unified !== null) {\n                  currentSubst = unified;\n                } else {\n                  // If any unification fails, skip this result\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                  return;\n                }\n              }\n              observer.next(currentSubst);\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            }\n          } else {\n            if (\n              result &&\n              typeof result === \"object\" &&\n              \"then\" in result &&\n              typeof (result as { then: unknown }).then === \"function\"\n            ) {\n              (result as Promise<unknown>)\n                .then((resolved: unknown) => {\n                  const unified = unify(outputVars, resolved, s);\n                  if (unified !== null) observer.next(unified);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                })\n                .catch((e: unknown) => {\n                  observer.error?.(e);\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                });\n            } else {\n              const unified = unify(outputVars, result, s);\n              if (unified !== null) observer.next(unified);\n              active--;\n              if (completed && active === 0) observer.complete?.();\n            }\n          }\n        },\n        error: observer.error,\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * Subquery: Run a subgoal and bind its results to a variable in the main stream.\n * This is the universal bridge between goal-based and stream-based operations.\n *\n * @param goal - The subgoal to run\n * @param extractVar - Variable to extract from subgoal results\n * @param bindVar - Variable to bind the extracted results to in main stream\n * @param aggregator - How to combine multiple results (receives results and original substitution)\n *\n * Examples:\n * - Subquery(membero(x, [1,2,3]), x, $.items) // binds $.items to [1,2,3]\n * - Subquery(goal, x, $.count, (results, _) => results.length) // binds $.count to result count\n * - Subquery(goal, x, $.count, (results, s) => results.filter(r => r === walk(target, s)).length) // count matches\n */\nexport function Subquery(\n  goal: Goal,\n  extractVar: Term,\n  bindVar: Term,\n  aggregator: (results: unknown[], originalSubst: Subst) => unknown = (\n    results,\n    _,\n  ) => arrayToLogicList(results),\n): Goal {\n  return enrichGroupInput(\"Subquery\", [], [goal], (input$) =>\n    input$.flatMap((s: Subst) => {\n      const extracted: unknown[] = [];\n\n      return new SimpleObservable<Subst>((observer) => {\n        const subgoalSubscription = goal(SimpleObservable.of(s)).subscribe({\n          next: (subResult) => {\n            // Extract the value from each subgoal result\n            const value = walk(extractVar, subResult);\n            extracted.push(value);\n          },\n          error: (error) => {\n            extracted.length = 0;\n            observer.error?.(error);\n          },\n          complete: () => {\n            // Aggregate all extracted values and bind to the target variable\n            // Pass the original substitution so aggregator can walk variables\n            const aggregated = aggregator(extracted, s);\n            const unified = unify(bindVar, aggregated, s);\n            if (unified !== null) {\n              observer.next(unified);\n            }\n            extracted.length = 0;\n            observer.complete?.();\n          },\n        });\n\n        return () => {\n          subgoalSubscription.unsubscribe?.();\n          extracted.length = 0;\n        };\n      });\n    }),\n  );\n}\n\nexport function branch(\n  goal: Goal,\n  aggregator: (\n    observer: Observer<Subst>,\n    substs: Subst[],\n    originalSubst: Subst,\n  ) => void,\n): Goal {\n  return enrichGroupInput(\n    \"branch\",\n    [],\n    [goal],\n    (input$) =>\n      new SimpleObservable<Subst>((observer) => {\n        const goalSubs: Subscription[] = [];\n        const inputSub = input$.subscribe({\n          error: observer.error,\n          complete: observer.complete,\n          next: (inputSubst) => {\n            const collectedSubsts: Subst[] = [];\n            const goalSub = goal(SimpleObservable.of(inputSubst)).subscribe({\n              error: observer.error,\n              complete: () => {\n                aggregator(observer, collectedSubsts, inputSubst);\n                // observer.complete?.();\n                collectedSubsts.length = 0;\n              },\n              next: (goalSubst) => {\n                collectedSubsts.push(goalSubst);\n              },\n            });\n            goalSubs.push(goalSub);\n          },\n        });\n\n        return () => {\n          goalSubs.forEach((goalSub) => goalSub.unsubscribe());\n          inputSub.unsubscribe();\n        };\n      }),\n  );\n}\n","import { SimpleObservable } from \"./observable.js\";\nimport type { Subscription, Observer } from \"./types.js\";\n\ntype ObserverOperator<A, B> = (\n  input$: SimpleObservable<A>,\n) => SimpleObservable<B>;\n\nexport function merge<A, B>(obsB: SimpleObservable<B>) {\n  return (obsA: SimpleObservable<A>) =>\n    new SimpleObservable<A | B>((observer) => {\n      let completed = 0;\n      const subscriptions = [\n        obsA.subscribe({\n          next: (r) => {\n            observer.next(r);\n          },\n          error: observer.error,\n          complete: () => {\n            completed++;\n            if (completed === 2) {\n              observer.complete?.();\n            }\n          },\n        }),\n        obsB.subscribe({\n          next: (r) => {\n            observer.next(r);\n          },\n          error: observer.error,\n          complete: () => {\n            completed++;\n            if (completed === 2) {\n              observer.complete?.();\n            }\n          },\n        }),\n      ];\n\n      return () => {\n        subscriptions.forEach((sub) => sub.unsubscribe());\n      };\n    });\n}\n\nexport function reduce<V>(\n  reducer: (accumulator: V, value: unknown) => V,\n  initialValue: unknown,\n): ObserverOperator<unknown, V> {\n  return (input$: SimpleObservable<unknown>): SimpleObservable<V> =>\n    new SimpleObservable<V>((observer) => {\n      let value: V = initialValue as V;\n      const sub = input$.subscribe({\n        next: (v: unknown) => {\n          value = reducer(value, v);\n        },\n        complete: () => {\n          observer.next(value);\n          observer.complete?.();\n        },\n        error: (e) => observer.error?.(e),\n      });\n\n      return () => sub.unsubscribe();\n    });\n}\n\nexport function map<T, U>(transform: (value: T) => U) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<U>((observer) => {\n      const subscription = input$.subscribe({\n        next: (value) => observer.next(transform(value)),\n        error: observer.error,\n        complete: observer.complete,\n      });\n      return () => subscription.unsubscribe();\n    });\n}\n\nexport function take<T>(count: number) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<T>((observer) => {\n      let taken = 0;\n      let upstreamUnsubscribed = false;\n      const subscription = input$.subscribe({\n        next: (value) => {\n          if (taken < count) {\n            observer.next(value);\n            taken++;\n            if (taken >= count) {\n              observer.complete?.();\n              setTimeout(() => {\n                subscription.unsubscribe();\n                upstreamUnsubscribed = true;\n              }, 0);\n            }\n          }\n        },\n        error: (err) => {\n          observer.error?.(err);\n        },\n        complete: () => {\n          observer.complete?.();\n        },\n      });\n      return () => {\n        if (!upstreamUnsubscribed) {\n          subscription.unsubscribe();\n        }\n        upstreamUnsubscribed = true;\n      };\n    });\n}\n\nexport function filter<T>(predicate: (value: T) => boolean) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<T>((observer) => {\n      const subscription = input$.subscribe({\n        next: (value) => {\n          if (predicate(value)) {\n            observer.next(value);\n          }\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n      return () => subscription.unsubscribe();\n    });\n}\n\nexport function flatMap<T, U>(transform: (value: T) => SimpleObservable<U>) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<U>((observer) => {\n      const subscriptions: Subscription[] = [];\n      let outerCompleted = false;\n      let activeInnerCount = 0;\n      let scheduledCompletion = false;\n      let fullyComplete = false;\n\n      const checkCompletion = () => {\n        if (outerCompleted && activeInnerCount === 0 && !scheduledCompletion) {\n          scheduledCompletion = true;\n          setTimeout(() => {\n            observer.complete?.();\n            fullyComplete = true;\n          }, 0);\n        }\n      };\n\n      const outerSubscription = input$.subscribe({\n        next: (value) => {\n          activeInnerCount++;\n          const innerObservable = transform(value);\n          const innerSubscription = innerObservable.subscribe({\n            next: observer.next,\n            error: observer.error,\n            complete: () => {\n              activeInnerCount--;\n              checkCompletion();\n            },\n          });\n          subscriptions.push(innerSubscription);\n        },\n        error: observer.error,\n        complete: () => {\n          outerCompleted = true;\n          // Always defer completion check to next microtask\n          setTimeout(() => checkCompletion(), 0);\n        },\n      });\n\n      subscriptions.push(outerSubscription);\n\n      return () => {\n        if (!fullyComplete) {\n          subscriptions.forEach((sub) => sub.unsubscribe());\n        }\n      };\n    });\n}\n\nexport function share<T>(bufferSize: number = Number.POSITIVE_INFINITY) {\n  let observers: Observer<T>[] = [];\n  let subscription: Subscription | null = null;\n  let refCount = 0;\n  let completed = false;\n  let lastError: any = null;\n  const buffer: T[] = [];\n\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<T>((observer) => {\n      // Replay all buffered values to new subscribers (logic programming needs deterministic behavior)\n      buffer.forEach((value) => observer.next?.(value));\n\n      if (completed) {\n        if (lastError !== null) {\n          observer.error?.(lastError);\n        } else {\n          observer.complete?.();\n        }\n        return;\n      }\n\n      observers.push(observer);\n      refCount++;\n\n      if (subscription === null) {\n        subscription = input$.subscribe({\n          next: (value) => {\n            buffer.push(value);\n            // Limit buffer size if specified (for memory optimization)\n            if (buffer.length > bufferSize) {\n              buffer.shift();\n            }\n            observers.slice().forEach((o) => o.next?.(value));\n          },\n          error: (err) => {\n            lastError = err;\n            completed = true;\n            observers.slice().forEach((o) => o.error?.(err));\n            observers = [];\n          },\n          complete: () => {\n            completed = true;\n            observers.slice().forEach((o) => o.complete?.());\n            observers = [];\n          },\n        });\n      }\n\n      return () => {\n        observers = observers.filter((o) => o !== observer);\n        refCount--;\n        if (refCount === 0 && subscription) {\n          subscription.unsubscribe();\n          subscription = null;\n          completed = false;\n          lastError = null;\n          buffer.length = 0; // Clean up buffer when no more subscribers\n        }\n      };\n    });\n}\n","// Simple Observable Implementation\n// -----------------------------------------------------------------------------\nimport {\n  merge as mergeOperator,\n  reduce as reduceOperator,\n  map as mapOperator,\n  take as takeOperator,\n  filter as filterOperator,\n  flatMap as flatMapOperator,\n  share as shareOperator,\n} from \"./operators.js\";\nimport type { Observable, Observer, Subscription } from \"./types.js\";\n\nconst isPromise = (v: any): v is Promise<any> =>\n  !!v && typeof v.then === \"function\";\n\n/**\n * Simple observable implementation focused on the needs of logic programming\n */\nexport class SimpleObservable<T> implements Observable<T> {\n  private producer: (\n    observer: Observer<T>,\n  ) => (() => void) | void | Promise<(() => void) | undefined>;\n\n  constructor(\n    producer: (\n      observer: Observer<T>,\n    ) => (() => void) | void | Promise<(() => void) | undefined>,\n  ) {\n    this.producer = producer;\n  }\n\n  subscribe(observer: Observer<T>): Subscription {\n    let closed = false;\n    let cleanup: (() => void) | undefined = () =>\n      console.log(\"I HAVE NO CLEANUP\");\n\n    const safeObserver = {\n      next: (value: T) => {\n        if (!closed && observer.next) {\n          if (isPromise(value)) {\n            value.then((v) => observer.next(v));\n          } else {\n            observer.next(value);\n          }\n        }\n      },\n      error: (error: Error) => {\n        if (!closed && observer.error) {\n          observer.error(error);\n          closed = true;\n        }\n      },\n      complete: () => {\n        if (!closed && observer.complete) {\n          observer.complete();\n          closed = true;\n        }\n      },\n    };\n\n    try {\n      const result = this.producer(safeObserver);\n\n      if (result && typeof result === \"object\" && \"then\" in result) {\n        result\n          .then((asyncCleanup) => {\n            cleanup = asyncCleanup;\n            if (unsubbed && cleanup) {\n              cleanup();\n            }\n          })\n          .catch((error) => {\n            safeObserver.error(\n              error instanceof Error ? error : new Error(String(error)),\n            );\n          });\n      } else {\n        cleanup = result as (() => void) | undefined;\n      }\n    } catch (error) {\n      if (!closed) {\n        safeObserver.error(\n          error instanceof Error ? error : new Error(String(error)),\n        );\n      }\n    }\n\n    let unsubbed = false;\n    return {\n      unsubscribe: () => {\n        if (!unsubbed) {\n          closed = true;\n          unsubbed = true;\n          if (cleanup) {\n            cleanup();\n          }\n        }\n      },\n      get closed() {\n        return closed;\n      },\n    };\n  }\n\n  // Static factory methods\n  static of<T>(...values: T[]): SimpleObservable<T> {\n    return new SimpleObservable<T>((observer) => {\n      for (const value of values) {\n        observer.next(value);\n      }\n      observer.complete?.();\n    });\n  }\n\n  static from<T>(values: T[]): SimpleObservable<T> {\n    return SimpleObservable.of(...values);\n  }\n\n  static empty<T>(): SimpleObservable<T> {\n    return new SimpleObservable<T>((observer) => {\n      observer.complete?.();\n    });\n  }\n\n  static fromAsyncGenerator<T>(generator: AsyncGenerator<T>): Observable<T> {\n    return new SimpleObservable<T>((observer) => {\n      let cancelled = false;\n\n      (async () => {\n        try {\n          for await (const value of generator) {\n            if (cancelled) break;\n            observer.next(value);\n          }\n          if (!cancelled) {\n            observer.complete?.();\n          }\n        } catch (error) {\n          if (!cancelled) {\n            observer.error?.(error);\n          }\n        }\n      })();\n\n      return () => {\n        cancelled = true;\n        generator.return?.(undefined as any);\n      };\n    });\n  }\n\n  static fromPromise<T>(promise: Promise<T>): Observable<T> {\n    return new SimpleObservable<T>((observer) => {\n      promise\n        .then((value) => {\n          observer.next(value);\n          observer.complete?.();\n        })\n        .catch((error) => observer.error?.(error));\n    });\n  }\n\n  // Operators\n\n  // Utility to collect all values into an array\n  toArray(): Promise<T[]> {\n    let sub: Subscription;\n    return new Promise<T[]>((resolve, reject) => {\n      const values: T[] = [];\n      sub = this.subscribe({\n        next: (value) => values.push(value),\n        error: reject,\n        complete: () => {\n          setTimeout(() => sub.unsubscribe(), 0);\n          resolve(values);\n        },\n      });\n    });\n  }\n\n  firstFrom(): Promise<T> {\n    let sub: Subscription;\n    let settled = false;\n    return new Promise<T>((resolve, reject) => {\n      sub = this.subscribe({\n        next: (value) => {\n          settled = true;\n          resolve(value);\n          setTimeout(() => sub.unsubscribe(), 0);\n        },\n        error: (e) => {\n          settled = true;\n          reject(e);\n        },\n        complete: () => {\n          if (!settled) {\n            reject(new Error(\"NO_VALUE_EMITTED\"));\n          }\n          setTimeout(() => sub.unsubscribe(), 0);\n        },\n      });\n    });\n  }\n\n  pipe<V>(\n    next_observable: (input$: SimpleObservable<T>) => SimpleObservable<V>,\n  ): SimpleObservable<V> {\n    return next_observable(this);\n  }\n\n  lastFrom(): Promise<T> {\n    let sub: Subscription;\n    let settled = false;\n    let valueRecevied = false;\n    let finalValue: T;\n    return new Promise<T>((resolve, reject) => {\n      sub = this.subscribe({\n        next: (value) => {\n          valueRecevied = true;\n          finalValue = value;\n        },\n        error: (e) => {\n          settled = true;\n          reject(e);\n        },\n        complete: () => {\n          if (!settled) {\n            if (valueRecevied) {\n              settled = true;\n              resolve(finalValue);\n            } else {\n              settled = true;\n              reject(new Error(\"NO_VALUE_EMITTED\"));\n            }\n          }\n          setTimeout(() => sub.unsubscribe(), 0);\n        },\n      });\n    });\n  }\n\n  // Fluent Operators\n  filter(predicate: (value: T) => boolean) {\n    return filterOperator(predicate)(this);\n  }\n\n  flatMap<U>(transform: (value: T) => SimpleObservable<U>) {\n    return flatMapOperator(transform)(this);\n  }\n\n  map<U>(transform: (value: T) => U) {\n    return mapOperator(transform)(this);\n  }\n\n  merge<R>(other: SimpleObservable<R>): SimpleObservable<T | R> {\n    return mergeOperator<T, R>(other)(this);\n  }\n\n  reduce<Q>(\n    reducer: (accumulator: Q, value: unknown) => Q,\n    initalValue: unknown,\n  ) {\n    return reduceOperator<Q>(reducer, initalValue)(this);\n  }\n\n  share(bufferSize: number = Number.POSITIVE_INFINITY) {\n    return shareOperator<T>(bufferSize)(this);\n  }\n\n  take(count: number) {\n    return takeOperator<T>(count)(this);\n  }\n}\n\nexport type ObsToObs = (input: SimpleObservable<any>) => SimpleObservable<any>;\n// Export the factory function for convenience\nexport const observable = <T>(\n  producer: (observer: Observer<T>) => (() => void) | undefined,\n) => new SimpleObservable(producer);\n","import { isVar, walk } from \"./kernel.js\";\nimport { SimpleObservable } from \"./observable.js\";\nimport { addSuspendToSubst } from \"./subst-suspends.js\";\nimport type { Goal, Subst, Term, Var } from \"./types.js\";\n\nexport const CHECK_LATER = Symbol.for(\"constraint-check-later\");\n\n/**\n * Generic constraint helper that handles suspension automatically\n */\n\nexport function makeSuspendHandler(\n  vars: Term[], \n  evaluator: (values: Term[], subst: Subst) => Subst | null | typeof CHECK_LATER, \n  minGrounded: number\n) {\n\treturn function handleSuspend(subst: Subst): Subst | null {\n\t\tconst values = vars.map((v) => walk(v, subst));\n\t\tconst groundedCount = values.filter((v) => !isVar(v)).length;\n\n\t\tif (groundedCount >= minGrounded) {\n\t\t\tconst result = evaluator(values, subst);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (result !== CHECK_LATER) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t// If we get here, result === CHECK_LATER, so fall through to suspension logic\n\t\t}\n\n\t\t// Only suspend if there are variables to watch\n\t\tconst watchedVars: string[] = vars\n\t\t\t.filter((v) => isVar(v))\n\t\t\t.map((v) => (v as Var).id); // Type-safe access to Var.id\n\t\tif (watchedVars.length > 0) {\n\t\t\treturn addSuspendToSubst(subst, handleSuspend, watchedVars);\n\t\t}\n\t\treturn null; // No variables to watch and CHECK_LATER returned, fail\n\t};\n}\n\nexport function suspendable<T extends Term[]>(\n\tvars: T,\n\tevaluator: (\n\t\tvalues: Term[],\n\t\tsubst: Subst,\n\t) => Subst | null | typeof CHECK_LATER,\n\tminGrounded = vars.length - 1,\n): Goal {\n\tconst handleSuspend = makeSuspendHandler(vars, evaluator, minGrounded);\n\t// console.log(\"VARS\", vars);\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\tconst sub = input$.subscribe({\n\t\t\t\tnext: (subst) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = handleSuspend(subst);\n\t\t\t\t\t\tif (result !== null) {\n\t\t\t\t\t\t\tobserver.next(result);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// console.log(\"SUSPEND DIED\");\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tobserver.error?.(error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: observer.complete,\n\t\t\t});\n\n\t\t\treturn () => sub.unsubscribe();\n\t\t});\n}\n\n","import { isVar, walk } from \"./kernel.js\";\nimport { CHECK_LATER } from \"./suspend-helper.js\";\nimport type { Subst } from \"./types.js\";\n\nexport const SUSPENDED_CONSTRAINTS = Symbol(\"suspended-constraints\");\n\nexport interface SuspendedConstraint {\n  id: string;\n  resumeFn: (subst: Subst) => Subst | null | typeof CHECK_LATER;\n  watchedVars: string[];\n}\n\nlet constraintCounter = 0;\nconst MAX_COUNTER = 1000000; // Reset after 1M constraints to prevent overflow\n\nexport function addSuspendToSubst(\n  subst: Subst,\n  resumeFn: (subst: Subst) => Subst | null | typeof CHECK_LATER,\n  watchedVars: string[],\n): Subst {\n  const suspends =\n    (subst.get(SUSPENDED_CONSTRAINTS) as SuspendedConstraint[]) || [];\n\n  // **Issue #3: Automatic pruning** - Check if constraint is already irrelevant\n  const stillRelevantVars = watchedVars.filter((varId) => {\n    const value = walk({ tag: \"var\", id: varId }, subst);\n    return isVar(value); // Only keep if variable is still unbound\n  });\n\n  // If no variables left to watch, don't add the constraint\n  if (stillRelevantVars.length === 0) {\n    return subst;\n  }\n\n  // Reset counter periodically to prevent unbounded growth\n  if (constraintCounter >= MAX_COUNTER) {\n    constraintCounter = 0;\n  }\n\n  const newSuspend: SuspendedConstraint = {\n    id: `constraint_${constraintCounter++}`,\n    resumeFn,\n    // watchedVars: stillRelevantVars // Use pruned list\n    watchedVars,\n  };\n\n  const newSubst = new Map(subst);\n  newSubst.set(SUSPENDED_CONSTRAINTS, [...suspends, newSuspend]);\n  return newSubst;\n}\n\nexport function getSuspendsFromSubst(subst: Subst): SuspendedConstraint[] {\n  return (subst.get(SUSPENDED_CONSTRAINTS) as SuspendedConstraint[]) || [];\n}\n\nexport function removeSuspendFromSubst(\n  subst: Subst,\n  suspendIds: string[],\n): Subst {\n  const suspends = getSuspendsFromSubst(subst);\n  const filteredSuspends = suspends.filter((c) => !suspendIds.includes(c.id));\n\n  const newSubst = new Map(subst);\n  if (filteredSuspends.length === 0) {\n    newSubst.delete(SUSPENDED_CONSTRAINTS);\n  } else {\n    newSubst.set(SUSPENDED_CONSTRAINTS, filteredSuspends);\n  }\n  return newSubst;\n}\n\nexport function wakeUpSuspends(\n  subst: Subst,\n  newlyBoundVars: string[],\n): Subst | null {\n  const suspends = getSuspendsFromSubst(subst);\n  if (suspends.length === 0) {\n    return subst;\n  }\n\n  // Partition suspends: those to wake up, and those to keep\n  const [toWake, toKeep] = suspends.reduce<\n    [SuspendedConstraint[], SuspendedConstraint[]]\n  >(\n    ([wake, keep], s) =>\n      s.watchedVars.some((v) => newlyBoundVars.includes(v))\n        ? [[...wake, s], keep]\n        : [wake, [...keep, s]],\n    [[], []],\n  );\n\n  // Remove only the suspends to be woken up\n  // let currentSubst = removeSuspendFromSubst(subst, toWake.map(x => x.id));\n  let currentSubst = subst;\n\n  for (const suspend of toWake) {\n    const result = suspend.resumeFn(currentSubst);\n    if (result === null) {\n      return null;\n    } else if (result === CHECK_LATER) {\n      // If still needs to be suspended, add back to suspends\n      toKeep.push(suspend);\n    } else {\n      toKeep.push(suspend);\n\n      currentSubst = result;\n    }\n  }\n\n  // currentSubst = removeSuspendFromSubst(subst, toWake.map(x => x.id));\n\n  // Restore any suspends that remain (not woken, or still suspended)\n  // if (toKeep.length > 0) {\n  //   const newSubst = new Map(currentSubst);\n  //   newSubst.set(SUSPENDED_CONSTRAINTS, toKeep);\n  //   return newSubst;\n  // }\n  return currentSubst;\n}\n","import { SimpleObservable } from \"./observable.js\";\nimport { SUSPENDED_CONSTRAINTS, wakeUpSuspends } from \"./subst-suspends.js\";\nimport type {\n\tConsNode,\n\tGoal,\n\tLogicList,\n\tNilNode,\n\tSubst,\n\tTerm,\n\tVar,\n} from \"./types.js\";\n\n// Well-known symbols for SQL query coordination\nexport const GOAL_GROUP_ID = Symbol(\"goal-group-id\");\nexport const GOAL_GROUP_PATH = Symbol(\"goal-group-path\");\nexport const GOAL_GROUP_CONJ_GOALS = Symbol(\"goal-group-conj-goals\"); // Goals in immediate group\nexport const GOAL_GROUP_ALL_GOALS = Symbol(\"goal-group-all-goals\"); // Goals across all related groups\n\nlet varCounter = 0;\nlet groupCounter = 0;\nexport function nextGroupId() {\n\treturn groupCounter++;\n}\n\n/**\n * Creates a new, unique logic variable.\n * @param name An optional prefix for debugging.\n */\nexport function lvar(name = \"\"): Var {\n\treturn {\n\t\ttag: \"var\",\n\t\tid: `${name}_${varCounter++}`,\n\t};\n}\n\n/**\n * Resets the global variable counter for deterministic tests.\n */\nexport function resetVarCounter(): void {\n\tvarCounter = 0;\n}\n\n/**\n * Recursively finds the ultimate binding of a term in a given substitution.\n * Optimized to use iteration for variable chains and avoid deep recursion.\n * @param u The term to resolve.\n * @param s The substitution map.\n */\nexport function walk(u: Term, s: Subst): Term {\n\tlet current = u;\n\n\tif (\n\t\t!isVar(current) &&\n\t\t!isCons(current) &&\n\t\t!Array.isArray(current) &&\n\t\ttypeof current !== \"object\"\n\t) {\n\t\treturn current; // Fast exit for primitives\n\t}\n\n\t// Fast path for variable chains - use iteration instead of recursion\n\twhile (isVar(current) && s.has(current.id)) {\n\t\tcurrent = s.get(current.id);\n\t}\n\n\t// If we ended up with a non-variable, check if it needs structural walking\n\tif (isCons(current)) {\n\t\t// Walk both parts of the cons cell\n\t\treturn cons(walk(current.head, s), walk(current.tail, s));\n\t}\n\n\tif (Array.isArray(current)) {\n\t\treturn current.map((x) => walk(x, s));\n\t}\n\n\tif (\n\t\tcurrent &&\n\t\ttypeof current === \"object\" &&\n\t\t!isVar(current) &&\n\t\t!isLogicList(current)\n\t) {\n\t\tconst out: Record<string, Term> = {};\n\t\tfor (const k in current) {\n\t\t\tif (Object.hasOwn(current, k)) {\n\t\t\t\tout[k] = walk((current as any)[k], s);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\treturn current;\n}\n\n/**\n * Extends a substitution by binding a variable to a value, with an occurs check.\n */\nexport function extendSubst(v: Var, val: Term, s: Subst): Subst | null {\n\tif (occursCheck(v, val, s)) {\n\t\treturn null; // Occurs check failed\n\t}\n\tconst s2 = new Map(s);\n\ts2.set(v.id, val);\n\treturn s2;\n}\n\n/**\n * Checks if a variable `v` occurs within a term `x` to prevent infinite loops.\n */\nfunction occursCheck(v: Var, x: Term, s: Subst): boolean {\n\tconst resolvedX = walk(x, s);\n\tif (isVar(resolvedX)) {\n\t\treturn v.id === resolvedX.id;\n\t}\n\tif (isCons(resolvedX)) {\n\t\treturn (\n\t\t\toccursCheck(v, resolvedX.head, s) || occursCheck(v, resolvedX.tail, s)\n\t\t);\n\t}\n\tif (Array.isArray(resolvedX)) {\n\t\tfor (const item of resolvedX) {\n\t\t\tif (occursCheck(v, item, s)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * The core unification algorithm. It attempts to make two terms structurally equivalent.\n * Optimized with fast paths for common cases.\n */\nexport function baseUnify(u: Term, v: Term, s: Subst | null): Subst | null {\n\tif (s === null) {\n\t\treturn null;\n\t}\n\n\t// Fast path: if both terms are identical primitives, no walking needed\n\tif (u === v) {\n\t\treturn s;\n\t}\n\n\tconst uWalked = walk(u, s);\n\tconst vWalked = walk(v, s);\n\n\t// Fast path: after walking, if they're still identical, succeed\n\tif (uWalked === vWalked) {\n\t\treturn s;\n\t}\n\n\tif (isVar(uWalked)) return extendSubst(uWalked, vWalked, s);\n\tif (isVar(vWalked)) return extendSubst(vWalked, uWalked, s);\n\n\t// Fast paths for primitive types\n\tif (typeof uWalked === \"number\" && typeof vWalked === \"number\") {\n\t\treturn uWalked === vWalked ? s : null;\n\t}\n\n\tif (typeof uWalked === \"string\" && typeof vWalked === \"string\") {\n\t\treturn uWalked === vWalked ? s : null;\n\t}\n\n\tif (isNil(uWalked) && isNil(vWalked)) return s;\n\tif (isCons(uWalked) && isCons(vWalked)) {\n\t\tconst s1 = unify(uWalked.head, vWalked.head, s);\n\t\tif (s1 === null) return null;\n\t\treturn unify(uWalked.tail, vWalked.tail, s1);\n\t}\n\n\tif (\n\t\tArray.isArray(uWalked) &&\n\t\tArray.isArray(vWalked) &&\n\t\tuWalked.length === vWalked.length\n\t) {\n\t\tlet currentSubst: Subst | null = s;\n\t\tfor (let i = 0; i < uWalked.length; i++) {\n\t\t\tcurrentSubst = unify(uWalked[i], vWalked[i], currentSubst);\n\t\t\tif (currentSubst === null) return null;\n\t\t}\n\t\treturn currentSubst;\n\t}\n\n\tif (JSON.stringify(uWalked) === JSON.stringify(vWalked)) {\n\t\treturn s;\n\t}\n\n\treturn null;\n}\n\n/**\n * Constraint-aware unify that wakes up suspended constraints when variables are bound\n */\n\nexport function unifyWithConstraints(\n\tu: Term,\n\tv: Term,\n\ts: Subst | null,\n): Subst | null {\n\tconst result = baseUnify(u, v, s);\n\n\tif (result !== null && s !== null) {\n\t\t// Fast path: if no constraints exist, skip constraint logic\n\t\tif (!result.has(SUSPENDED_CONSTRAINTS)) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// Check what new variables were bound\n\t\tconst newlyBoundVars: string[] = [];\n\t\tfor (const [key] of result) {\n\t\t\tif (!s.has(key) && typeof key === \"string\") {\n\t\t\t\tnewlyBoundVars.push(key);\n\t\t\t}\n\t\t}\n\n\t\t// Wake up constraints for newly bound variables (if any)\n\t\tif (newlyBoundVars.length > 0) {\n\t\t\treturn wakeUpSuspends(result, newlyBoundVars);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport const unify = unifyWithConstraints;\n// export const unify = baseUnify;\n\n/**\n * Type guard to check if a term is a logic variable.\n */\nexport function isVar(x: Term): x is Var {\n\treturn typeof x === \"object\" && x !== null && (x as Var).tag === \"var\";\n}\n\n/**\n * The canonical `nil` value, representing an empty logic list.\n */\nexport const nil: NilNode = { tag: \"nil\" };\n\n/**\n * Creates a `cons` cell (a node in a logic list).\n */\nexport function cons(head: Term, tail: Term): ConsNode {\n\treturn {\n\t\ttag: \"cons\",\n\t\thead,\n\t\ttail,\n\t};\n}\n\n/**\n * Converts a JavaScript array into a logic list.\n */\nexport function arrayToLogicList(arr: Term[]): LogicList {\n\treturn arr.reduceRight<LogicList>((tail, head) => cons(head, tail), nil);\n}\n\n/**\n * A convenience function to create a logic list from arguments.\n */\nexport function logicList<T = unknown>(...items: T[]): LogicList {\n\treturn arrayToLogicList(items);\n}\n\n/**\n * Type guard to check if a term is a `cons` cell.\n */\nexport function isCons(x: Term): x is ConsNode {\n\treturn typeof x === \"object\" && x !== null && (x as ConsNode).tag === \"cons\";\n}\n\n/**\n * Type guard to check if a term is `nil`.\n */\nexport function isNil(x: Term): x is NilNode {\n\treturn typeof x === \"object\" && x !== null && (x as NilNode).tag === \"nil\";\n}\n\n/**\n * Type guard to check if a term is a logic list.\n */\nexport function isLogicList(x: Term): x is LogicList {\n\treturn isCons(x) || isNil(x);\n}\n\n/**\n * Converts a logic list to a JavaScript array.\n */\nexport function logicListToArray(list: Term): Term[] {\n\tconst out = [];\n\tlet cur = list;\n\twhile (\n\t\tcur &&\n\t\ttypeof cur === \"object\" &&\n\t\t\"tag\" in cur &&\n\t\t(cur as any).tag === \"cons\"\n\t) {\n\t\tout.push((cur as any).head);\n\t\tcur = (cur as any).tail;\n\t}\n\treturn out;\n}\n\n// Helper: Convert a single-substitution goal to the new protocol\nexport function liftGoal(\n\tsingleGoal: (s: Subst) => SimpleObservable<Subst>,\n): Goal {\n\tconst groupType = singleGoal.name || \"liftGoal\";\n\treturn enrichGroupInput(\n\t\tgroupType,\n\t\t[],\n\t\t[],\n\t\t(input$) =>\n\t\t\tnew SimpleObservable((observer) => {\n\t\t\t\tconst subs = input$.subscribe({\n\t\t\t\t\tnext: (s) => {\n\t\t\t\t\t\tconst out$ = singleGoal(s);\n\t\t\t\t\t\tout$.subscribe({\n\t\t\t\t\t\t\tnext: (s2) => observer.next(s2),\n\t\t\t\t\t\t\terror: (e) => observer.error?.(e),\n\t\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\t\t/* pass */\n\t\t\t\t\t\t\t}, // wait for all\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\terror: (e) => observer.error?.(e),\n\t\t\t\t\tcomplete: () => observer.complete?.(),\n\t\t\t\t});\n\t\t\t\treturn () => subs.unsubscribe?.();\n\t\t\t}),\n\t);\n}\n\n// Helper: Chain goals (like flatMap for observables)\nexport function chainGoals(\n\tgoals: Goal[],\n\tinitial$: SimpleObservable<Subst>,\n): SimpleObservable<Subst> {\n\treturn goals.reduce((input$, goal) => goal(input$), initial$);\n}\n\n/**\n * Creates an enriched substitution with group metadata\n */\nexport function createEnrichedSubst(\n\ts: Subst,\n\ttype: string,\n\tconjGoals: Goal[],\n\tdisjGoals: Goal[],\n\tbranch?: number,\n): Subst {\n\tconst groupId = nextGroupId();\n\tconst parentPath = (s.get(GOAL_GROUP_PATH) as any[]) || [];\n\tconst newPath = [\n\t\t...parentPath,\n\t\t{\n\t\t\ttype: Symbol(type),\n\t\t\tid: groupId,\n\t\t\t...(branch !== undefined ? { branch } : {}),\n\t\t},\n\t];\n\tconst parentOuterGoals = (s.get(GOAL_GROUP_ALL_GOALS) as Goal[]) || [];\n\t// Recursively collect all innerGoals from the combined goals array\n\tfunction collectAllInnerConjGoals(goals: Goal[]): Goal[] {\n\t\treturn goals.flatMap((goal) => {\n\t\t\tconst innerGoals = (goal as any)?.conjGoals ?? ([] as Goal[]);\n\t\t\tif (innerGoals && innerGoals.length > 0) {\n\t\t\t\treturn [...collectAllInnerConjGoals(innerGoals)];\n\t\t\t} else {\n\t\t\t\treturn [goal];\n\t\t\t}\n\t\t});\n\t}\n\tfunction collectAllInnerGoals(goals: Goal[]): Goal[] {\n\t\treturn goals.flatMap((goal) => {\n\t\t\tconst innerConjGoals = (goal as any)?.conjGoals ?? ([] as Goal[]);\n\t\t\tconst innerDisjGoals = (goal as any)?.disjGoals ?? ([] as Goal[]);\n\t\t\tconst innerGoals = [...new Set([...innerConjGoals, ...innerDisjGoals])];\n\t\t\tif (innerGoals && innerGoals.length > 0) {\n\t\t\t\treturn [...collectAllInnerGoals(innerGoals)];\n\t\t\t} else {\n\t\t\t\treturn [goal];\n\t\t\t}\n\t\t});\n\t}\n\n\tconst allGoals = [...conjGoals, ...disjGoals];\n\tconst conjInnerConj = collectAllInnerConjGoals(conjGoals);\n\tconst disjInnerAll = collectAllInnerGoals(allGoals);\n\n\tconst newSubst = new Map(s);\n\tnewSubst.set(GOAL_GROUP_ID, groupId);\n\tnewSubst.set(GOAL_GROUP_PATH, newPath);\n\tnewSubst.set(GOAL_GROUP_CONJ_GOALS, [\n\t\t...new Set([...conjGoals, ...conjInnerConj]),\n\t]);\n\tnewSubst.set(GOAL_GROUP_ALL_GOALS, [\n\t\t...new Set([\n\t\t\t...parentOuterGoals,\n\t\t\t...conjGoals,\n\t\t\t...disjGoals,\n\t\t\t...disjInnerAll,\n\t\t]),\n\t]);\n\treturn newSubst;\n}\n\n/**\n * Unified helper for enriching input with group metadata\n */\nexport function enrichGroupInput(\n\ttype: string,\n\tconjGoals: Goal[],\n\tdisjGoals: Goal[],\n\tfn: (enrichedInput$: SimpleObservable<Subst>) => SimpleObservable<Subst>,\n) {\n\tfunction newInput$(input$: SimpleObservable<Subst>) {\n\t\tconst enrichedInput$ = input$.map((s) =>\n\t\t\tcreateEnrichedSubst(s, type, conjGoals, disjGoals),\n\t\t);\n\t\treturn fn(enrichedInput$);\n\t}\n\t(newInput$ as any).conjGoals = conjGoals;\n\t(newInput$ as any).disjGoals = disjGoals;\n\tObject.defineProperty(newInput$, \"name\", { value: type });\n\treturn newInput$;\n}\n","import { and } from \"./combinators.js\";\nimport { isLogicList, isVar, logicListToArray, lvar, walk } from \"./kernel.js\";\nimport { SimpleObservable } from \"./observable.js\";\nimport type {\n\tGoal,\n\tObservable,\n\tRunResult,\n\tSubst,\n\tVar,\n} from \"./types.js\";\n\n/**\n * Recursively walks a result object, converting any logic lists into JS arrays.\n */\nfunction deepListWalk(val: any): any {\n\tif (isLogicList(val)) {\n\t\treturn logicListToArray(val).map(deepListWalk);\n\t} else if (Array.isArray(val)) {\n\t\treturn val.map(deepListWalk);\n\t} else if (val && typeof val === \"object\" && !isVar(val)) {\n\t\tconst out: any = {};\n\t\tfor (const k in val) {\n\t\t\tif (Object.hasOwn(val, k)) {\n\t\t\t\tout[k] = deepListWalk(val[k]);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\treturn val;\n}\n\n/**\n * Creates a proxy object that automatically creates logic variables on access.\n */\nexport function createLogicVarProxy<K extends string | symbol = string>(\n\tprefix = \"\",\n): { proxy: Record<K, Var>; varMap: Map<K, Var> } {\n\tconst varMap = new Map<K, Var>();\n\tconst proxy = new Proxy({} as Record<K, Var>, {\n\t\tget(_target, prop: K) {\n\t\t\tif (typeof prop !== \"string\") return undefined;\n\t\t\tif (prop === \"_\") return lvar();\n\t\t\tif (!varMap.has(prop)) {\n\t\t\t\tvarMap.set(prop, lvar(`${prefix}${String(prop)}`));\n\t\t\t}\n\t\t\treturn varMap.get(prop);\n\t\t},\n\t\thas: () => true,\n\t\townKeys: () => Array.from(varMap.keys()),\n\t\tgetOwnPropertyDescriptor: () => ({\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t}),\n\t});\n\treturn {\n\t\tproxy,\n\t\tvarMap,\n\t};\n}\n\n/**\n * Formats the raw substitution streams into user-friendly result objects.\n */\nfunction formatSubstitutions<Fmt>(\n\tsubsts: Observable<Subst>,\n\tformatter: Fmt,\n\tlimit: number,\n): Observable<RunResult<Fmt>> {\n\t// Use the built-in take operator which properly handles cleanup\n\tconst limitedSubsts =\n\t\tlimit === Infinity ? substs : (substs as any).take(limit);\n\treturn {\n\t\tsubscribe(observer) {\n\t\t\tconst unsub = limitedSubsts.subscribe({\n\t\t\t\tnext: (s: Subst) => {\n\t\t\t\t\tconst result: Partial<RunResult<Fmt>> = {};\n\t\t\t\t\tfor (const key in formatter) {\n\t\t\t\t\t\tif (key.startsWith(\"_\")) continue;\n\t\t\t\t\t\tconst term = formatter[key];\n\t\t\t\t\t\tresult[key] = walk(term, s);\n\t\t\t\t\t}\n\t\t\t\t\t// Convert logic lists to arrays before yielding the final result\n\t\t\t\t\tobserver.next(deepListWalk(result) as RunResult<Fmt>);\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: observer.complete,\n\t\t\t});\n\t\t\tif (typeof unsub === \"function\") return unsub;\n\t\t\tif (unsub && typeof unsub.unsubscribe === \"function\")\n\t\t\t\treturn () => unsub.unsubscribe();\n\t\t\treturn function noop() {\n\t\t\t\t/* pass */\n\t\t\t};\n\t\t},\n\t};\n}\n\ntype QueryOutput<Fmt, Sel> = Sel extends ($: Record<string, Var>) => Fmt\n\t? RunResult<Fmt>\n\t: Sel extends \"*\"\n\t\t? RunResult<Record<string, any>>\n\t\t: any;\n\n/**\n * A fluent interface for building and executing logic queries.\n */\nclass Query<Fmt = Record<string, Var>, Sel = \"*\"> {\n\tprivate _formatter: Fmt | Record<string, Var> | null = null;\n\tprivate _rawSelector: any = null;\n\tprivate _goals: Goal[] = [];\n\tprivate _limit = Infinity;\n\tprivate readonly _logicVarProxy: Record<string, Var>;\n\tprivate _selectAllVars = false;\n\n\tconstructor() {\n\t\tconst { proxy } = createLogicVarProxy(\"q_\");\n\t\tthis._logicVarProxy = proxy;\n\t\tthis._selectAllVars = true;\n\t}\n\n\t/**\n\t * Specifies the shape of the desired output.\n\t */\n\tselect<NewSel extends \"*\">(\n\t\tselector: NewSel,\n\t): Query<Record<string, Var>, NewSel>;\n\tselect<NewSel extends ($: Record<string, Var>) => any>(\n\t\tselector: NewSel,\n\t): Query<ReturnType<NewSel>, NewSel>;\n\tselect<NewSel>(selector: NewSel): Query<any, any> {\n\t\tif (selector === \"*\") {\n\t\t\tthis._formatter = null;\n\t\t\tthis._rawSelector = null;\n\t\t\tthis._selectAllVars = true;\n\t\t} else if (typeof selector === \"function\") {\n\t\t\tthis._rawSelector = null;\n\t\t\tthis._selectAllVars = false;\n\t\t\tthis._formatter = selector(this._logicVarProxy);\n\t\t} else {\n\t\t\tthis._formatter = null;\n\t\t\tthis._selectAllVars = false;\n\t\t\tthis._rawSelector = selector;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds constraints (goals) to the query.\n\t */\n\twhere(goalFn: (proxy: Record<string, Var>) => Goal | Goal[]): this {\n\t\tconst result = goalFn(this._logicVarProxy);\n\t\tthis._goals.push(...(Array.isArray(result) ? result : [result]));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the maximum number of results.\n\t */\n\tlimit(n: number): this {\n\t\tthis._limit = n;\n\t\treturn this;\n\t}\n\n\tgetSubstObservale() {\n\t\tconst initialSubst: Subst = new Map();\n\t\tconst combinedGoal = and(...this._goals);\n\t\t// Updated for streaming protocol: pass Observable<Subst> to the goal\n\t\tconst substStream = combinedGoal(SimpleObservable.of(initialSubst));\n\t\treturn substStream;\n\t}\n\n\tprivate getObservable(): Observable<any> {\n\t\tif (this._goals.length === 0) {\n\t\t\tthrow new Error(\"Query must have at least one .where() clause.\");\n\t\t}\n\n\t\tlet formatter: Fmt | Record<string, Var> | any = this._formatter;\n\t\tif (this._selectAllVars) {\n\t\t\tformatter = {\n\t\t\t\t...this._logicVarProxy,\n\t\t\t};\n\t\t} else if (this._rawSelector) {\n\t\t\tformatter = {\n\t\t\t\tresult: this._rawSelector,\n\t\t\t};\n\t\t} else if (!formatter) {\n\t\t\tformatter = {\n\t\t\t\t...this._logicVarProxy,\n\t\t\t};\n\t\t}\n\n\t\tconst initialSubst: Subst = new Map();\n\t\tconst combinedGoal = and(...this._goals);\n\t\t// Updated for streaming protocol: pass Observable<Subst> to the goal\n\t\tconst substStream = combinedGoal(SimpleObservable.of(initialSubst));\n\t\tconst results = formatSubstitutions(substStream, formatter, this._limit);\n\n\t\tconst rawSelector = this._rawSelector;\n\t\treturn {\n\t\t\tsubscribe(observer) {\n\t\t\t\treturn results.subscribe({\n\t\t\t\t\tnext: (result) => {\n\t\t\t\t\t\tif (rawSelector) {\n\t\t\t\t\t\t\tobserver.next(result.result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobserver.next(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\terror: observer.error,\n\t\t\t\t\tcomplete: observer.complete,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Makes the Query object itself an async iterable.\n\t * Properly propagates cancellation upstream when the consumer stops early.\n\t */\n\tasync *[Symbol.asyncIterator](): AsyncGenerator<QueryOutput<Fmt, Sel>> {\n\t\tconst observable = this.getObservable();\n\t\tconst queue: QueryOutput<Fmt, Sel>[] = [];\n\t\tlet completed = false;\n\t\tlet error: any = null;\n\t\tlet resolveNext: (() => void) | null = null;\n\t\t// let unsub: (() => void) | null = null;\n\n\t\tconst nextPromise = () =>\n\t\t\tnew Promise<void>((resolve) => {\n\t\t\t\tresolveNext = resolve;\n\t\t\t});\n\n\t\tconst subcription = observable.subscribe({\n\t\t\tnext: (result) => {\n\t\t\t\tqueue.push(result);\n\t\t\t\tif (resolveNext) {\n\t\t\t\t\tresolveNext();\n\t\t\t\t\tresolveNext = null;\n\t\t\t\t}\n\t\t\t},\n\t\t\terror: (err) => {\n\t\t\t\terror = err;\n\t\t\t\tcompleted = true;\n\t\t\t\tif (resolveNext) {\n\t\t\t\t\tresolveNext();\n\t\t\t\t\tresolveNext = null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tcomplete: () => {\n\t\t\t\tcompleted = true;\n\t\t\t\tif (resolveNext) {\n\t\t\t\t\tresolveNext();\n\t\t\t\t\tresolveNext = null;\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\ttry {\n\t\t\twhile (!completed || queue.length > 0) {\n\t\t\t\tif (queue.length === 0) {\n\t\t\t\t\tawait nextPromise();\n\t\t\t\t}\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst item = queue.shift();\n\t\t\t\t\tif (item !== undefined) {\n\t\t\t\t\t\tyield item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (error) throw error;\n\t\t\t}\n\t\t} finally {\n\t\t\tsubcription.unsubscribe?.();\n\t\t}\n\t}\n\n\t/**\n\t * Executes the query and returns all results as an array.\n\t */\n\tasync toArray(): Promise<QueryOutput<Fmt, Sel>[]> {\n\t\tconst observable = this.getObservable();\n\t\tconst results: QueryOutput<Fmt, Sel>[] = [];\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tobservable.subscribe({\n\t\t\t\tnext: (result) => {\n\t\t\t\t\tresults.push(result);\n\t\t\t\t},\n\t\t\t\terror: reject,\n\t\t\t\tcomplete: () => resolve(results),\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Returns the observable stream directly for reactive programming.\n\t */\n\ttoObservable(): Observable<QueryOutput<Fmt, Sel>> {\n\t\treturn this.getObservable();\n\t}\n}\n\n/**\n * The main entry point for creating a new logic query.\n */\nexport function query<Fmt>(): Query<Fmt> {\n\treturn new Query<Fmt>();\n}\n","/**\n * Base functions for building aggregation operations.\n *\n * These are foundational building blocks intended for creating new aggregation\n * relations, not for direct use by end users. They handle the low-level\n * subscription, buffering, grouping, and cleanup patterns that most\n * aggregation functions need.\n *\n * Functions ending in _base are infrastructure - use the public aggregation\n * functions in aggregates.ts instead.\n */\n\nimport type { Goal, Observable, Subst, Term } from \"../index.js\";\nimport { SimpleObservable, unify, walk } from \"../index.js\";\n\n/**\n * Helper: collect all substitutions from a stream, then process them all at once.\n * Handles subscription, buffering, cleanup, and error management.\n * This is a foundational building block for aggregation functions that need\n * to see all data before processing (like sorting).\n *\n * @param processor - Function that receives all buffered substitutions and observer to emit results\n */\nexport function collect_and_process_base(\n  processor: (buffer: Subst[], observer: { next: (s: Subst) => void }) => void,\n): Goal {\n  return (input$: Observable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      const buffer: Subst[] = [];\n\n      const subscription = input$.subscribe({\n        next: (item) => buffer.push(item),\n        error: (error) => {\n          buffer.length = 0;\n          observer.error?.(error);\n        },\n        complete: () => {\n          processor(buffer, observer);\n          buffer.length = 0;\n          observer.complete?.();\n        },\n      });\n\n      return () => {\n        subscription.unsubscribe?.();\n        buffer.length = 0;\n      };\n    });\n}\n\n/**\n * Generic stream-based grouping function - the foundation for all group_by_*_streamo functions.\n * Groups substitutions by keyVar and applies an aggregator function to each group.\n * This is a foundational building block for all grouping operations.\n *\n * @param keyVar - Variable to group by\n * @param valueVar - Variable to extract values from (null for count-only operations)\n * @param outVar - Variable to bind the aggregated result to\n * @param drop - If true, create fresh substitutions; if false, preserve original variables\n * @param aggregator - Function that takes (values, substitutions) and returns aggregated result\n */\nexport function group_by_streamo_base(\n  keyVar: Term,\n  valueVar: Term | null,\n  outVar: Term,\n  drop: boolean,\n  aggregator: (values: any[], substitutions: Subst[]) => any,\n): Goal {\n  return (input$: Observable<Subst>) =>\n    new SimpleObservable<Subst>((observer) => {\n      // Shared grouping logic - collect all substitutions by key\n      const groups = new Map<\n        string,\n        { key: any; values: any[]; substitutions: Subst[] }\n      >();\n\n      const subscription = input$.subscribe({\n        next: (s) => {\n          const key = walk(keyVar, s);\n          const keyStr = JSON.stringify(key);\n\n          if (!groups.has(keyStr)) {\n            groups.set(keyStr, {\n              key,\n              values: [],\n              substitutions: [],\n            });\n          }\n          const group = groups.get(keyStr)!;\n          if (valueVar !== null) {\n            const value = walk(valueVar, s);\n            group.values.push(value);\n          }\n          group.substitutions.push(s);\n        },\n        error: (error) => {\n          groups.clear();\n          observer.error?.(error);\n        },\n        complete: () => {\n          // Different output generation based on drop parameter\n          if (drop) {\n            // Drop mode: emit one fresh substitution per group\n            for (const { key, values, substitutions } of groups.values()) {\n              const aggregated = aggregator(values, substitutions);\n              const subst = new Map();\n              const subst1 = unify(keyVar, key, subst);\n              if (subst1 === null) continue;\n              const subst2 = unify(outVar, aggregated, subst1);\n              if (subst2 === null) continue;\n              observer.next(subst2 as Subst);\n            }\n          } else {\n            // Preserve mode: emit all substitutions with aggregated result added\n            for (const { key, values, substitutions } of groups.values()) {\n              const aggregated = aggregator(values, substitutions);\n              for (const subst of substitutions) {\n                const subst1 = unify(keyVar, key, subst);\n                if (subst1 === null) continue;\n                const subst2 = unify(outVar, aggregated, subst1);\n                if (subst2 === null) continue;\n                observer.next(subst2 as Subst);\n              }\n            }\n          }\n          groups.clear();\n          observer.complete?.();\n        },\n      });\n\n      return () => {\n        subscription.unsubscribe?.();\n        groups.clear();\n      };\n    });\n}\n","import { eq } from \"../core/combinators.js\";\nimport {\n\tarrayToLogicList,\n\tenrichGroupInput,\n\tunify,\n\twalk,\n} from \"../core/kernel.js\";\nimport { SimpleObservable } from \"../core/observable.js\";\nimport type { Goal, Observable, Subst, Term, Var } from \"../core/types.ts\";\nimport {\n\tcollect_and_process_base,\n\tgroup_by_streamo_base,\n} from \"./aggregates-base.js\";\n\n/**\n * count_value_streamo(x, value, count):\n *   count is the number of times x == value in the current stream of substitutions.\n *   (Stream-based version: aggregates over the current stream, like maxo/mino.)\n *\n * Usage: count_value_streamo(x, value, count)\n */\nexport function count_value_streamo(x: Term, value: Term, count: Term): Goal {\n\treturn (input$: Observable<Subst>) =>\n\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\tconst substitutions: Subst[] = [];\n\n\t\t\tconst subscription = input$.subscribe({\n\t\t\t\tnext: (s) => substitutions.push(s),\n\t\t\t\terror: (error) => {\n\t\t\t\t\t// Clean up substitutions on error\n\t\t\t\t\tsubstitutions.length = 0;\n\t\t\t\t\tobserver.error?.(error);\n\t\t\t\t},\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tlet n = 0;\n\t\t\t\t\tfor (const s of substitutions) {\n\t\t\t\t\t\tconst val = walk(x, s);\n\t\t\t\t\t\tconst target = walk(value, s);\n\t\t\t\t\t\tif (JSON.stringify(val) === JSON.stringify(target)) n++;\n\t\t\t\t\t}\n\n\t\t\t\t\teq(\n\t\t\t\t\t\tcount,\n\t\t\t\t\t\tn,\n\t\t\t\t\t)(SimpleObservable.of(new Map())).subscribe({\n\t\t\t\t\t\tnext: observer.next,\n\t\t\t\t\t\terror: observer.error,\n\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\t// Clean up substitutions after processing\n\t\t\t\t\t\t\tsubstitutions.length = 0;\n\t\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Return cleanup function to handle early unsubscription\n\t\t\treturn () => {\n\t\t\t\tsubscription.unsubscribe?.();\n\t\t\t\tsubstitutions.length = 0; // Clean up substitutions on unsubscribe\n\t\t\t};\n\t\t});\n}\n\n/**\n * group_by_count_streamo(x, count, drop?):\n *   Groups the input stream by values of x and counts each group.\n *   - If drop=false (default): Preserves all variables from original substitutions,\n *     emitting one result for EACH substitution in each group with the count added.\n *   - If drop=true: Creates fresh substitutions with ONLY x and count variables.\n *   Example: if stream is x=A,y=1; x=A,y=2; x=B,y=3\n *   - drop=false: emits x=A,y=1,count=2; x=A,y=2,count=2; x=B,y=3,count=1\n *   - drop=true: emits x=A,count=2; x=B,count=1\n */\nexport function group_by_count_streamo(\n\tx: Term,\n\tcount: Term,\n\tdrop = false,\n): Goal {\n\treturn group_by_streamo_base(\n\t\tx, // keyVar\n\t\tnull, // valueVar (not needed for counting)\n\t\tcount, // outVar\n\t\tdrop, // drop\n\t\t(_, substitutions) => substitutions.length, // aggregator: count substitutions\n\t);\n}\n\n/**\n * sort_by_streamo(x, orderOrFn?):\n *   Sorts the stream of substitutions by the value of x.\n *   - If orderOrFn is 'asc' (default), sorts ascending.\n *   - If orderOrFn is 'desc', sorts descending.\n *   - If orderOrFn is a function (a, b) => number, uses it as the comparator on walked x values.\n *   Emits the same substitutions, but in sorted order by x.\n *   Example: if stream is x=3, x=1, x=2, emits x=1, x=2, x=3 (asc)\n */\nexport function sort_by_streamo(\n\tx: Term,\n\torderOrFn?: \"asc\" | \"desc\" | ((a: any, b: any) => number),\n): Goal {\n\treturn collect_and_process_base(\n\t\t(buffer: Subst[], observer: { next: (s: Subst) => void }) => {\n\t\t\t// Extract values and create sortable pairs\n\t\t\tconst pairs = buffer.map((subst) => ({\n\t\t\t\tvalue: walk(x, subst),\n\t\t\t\tsubst,\n\t\t\t}));\n\n\t\t\t// Create comparator\n\t\t\tconst orderFn = (() => {\n\t\t\t\tif (typeof orderOrFn === \"function\") {\n\t\t\t\t\treturn orderOrFn;\n\t\t\t\t}\n\t\t\t\tif (typeof orderOrFn === \"string\") {\n\t\t\t\t\tif (orderOrFn === \"desc\") {\n\t\t\t\t\t\treturn descComparator;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ascComparator;\n\t\t\t})();\n\n\t\t\tconst comparator = (a: { value: any }, b: { value: any }) =>\n\t\t\t\torderFn(a.value, b.value);\n\n\t\t\t// Sort and emit\n\t\t\tpairs.sort(comparator);\n\t\t\tfor (const { subst } of pairs) {\n\t\t\t\tobserver.next(subst);\n\t\t\t}\n\t\t},\n\t);\n}\n\nconst descComparator = <T>(a: T, b: T) => {\n\tif (a < b) return 1;\n\tif (a > b) return -1;\n\treturn 0;\n};\n\nconst ascComparator = <T>(a: T, b: T) => {\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\treturn 0;\n};\n\n/**\n * take_streamo(n):\n *   Allows only the first n substitutions to pass through the stream.\n *   Example: take_streamo(3) will emit only the first 3 substitutions.\n */\nexport function take_streamo(n: number): Goal {\n\treturn (input$: Observable<Subst>) =>\n\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\tlet count = 0;\n\n\t\t\tconst subscription = input$.subscribe({\n\t\t\t\tnext: (item) => {\n\t\t\t\t\tif (count < n) {\n\t\t\t\t\t\tobserver.next(item);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (count === n) {\n\t\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\t\tsubscription.unsubscribe?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: observer.complete,\n\t\t\t});\n\n\t\t\treturn () => subscription.unsubscribe?.();\n\t\t});\n}\n\n/**\n * group_by_collect_streamo(keyVar, valueVar, outList, drop?):\n *   Groups the input stream by keyVar and collects valueVar values into lists.\n *   The keyVar is preserved in the output (no need for separate outKey parameter).\n *   - If drop=false (default): Preserves all variables from original substitutions,\n *     emitting one result for EACH substitution in each group with the collected list added.\n *   - If drop=true: Creates fresh substitutions with ONLY keyVar and outList variables.\n *   Example: if stream is x=A,y=1; x=A,y=2; x=B,y=3\n *   - drop=false: emits x=A,y=1,list=[1,2]; x=A,y=2,list=[1,2]; x=B,y=3,list=[3]\n *   - drop=true: emits x=A,list=[1,2]; x=B,list=[3]\n */\nexport function group_by_collect_streamo<T>(\n\tkeyVar: Term,\n\tvalueVar: Term<T>,\n\toutList: Term<T[]>,\n\tdrop = false,\n): Goal {\n\treturn group_by_streamo_base(\n\t\tkeyVar, // keyVar\n\t\tvalueVar, // valueVar\n\t\toutList, // outVar\n\t\tdrop, // drop\n\t\t(values, _) => arrayToLogicList(values), // aggregator: collect into list\n\t);\n}\n\nexport function group_by_collect_distinct_streamo<T>(\n\tkeyVar: Term,\n\tvalueVar: Term<T>,\n\toutList: Term<T[]>,\n\tdrop = false,\n): Goal {\n\treturn group_by_streamo_base(\n\t\tkeyVar, // keyVar\n\t\tvalueVar, // valueVar\n\t\toutList, // outVar\n\t\tdrop, // drop\n\t\t(values, _) => arrayToLogicList([...new Set(values)]), // aggregator: collect into list\n\t);\n}\n\nexport function collect_streamo(\n\tvalueVar: Term,\n\toutList: Term,\n\tdrop = false,\n): Goal {\n\treturn collect_and_process_base((buffer, observer) => {\n\t\tconst results = buffer.map((x) => walk(valueVar, x));\n\t\tlet s;\n\t\tif (drop) {\n\t\t\ts = new Map() as Subst;\n\t\t} else {\n\t\t\ts = buffer[0] ?? new Map();\n\t\t}\n\t\tconst newSubst = unify(results, outList, s);\n\t\tif (newSubst) {\n\t\t\tobserver.next(newSubst);\n\t\t}\n\t});\n}\n\n// export function collect_distinct_streamo(\n//   valueVar: Term,\n//   outList: Term,\n//   drop = false,\n// ): Goal {\n//   return collect_and_process_base(\n//     (buffer, observer) => {\n//       const resultsRaw = buffer.map(x => walk(valueVar, x));\n//       const results = [...new Set(resultsRaw)];\n//       let s;\n//       if(drop) {\n//         s = new Map() as Subst;\n//       } else {\n//         s = buffer[0];\n//       }\n//       const newSubst = unify(results, outList, s);\n//       if(newSubst) {\n//         observer.next(newSubst);\n//       }\n//     }\n//   )\n// }\n","import { and, branch, eq, fresh, lift, Subquery } from \"../core/combinators.js\";\nimport {\n\tarrayToLogicList,\n\tenrichGroupInput,\n\tisVar,\n\tlogicListToArray,\n\tlvar,\n\tunify,\n\twalk,\n} from \"../core/kernel.js\";\nimport type { Goal, Term, Var } from \"../core/types.ts\";\nimport {\n\tcollect_streamo,\n\tgroup_by_collect_distinct_streamo,\n\tgroup_by_collect_streamo,\n} from \"./aggregates.js\";\nimport { substLog } from \"./control.js\";\n\n/**\n * aggregateRelFactory: generic helper for collecto, collect_distincto, counto.\n * - x: variable to collect\n * - goal: logic goal\n * - out: output variable\n * - aggFn: aggregation function (receives array of results)\n * - dedup: if true, deduplicate results\n */\n\nexport function aggregateRelFactory(\n\taggFn: (results: Term[]) => any,\n\tdedup = false,\n) {\n\treturn (x: Term, goal: Goal, out: Term): Goal => {\n\t\treturn enrichGroupInput(\n\t\t\t\"aggregateRelFactory\",\n\t\t\t[],\n\t\t\t[goal],\n\t\t\tSubquery(\n\t\t\t\tgoal,\n\t\t\t\tx, // extract x from each subgoal result\n\t\t\t\tout, // bind the aggregated result to this variable\n\t\t\t\t(extractedValues, _) => {\n\t\t\t\t\tconst values = dedup ? deduplicate(extractedValues) : extractedValues;\n\t\t\t\t\treturn aggFn(values);\n\t\t\t\t},\n\t\t\t),\n\t\t);\n\t};\n}\n\n/**\n * collecto(x, goal, xs): xs is the list of all values x can take under goal (logic relation version)\n * Usage: collecto(x, membero(x, ...), xs)\n */\n\nexport const collecto = aggregateRelFactory(\n\t(arr) => arrayToLogicList(arr),\n\tfalse,\n);\n\n/**\n * collect_distincto(x, goal, xs): xs is the list of distinct values of x under goal.\n * Usage: collect_distincto(x, goal, xs)\n */\n\nexport const collect_distincto = aggregateRelFactory(\n\t(arr) => arrayToLogicList(arr),\n\ttrue,\n);\n\n/**\n * counto(x, goal, n): n is the number of (distinct) values of x under goal.\n * Usage: counto(x, goal, n)\n */\n\nexport const counto = aggregateRelFactory((arr) => arr.length, false);\n\nexport const count_distincto = aggregateRelFactory((arr) => arr.length, true);\n\n/**\n * count_valueo(x, goal, value, count):\n *   count is the number of times x == value in the stream of substitutions from goal.\n *   (Canonical, goal-wrapping version: aggregates over all solutions to goal.)\n *\n *   This is implemented using Subquery with a custom aggregator that counts\n *   how many times the extracted value equals the target value (walked in context).\n */\n\nexport function count_valueo(\n\tx: Term,\n\tgoal: Goal,\n\tvalue: Term,\n\tcount: Term,\n): Goal {\n\treturn Subquery(\n\t\tgoal,\n\t\tx, // extract x from each subgoal result\n\t\tcount, // bind the count to this variable\n\t\t(extractedValues, originalSubst) => {\n\t\t\t// Walk the value in the original substitution context\n\t\t\tconst targetValue = walk(value, originalSubst);\n\t\t\t// Count how many extracted values match the target value\n\t\t\treturn extractedValues.filter(\n\t\t\t\t(val) => JSON.stringify(val) === JSON.stringify(targetValue),\n\t\t\t).length;\n\t\t},\n\t);\n}\n// export function aggregateRelFactory(\n//   aggFn: (results: Term[]) => any,\n//   dedup = false,\n// ) {\n//   return (x: Term, goal: Goal, out: Term): Goal => {\n//     const ToutAgg = lvar(\"ToutAgg\");\n//     const collect_rel = dedup ? collect_distinct_streamo : collect_streamo\n//     return and(\n//       goal,\n//       collect_rel(x, ToutAgg, false),\n//       lift(aggFn)(ToutAgg, out),\n//     )\n//   };\n// }\n/**\n * groupAggregateRelFactory(aggFn): returns a group-by aggregation goal constructor.\n * The returned function has signature (keyVar, valueVar, goal, outKey, outAgg, dedup?) => Goal\n * Example: const group_by_collecto = groupAggregateRelFactory(arrayToLogicList)\n */\n\nexport function groupAggregateRelFactory(\n\taggFn: (items: any[]) => any,\n\tdedup = false,\n) {\n\treturn (\n\t\tkeyVar: Term,\n\t\tvalueVar: Term,\n\t\tgoal: Goal,\n\t\toutValueAgg: Term,\n\t): Goal => {\n\t\tconst group_by_rel = dedup\n\t\t\t? group_by_collect_distinct_streamo\n\t\t\t: group_by_collect_streamo;\n\t\t// @ts-expect-error\n\t\tconst aggFnName = aggFn?.displayName || aggFn.name || \"unknown\";\n\t\treturn enrichGroupInput(\n\t\t\t`groupAggregateRelFactory ${aggFnName}`,\n\t\t\t[],\n\t\t\t[goal],\n\t\t\tfresh((in_outValueAgg) =>\n\t\t\t\tbranch(\n\t\t\t\t\tand(goal, group_by_rel(keyVar, valueVar, in_outValueAgg, true)),\n\t\t\t\t\t(observer, substs, subst) => {\n\t\t\t\t\t\tfor (const oneSubst of substs) {\n\t\t\t\t\t\t\tconst keyVal = walk(keyVar as Term, oneSubst);\n\t\t\t\t\t\t\tif (isVar(keyVal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst valueAggVal = walk(in_outValueAgg, oneSubst);\n\t\t\t\t\t\t\tif (isVar(valueAggVal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst convertedAgg = aggFn(valueAggVal as any[]);\n\t\t\t\t\t\t\tconst s2 = unify(keyVar, keyVal, subst);\n\t\t\t\t\t\t\tif (!s2) continue;\n\t\t\t\t\t\t\tconst s3 = unify(outValueAgg, convertedAgg, s2);\n\t\t\t\t\t\t\tif (!s3) continue;\n\t\t\t\t\t\t\tobserver.next(s3);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t};\n}\n\nexport const group_by_collecto = groupAggregateRelFactory(\n\tfunction group_by_collecto(x) {\n\t\treturn x;\n\t},\n);\nexport const group_by_counto = groupAggregateRelFactory(\n\tfunction group_by_counto(items: any[]) {\n\t\treturn logicListToArray(items).length;\n\t},\n);\n\n/**\n * Helper: deduplicate an array of items using JSON.stringify for deep equality.\n */\nfunction deduplicate<T>(items: T[]): T[] {\n\tconst seen = new Set<string>();\n\tconst result: T[] = [];\n\tfor (const item of items) {\n\t\tconst k = JSON.stringify(item);\n\t\tif (!seen.has(k)) {\n\t\t\tseen.add(k);\n\t\t\tresult.push(item);\n\t\t}\n\t}\n\treturn result;\n}\n","import util from \"node:util\";\nimport { eq } from \"../core/combinators.js\";\nimport { enrichGroupInput, isVar, unify, walk } from \"../core/kernel.js\";\nimport { SimpleObservable } from \"../core/observable.js\";\nimport {\n\tgetSuspendsFromSubst,\n\tSUSPENDED_CONSTRAINTS,\n} from \"../core/subst-suspends.js\";\nimport { CHECK_LATER, suspendable } from \"../core/suspend-helper.js\";\nimport type { ConsNode, Goal, Subst, Term } from \"../core/types.js\";\n\nexport const uniqueo = (t: Term, g: Goal): Goal =>\n\tenrichGroupInput(\"uniqueo\", [g], [], (input$: SimpleObservable<Subst>) =>\n\t\tinput$.flatMap((s: Subst) => {\n\t\t\tconst seen = new Set();\n\t\t\treturn g(SimpleObservable.of(s)).flatMap((s2: Subst) => {\n\t\t\t\tconst w_t = walk(t, s2);\n\t\t\t\tif (isVar(w_t)) {\n\t\t\t\t\treturn SimpleObservable.of(s2);\n\t\t\t\t}\n\t\t\t\tconst key = JSON.stringify(w_t);\n\t\t\t\tif (seen.has(key)) return SimpleObservable.empty();\n\t\t\t\tseen.add(key);\n\t\t\t\treturn SimpleObservable.of(s2);\n\t\t\t});\n\t\t}),\n\t);\n\nexport function not(goal: Goal): Goal {\n\treturn enrichGroupInput(\"not\", [], [goal], (input$) =>\n\t\tinput$.flatMap((s: Subst) => {\n\t\t\treturn new SimpleObservable<Subst>((observer) => {\n\t\t\t\tlet hasSolutions = false;\n\t\t\t\tconst sub = goal(SimpleObservable.of(s)).subscribe({\n\t\t\t\t\tnext: (subst) => {\n\t\t\t\t\t\tif (!subst.has(SUSPENDED_CONSTRAINTS)) {\n\t\t\t\t\t\t\thasSolutions = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\terror: (err) => observer.error?.(err),\n\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\tif (!hasSolutions) {\n\t\t\t\t\t\t\tobserver.next(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\treturn () => sub.unsubscribe();\n\t\t\t});\n\t\t}),\n\t);\n}\n\nexport function gv1_not(goal: Goal): Goal {\n\treturn enrichGroupInput(\n\t\t\"not\",\n\t\t[],\n\t\t[goal],\n\t\t(input$: SimpleObservable<Subst>) =>\n\t\t\tinput$.flatMap((s: Subst) => {\n\t\t\t\treturn new SimpleObservable<Subst>((observer) => {\n\t\t\t\t\tlet hasSolutions = false;\n\t\t\t\t\tconst sub = goal(SimpleObservable.of(s)).subscribe({\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\thasSolutions = true; // Any solution means the goal succeeds, so not fails\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: (err) => observer.error?.(err),\n\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\tif (!hasSolutions) {\n\t\t\t\t\t\t\t\tobserver.next(s); // No solutions means not succeeds\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\treturn () => sub.unsubscribe();\n\t\t\t\t});\n\t\t\t}),\n\t);\n}\n\nexport function old_not(goal: Goal): Goal {\n\treturn enrichGroupInput(\n\t\t\"not\",\n\t\t[],\n\t\t[goal],\n\t\t(input$: SimpleObservable<Subst>) =>\n\t\t\tinput$.flatMap((s: Subst) => {\n\t\t\t\tlet found = false;\n\t\t\t\treturn new SimpleObservable<Subst>((observer) => {\n\t\t\t\t\tgoal(SimpleObservable.of(s)).subscribe({\n\t\t\t\t\t\tnext: (subst) => {\n\t\t\t\t\t\t\tlet addedNewBindings = false;\n\t\t\t\t\t\t\tfor (const [key, value] of subst) {\n\t\t\t\t\t\t\t\tif (!s.has(key)) {\n\t\t\t\t\t\t\t\t\taddedNewBindings = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!addedNewBindings) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: observer.error,\n\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\tif (!found) observer.next(s);\n\t\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}),\n\t);\n}\n\nexport function neqo(x: Term<any>, y: Term<any>): Goal {\n\treturn suspendable(\n\t\t[x, y],\n\t\t(values, subst) => {\n\t\t\tconst [xVal, yVal] = values;\n\t\t\tconst xGrounded = !isVar(xVal);\n\t\t\tconst yGrounded = !isVar(yVal);\n\n\t\t\tif (xGrounded && yGrounded) {\n\t\t\t\t// Both terms are ground, check inequality\n\t\t\t\treturn xVal !== yVal ? subst : null;\n\t\t\t}\n\n\t\t\tif (!xGrounded && !yGrounded) {\n\t\t\t\tif (xVal.id === yVal.id) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if(xGrounded) {\n\t\t\t//   const newsubst = unify(yVal, xVal, subst)\n\t\t\t//   console.log(newsubst);\n\t\t\t//   if(newsubst === null) return subst;\n\t\t\t//   return CHECK_LATER;\n\t\t\t// }\n\n\t\t\t// if(yGrounded) {\n\t\t\t//   const newsubst = unify(xVal, yVal, subst)\n\t\t\t//   console.log(newsubst);\n\t\t\t//   if(newsubst === null) return subst;\n\t\t\t//   return CHECK_LATER;\n\t\t\t// }\n\t\t\treturn CHECK_LATER;\n\t\t},\n\t\t0,\n\t);\n}\n\n// export const neqo = (x: Term, y: Term): Goal => not(eq(x, y));\nexport function old_neqo(x: Term<any>, y: Term<any>): Goal {\n\treturn suspendable(\n\t\t[x, y],\n\t\t(values, subst) => {\n\t\t\treturn CHECK_LATER;\n\t\t\tconst [xVal, yVal] = values;\n\t\t\tconst xGrounded = !isVar(xVal);\n\t\t\tconst yGrounded = !isVar(yVal);\n\n\t\t\t// All grounded - check constraint\n\t\t\tif (xGrounded && yGrounded) {\n\t\t\t\treturn xVal !== yVal ? subst : null;\n\t\t\t}\n\n\t\t\t// if(xGrounded) {\n\t\t\t//   const s2 = unify(xVal, yVal, subst);\n\t\t\t//   if(s2) return CHECK_LATER;\n\t\t\t//   return subst;\n\t\t\t// }\n\n\t\t\t// if(yGrounded) {\n\t\t\t//   const s2 = unify(yVal, xVal, subst);\n\t\t\t//   if(s2) return CHECK_LATER;\n\t\t\t//   return subst;\n\t\t\t// }\n\n\t\t\treturn CHECK_LATER; // Still not enough variables bound\n\t\t},\n\t\t0,\n\t);\n}\n\n/**\n * A goal that succeeds if the given goal succeeds exactly once.\n * Useful for cut-like behavior.\n */\nexport function onceo(goal: Goal): Goal {\n\treturn (input$: SimpleObservable<Subst>) => goal(input$).take(1);\n}\n\n/**\n * A goal that always succeeds with the given substitution.\n * Useful as a base case or for testing.\n */\nexport function succeedo(): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tinput$.flatMap(\n\t\t\t(s: Subst) =>\n\t\t\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\t\t\tobserver.next(s);\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t}),\n\t\t);\n}\n\n/**\n * A goal that always fails.\n * Useful for testing or as a base case.\n */\nexport function failo(): Goal {\n\treturn (_input$: SimpleObservable<Subst>) => SimpleObservable.empty<Subst>();\n}\n\n/**\n * A goal that succeeds if the term is ground (contains no unbound variables).\n */\nexport function groundo(term: Term): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tinput$.flatMap(\n\t\t\t(s: Subst) =>\n\t\t\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\t\t\tconst walked = walk(term, s);\n\t\t\t\t\tfunction isGround(t: Term): boolean {\n\t\t\t\t\t\tif (isVar(t)) return false;\n\t\t\t\t\t\tif (Array.isArray(t)) {\n\t\t\t\t\t\t\treturn t.every(isGround);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (t && typeof t === \"object\" && \"tag\" in t) {\n\t\t\t\t\t\t\tif (t.tag === \"cons\") {\n\t\t\t\t\t\t\t\tconst l = t as ConsNode;\n\t\t\t\t\t\t\t\treturn isGround(l.head) && isGround(l.tail);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (t.tag === \"nil\") {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (t && typeof t === \"object\" && !(\"tag\" in t)) {\n\t\t\t\t\t\t\treturn Object.values(t).every(isGround);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true; // primitives are ground\n\t\t\t\t\t}\n\t\t\t\t\tif (isGround(walked)) {\n\t\t\t\t\t\tobserver.next(s);\n\t\t\t\t\t}\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t}),\n\t\t);\n}\n\n/**\n * A goal that succeeds if the term is not ground (contains unbound variables).\n */\nexport function nonGroundo(term: Term): Goal {\n\treturn not(groundo(term));\n}\n\n/**\n * A goal that logs each substitution it sees along with a message.\n */\nexport function substLog(msg: string, onlyVars = false): Goal {\n\treturn enrichGroupInput(\n\t\t\"substLog\",\n\t\t[],\n\t\t[],\n\t\t(input$: SimpleObservable<Subst>) =>\n\t\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\t\tconst sub = input$.subscribe({\n\t\t\t\t\tnext: (s) => {\n\t\t\t\t\t\tconst ns = onlyVars\n\t\t\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\t\t\t[...s.entries()].filter(([k, v]) => typeof k === \"string\"),\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: s;\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[substLog] ${msg}:`,\n\t\t\t\t\t\t\tutil.inspect(ns, {\n\t\t\t\t\t\t\t\tdepth: null,\n\t\t\t\t\t\t\t\tcolors: true,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tobserver.next(s);\n\t\t\t\t\t},\n\t\t\t\t\terror: observer.error,\n\t\t\t\t\tcomplete: observer.complete,\n\t\t\t\t});\n\t\t\t\treturn () => sub.unsubscribe();\n\t\t\t}),\n\t);\n}\n\nlet thruCountId = 0;\nexport function thruCount(msg: string, level = 1000): Goal {\n\tconst id = ++thruCountId;\n\treturn enrichGroupInput(\n\t\t\"thruCount\",\n\t\t[],\n\t\t[],\n\t\t(input$: SimpleObservable<Subst>) =>\n\t\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\t\tlet cnt = 0;\n\t\t\t\tconst sub = input$.subscribe({\n\t\t\t\t\tnext: (s) => {\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\t// Determine current level based on count\n\t\t\t\t\t\tlet currentLevel = 1;\n\t\t\t\t\t\tif (cnt >= 10) currentLevel = 10;\n\t\t\t\t\t\tif (cnt >= 100) currentLevel = 100;\n\t\t\t\t\t\tif (cnt >= 1000) currentLevel = 1000;\n\t\t\t\t\t\t// if (cnt >= 10000) currentLevel = 10000;\n\t\t\t\t\t\t// if (cnt >= 100000) currentLevel = 100000;\n\n\t\t\t\t\t\tif (cnt % currentLevel === 0) {\n\t\t\t\t\t\t\tlet nonSymbolKeyCount = 0;\n\t\t\t\t\t\t\tfor (const key of s.keys()) {\n\t\t\t\t\t\t\t\tif (typeof key !== \"symbol\") nonSymbolKeyCount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst suspendedCount = getSuspendsFromSubst(s).length;\n\t\t\t\t\t\t\tconsole.log(\"THRU\", id, msg, cnt, {\n\t\t\t\t\t\t\t\tnonSymbolKeyCount,\n\t\t\t\t\t\t\t\tsuspendedCount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobserver.next(s);\n\t\t\t\t\t},\n\t\t\t\t\terror: observer.error,\n\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\tconsole.log(\"THRU COMPLETE\", id, msg, cnt);\n\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\treturn () => sub.unsubscribe();\n\t\t\t}),\n\t);\n}\n\nexport function fail(): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\tconst sub = input$.subscribe({\n\t\t\t\tnext: (s) => {\n\t\t\t\t\t/* pass */\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: observer.complete,\n\t\t\t});\n\t\t\treturn () => sub.unsubscribe();\n\t\t});\n}\n","import { and, eq } from \"../core/combinators.js\";\nimport {\n  cons,\n  enrichGroupInput,\n  isCons,\n  isLogicList,\n  isNil,\n  logicListToArray,\n  lvar,\n  nil,\n  unify,\n  walk,\n} from \"../core/kernel.js\";\nimport { SimpleObservable } from \"../core/observable.js\";\nimport type { Goal, LogicList, Subst, Term } from \"../core/types.js\";\n\nexport function membero(x: Term, list: Term): Goal {\n  return enrichGroupInput(\n    \"membero\",\n    [],\n    [],\n    (input$) =>\n      new SimpleObservable<Subst>((observer) => {\n        const subscriptions: any[] = [];\n        let cancelled = false;\n        let active = 0;\n        let inputComplete = false;\n\n        const checkComplete = () => {\n          if (inputComplete && active === 0 && !cancelled) {\n            observer.complete?.();\n          }\n        };\n\n        const inputSub = input$.subscribe({\n          next: (s) => {\n            if (cancelled) return;\n\n            const l = walk(list, s);\n            // Fast path for arrays\n            if (Array.isArray(l)) {\n              for (let i = 0; i < l.length; i++) {\n                if (cancelled) break;\n                const item = l[i];\n                const s2 = unify(x, item, s);\n                if (s2) observer.next(s2);\n              }\n            } else if (\n              l &&\n              typeof l === \"object\" &&\n              \"tag\" in l &&\n              (l as any).tag === \"cons\"\n            ) {\n              if (cancelled) return;\n\n              const s1 = unify(x, (l as any).head, s);\n              if (s1) observer.next(s1);\n\n              active++;\n              // Recursive call for tail\n              const sub = membero(\n                x,\n                (l as any).tail,\n              )(SimpleObservable.of(s)).subscribe({\n                next: (result) => {\n                  if (!cancelled) observer.next(result);\n                },\n                error: (err) => {\n                  if (!cancelled) observer.error?.(err);\n                },\n                complete: () => {\n                  active--;\n                  checkComplete();\n                },\n              });\n              subscriptions.push(sub);\n            }\n            // If neither array nor cons, do nothing (no result)\n          },\n          error: (err) => {\n            if (!cancelled) observer.error?.(err);\n          },\n          complete: () => {\n            inputComplete = true;\n            checkComplete();\n          },\n        });\n\n        subscriptions.push(inputSub);\n\n        return () => {\n          cancelled = true;\n          subscriptions.forEach((sub) => {\n            try {\n              sub?.unsubscribe?.();\n            } catch (e) {\n              // Ignore cleanup errors\n            }\n          });\n          subscriptions.length = 0;\n        };\n      }),\n  );\n}\n\n/**\n * A goal that succeeds if `h` is the head of the logic list `l`.\n */\nexport function firsto(x: Term, xs: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const l = walk(xs, s);\n          if (isCons(l)) {\n            const consNode = l as { tag: \"cons\"; head: Term; tail: Term };\n            const s1 = unify(x, consNode.head, s);\n            if (s1) observer.next(s1);\n          }\n          observer.complete?.();\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n\n/**\n * A goal that succeeds if `t` is the tail of the logic list `l`.\n */\nexport function resto(xs: Term, tail: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const l = walk(xs, s);\n          if (isCons(l)) {\n            const consNode = l as { tag: \"cons\"; head: Term; tail: Term };\n            const s1 = unify(tail, consNode.tail, s);\n            if (s1) observer.next(s1);\n          }\n          observer.complete?.();\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n\n/**\n * A goal that succeeds if logic list `zs` is the result of appending\n * logic list `ys` to `xs`.\n */\nexport function appendo(xs: Term, ys: Term, zs: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const xsVal = walk(xs, s);\n          if (isCons(xsVal)) {\n            const consNode = xsVal as { tag: \"cons\"; head: Term; tail: Term };\n            const head = consNode.head;\n            const tail = consNode.tail;\n            const rest = lvar();\n            const s1 = unify(\n              zs,\n              {\n                tag: \"cons\",\n                head,\n                tail: rest,\n              },\n              s,\n            );\n            if (s1) {\n              appendo(\n                tail,\n                ys,\n                rest,\n              )(SimpleObservable.of(s1)).subscribe({\n                next: observer.next,\n                error: observer.error,\n                complete: observer.complete,\n              });\n              return;\n            }\n          } else if (isNil(xsVal)) {\n            const s1 = unify(ys, zs, s);\n            if (s1) observer.next(s1);\n          }\n          observer.complete?.();\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n\n/**\n * A goal that unifies the length of an array or logic list with a numeric value.\n * @param arrayOrList The array or logic list to measure\n * @param length The length to unify with\n */\nexport function lengtho(arrayOrList: Term, length: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const walkedArray = walk(arrayOrList, s);\n          const walkedLength = walk(length, s);\n          let actualLength: number;\n          if (isLogicList(walkedArray)) {\n            actualLength = logicListToArray(walkedArray).length;\n          } else if (Array.isArray(walkedArray)) {\n            actualLength = walkedArray.length;\n          } else {\n            // observer.complete?.();\n            return;\n          }\n          const unified = unify(actualLength, walkedLength, s);\n          if (unified !== null) {\n            observer.next(unified);\n          }\n          // observer.complete?.();\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n\nexport function permuteo(xs: Term, ys: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const xsVal = walk(xs, s);\n          if (isNil(xsVal)) {\n            eq(\n              ys,\n              nil,\n            )(SimpleObservable.of(s)).subscribe({\n              next: observer.next,\n              error: observer.error,\n              complete: observer.complete,\n            });\n            return;\n          }\n          if (isCons(xsVal)) {\n            const arr = logicListToArray(xsVal as LogicList);\n            let completedCount = 0;\n            for (const head of arr) {\n              const rest = lvar();\n              and(\n                removeFirsto(xsVal, head, rest),\n                permuteo(rest, lvar()),\n                eq(ys, cons(head, lvar())),\n              )(SimpleObservable.of(s)).subscribe({\n                next: (s1) => {\n                  const ysVal2 = walk(ys, s1);\n                  if (isCons(ysVal2)) {\n                    eq(\n                      ysVal2.tail,\n                      walk(lvar(), s1),\n                    )(SimpleObservable.of(s1)).subscribe({\n                      next: observer.next,\n                      error: observer.error,\n                    });\n                  }\n                },\n                error: observer.error,\n                complete: () => {\n                  completedCount++;\n                  if (completedCount === arr.length) {\n                    observer.complete?.();\n                  }\n                },\n              });\n            }\n            if (arr.length === 0) {\n              observer.complete?.();\n            }\n          } else {\n            observer.complete?.();\n          }\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n\nexport function mapo(\n  rel: (x: Term, y: Term) => Goal,\n  xs: Term,\n  ys: Term,\n): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const xsVal = walk(xs, s);\n          if (isNil(xsVal)) {\n            eq(\n              ys,\n              nil,\n            )(SimpleObservable.of(s)).subscribe({\n              next: observer.next,\n              error: observer.error,\n              complete: () => {\n                active--;\n                if (completed && active === 0) observer.complete?.();\n              },\n            });\n            return;\n          }\n          if (isCons(xsVal)) {\n            const xHead = xsVal.head;\n            const xTail = xsVal.tail;\n            const yHead = lvar();\n            const yTail = lvar();\n            and(\n              eq(ys, cons(yHead, yTail)),\n              rel(xHead, yHead),\n              mapo(rel, xTail, yTail),\n            )(SimpleObservable.of(s)).subscribe({\n              next: observer.next,\n              error: observer.error,\n              complete: () => {\n                active--;\n                if (completed && active === 0) observer.complete?.();\n              },\n            });\n          } else {\n            active--;\n            if (completed && active === 0) observer.complete?.();\n          }\n        },\n        error: observer.error,\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\nexport function removeFirsto(xs: Term, x: Term, ys: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      let active = 0;\n      let completed = false;\n      const subscription = input$.subscribe({\n        next: (s) => {\n          active++;\n          const xsVal = walk(xs, s);\n          if (isNil(xsVal)) {\n            active--;\n            if (completed && active === 0) observer.complete?.();\n            return;\n          }\n          if (isCons(xsVal)) {\n            const walkedX = walk(x, s);\n            const walkedHead = walk(xsVal.head, s);\n            if (JSON.stringify(walkedHead) === JSON.stringify(walkedX)) {\n              eq(\n                ys,\n                xsVal.tail,\n              )(SimpleObservable.of(s)).subscribe({\n                next: observer.next,\n                error: observer.error,\n                complete: () => {\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                },\n              });\n            } else {\n              const rest = lvar();\n              and(\n                eq(ys, cons(xsVal.head, rest)),\n                removeFirsto(xsVal.tail, x, rest),\n              )(SimpleObservable.of(s)).subscribe({\n                next: observer.next,\n                error: observer.error,\n                complete: () => {\n                  active--;\n                  if (completed && active === 0) observer.complete?.();\n                },\n              });\n            }\n          } else {\n            active--;\n            if (completed && active === 0) observer.complete?.();\n          }\n        },\n        error: observer.error,\n        complete: () => {\n          completed = true;\n          if (active === 0) observer.complete?.();\n        },\n      });\n      return () => subscription.unsubscribe?.();\n    });\n}\n\n/**\n * alldistincto(xs): true if all elements of xs are distinct.\n */\nexport function alldistincto(xs: Term): Goal {\n  return (input$) =>\n    new SimpleObservable<Subst>((observer) => {\n      input$.subscribe({\n        next: (s) => {\n          const arr = walk(xs, s);\n          let jsArr: any[] = [];\n          if (arr && typeof arr === \"object\" && \"tag\" in arr) {\n            let cur: Term = arr;\n            while (isCons(cur)) {\n              jsArr.push(cur.head);\n              cur = cur.tail;\n            }\n          } else if (Array.isArray(arr)) {\n            jsArr = arr;\n          }\n          const seen = new Set();\n          let allDistinct = true;\n          for (const v of jsArr) {\n            const key = JSON.stringify(v);\n            if (seen.has(key)) {\n              allDistinct = false;\n              break;\n            }\n            seen.add(key);\n          }\n          if (allDistinct) observer.next(s);\n          observer.complete?.();\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n    });\n}\n","import { isVar, unify, walk } from \"../core/kernel.js\";\nimport { SimpleObservable } from \"../core/observable.js\";\nimport { CHECK_LATER, suspendable } from \"../core/suspend-helper.js\";\nimport type { Goal, Subst, Term } from \"../core/types.js\";\n\n/**\n * A goal that succeeds if the numeric value in the first term is greater than\n * the numeric value in the second term.\n */\nexport function gto(x: Term<number>, y: Term<number>): Goal {\n\treturn suspendable(\n\t\t[x, y],\n\t\t(values: Term<any>[], subst: Subst) => {\n\t\t\tconst [xVal, yVal] = values;\n\t\t\tconst xGrounded = !isVar(xVal);\n\t\t\tconst yGrounded = !isVar(yVal);\n\n\t\t\t// All grounded - check constraint\n\t\t\tif (xGrounded && yGrounded) {\n\t\t\t\treturn xVal > yVal ? subst : null;\n\t\t\t}\n\n\t\t\treturn CHECK_LATER; // Still not enough variables bound\n\t\t},\n\t\t2,\n\t);\n}\n\n/**\n * A goal that succeeds if the numeric value in the first term is less than\n * the numeric value in the second term.\n */\nexport function lto(x: Term<number>, y: Term<number>): Goal {\n\treturn suspendable(\n\t\t[x, y],\n\t\t(values: Term<any>[], subst: Subst) => {\n\t\t\tconst [xVal, yVal] = values;\n\t\t\tconst xGrounded = !isVar(xVal);\n\t\t\tconst yGrounded = !isVar(yVal);\n\n\t\t\t// All grounded - check constraint\n\t\t\tif (xGrounded && yGrounded) {\n\t\t\t\treturn xVal < yVal ? subst : null;\n\t\t\t}\n\n\t\t\treturn CHECK_LATER; // Still not enough variables bound\n\t\t},\n\t\t2,\n\t);\n}\n\n/**\n * A goal that succeeds if the numeric value in the first term is greater than or equal to\n * the numeric value in the second term.\n */\nexport function gteo(x: Term<number>, y: Term<number>): Goal {\n\treturn suspendable(\n\t\t[x, y],\n\t\t(values: Term<any>[], subst: Subst) => {\n\t\t\tconst [xVal, yVal] = values;\n\t\t\tconst xGrounded = !isVar(xVal);\n\t\t\tconst yGrounded = !isVar(yVal);\n\n\t\t\t// All grounded - check constraint\n\t\t\tif (xGrounded && yGrounded) {\n\t\t\t\treturn xVal >= yVal ? subst : null;\n\t\t\t}\n\n\t\t\treturn CHECK_LATER; // Still not enough variables bound\n\t\t},\n\t\t2,\n\t);\n}\n\n/**\n * A goal that succeeds if the numeric value in the first term is less than or equal to\n * the numeric value in the second term.\n */\nexport function lteo(x: Term<number>, y: Term<number>): Goal {\n\treturn suspendable(\n\t\t[x, y],\n\t\t(values: Term<any>[], subst: Subst) => {\n\t\t\tconst [xVal, yVal] = values;\n\t\t\tconst xGrounded = !isVar(xVal);\n\t\t\tconst yGrounded = !isVar(yVal);\n\n\t\t\t// All grounded - check constraint\n\t\t\tif (xGrounded && yGrounded) {\n\t\t\t\treturn xVal <= yVal ? subst : null;\n\t\t\t}\n\n\t\t\treturn CHECK_LATER; // Still not enough variables bound\n\t\t},\n\t\t2,\n\t);\n}\n\n/**\n * A goal that succeeds if z is the sum of x and y.\n * Can work in multiple directions if some variables are grounded.\n */\nexport function pluso(x: Term<number>, y: Term<number>, z: Term<number>): Goal {\n\treturn suspendable([x, y, z], (values: Term<any>[], subst: Subst) => {\n\t\tconst [xVal, yVal, zVal] = values;\n\t\tconst xGrounded = !isVar(xVal);\n\t\tconst yGrounded = !isVar(yVal);\n\t\tconst zGrounded = !isVar(zVal);\n\n\t\t// All grounded - check constraint\n\t\tif (xGrounded && yGrounded && zGrounded) {\n\t\t\treturn xVal + yVal === zVal ? subst : null;\n\t\t}\n\t\t// Two grounded - compute third\n\t\telse if (xGrounded && yGrounded) {\n\t\t\treturn unify(z, xVal + yVal, subst);\n\t\t} else if (xGrounded && zGrounded) {\n\t\t\treturn unify(y, zVal - xVal, subst);\n\t\t} else if (yGrounded && zGrounded) {\n\t\t\treturn unify(x, zVal - yVal, subst);\n\t\t}\n\n\t\treturn CHECK_LATER; // Still not enough variables bound\n\t});\n}\nexport const minuso = (\n\tx: Term<number>,\n\ty: Term<number>,\n\tz: Term<number>,\n): Goal => pluso(z, y, x);\n\n/**\n * A goal that succeeds if z is the product of x and y.\n * Can work in multiple directions if some variables are grounded.\n */\nexport function multo(x: Term<number>, y: Term<number>, z: Term<number>): Goal {\n\treturn suspendable([x, y, z], (values: Term<any>[], subst: Subst) => {\n\t\tconst [xVal, yVal, zVal] = values;\n\t\tconst xGrounded = !isVar(xVal);\n\t\tconst yGrounded = !isVar(yVal);\n\t\tconst zGrounded = !isVar(zVal);\n\n\t\tif (xGrounded && yGrounded && zGrounded) {\n\t\t\treturn xVal * yVal === zVal ? subst : null;\n\t\t}\n\t\tif (xGrounded && yGrounded) {\n\t\t\treturn unify(z, xVal * yVal, subst);\n\t\t}\n\t\tif (zGrounded && zVal !== 0) {\n\t\t\tif (xGrounded && xVal === 0) return null;\n\t\t\tif (yGrounded && yVal === 0) return null;\n\t\t}\n\t\tif (xGrounded && zGrounded) {\n\t\t\treturn unify(y, zVal / xVal, subst);\n\t\t} else if (yGrounded && zGrounded) {\n\t\t\treturn unify(x, zVal / yVal, subst);\n\t\t}\n\n\t\treturn CHECK_LATER; // Still not enough variables bound\n\t});\n}\nexport const dividebyo = (\n\tx: Term<number>,\n\ty: Term<number>,\n\tz: Term<number>,\n): Goal => multo(z, y, x);\n\n/**\n * A goal that succeeds only for the substitution(s) that have the maximum value\n * for the given variable across all input substitutions.\n *\n * Usage: maxo($.movie_popularity) - selects the substitution with highest movie_popularity\n */\nexport function maxo(variable: Term): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\tconst substitutions: Subst[] = [];\n\n\t\t\t// First, collect all substitutions\n\t\t\tconst subscription = input$.subscribe({\n\t\t\t\tnext: (s) => {\n\t\t\t\t\tsubstitutions.push(s);\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tif (substitutions.length === 0) {\n\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find the maximum value and corresponding substitutions\n\t\t\t\t\tlet maxValue: number | undefined;\n\t\t\t\t\tconst maxSubstitutions: Subst[] = [];\n\n\t\t\t\t\tfor (const s of substitutions) {\n\t\t\t\t\t\tconst value = walk(variable, s);\n\t\t\t\t\t\tif (typeof value === \"number\") {\n\t\t\t\t\t\t\tif (maxValue === undefined || value > maxValue) {\n\t\t\t\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t\t\t\tmaxSubstitutions.length = 0; // Clear array\n\t\t\t\t\t\t\t\tmaxSubstitutions.push(s);\n\t\t\t\t\t\t\t} else if (value === maxValue) {\n\t\t\t\t\t\t\t\tmaxSubstitutions.push(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit all substitutions that have the maximum value\n\t\t\t\t\tfor (const s of maxSubstitutions) {\n\t\t\t\t\t\tobserver.next(s);\n\t\t\t\t\t}\n\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn () => subscription.unsubscribe?.();\n\t\t});\n}\n\n/**\n * A goal that succeeds only for the substitution(s) that have the minimum value\n * for the given variable across all input substitutions.\n *\n * Usage: mino($.movie_popularity) - selects the substitution with lowest movie_popularity\n */\nexport function mino(variable: Term): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\tconst substitutions: Subst[] = [];\n\n\t\t\t// First, collect all substitutions\n\t\t\tconst subscription = input$.subscribe({\n\t\t\t\tnext: (s) => {\n\t\t\t\t\tsubstitutions.push(s);\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tif (substitutions.length === 0) {\n\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find the minimum value and corresponding substitutions\n\t\t\t\t\tlet minValue: number | undefined;\n\t\t\t\t\tconst minSubstitutions: Subst[] = [];\n\n\t\t\t\t\tfor (const s of substitutions) {\n\t\t\t\t\t\tconst value = walk(variable, s);\n\t\t\t\t\t\tif (typeof value === \"number\") {\n\t\t\t\t\t\t\tif (minValue === undefined || value < minValue) {\n\t\t\t\t\t\t\t\tminValue = value;\n\t\t\t\t\t\t\t\tminSubstitutions.length = 0; // Clear array\n\t\t\t\t\t\t\t\tminSubstitutions.push(s);\n\t\t\t\t\t\t\t} else if (value === minValue) {\n\t\t\t\t\t\t\t\tminSubstitutions.push(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit all substitutions that have the minimum value\n\t\t\t\t\tfor (const s of minSubstitutions) {\n\t\t\t\t\t\tobserver.next(s);\n\t\t\t\t\t}\n\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn () => subscription.unsubscribe?.();\n\t\t});\n}\n","import { unify, walk, isVar } from \"../core/kernel.js\";\nimport { SimpleObservable } from \"../core/observable.js\";\nimport type { Goal, Subst, Term } from \"../core/types.js\";\n\n/**\n * A goal that extracts specific keys from an object and unifies them with logic variables.\n * This is a simpler alternative to projectJsonata for basic object key extraction.\n *\n * Usage:\n *   extract($.input_object, {\n *     name: $.output_name,\n *     age: $.output_age,\n *     nested: {\n *       city: $.output_city,\n *       country: $.output_country\n *     }\n *   })\n *\n * If the mapping value is a logic variable, it unifies directly.\n * If the mapping value is an object/array, it recursively extracts from nested structures.\n */\nexport function extract(inputVar: Term, mapping: Record<string, Term>): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tinput$.flatMap(\n\t\t\t(s: Subst) =>\n\t\t\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\t\t\tconst inputValue: Term<any> = walk(inputVar, s);\n\n\t\t\t\t\t// Input must be resolved to an object\n\t\t\t\t\tif (typeof inputValue !== \"object\" || inputValue === null) {\n\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Helper function to recursively extract values\n\t\t\t\t\tconst extractRecursive = (sourceValue: any, targetMapping: any, currentSubst: Subst): Subst | null => {\n\t\t\t\t\t\tif (isVar(targetMapping)) {\n\t\t\t\t\t\t\t// If target is a logic variable, unify directly\n\t\t\t\t\t\t\treturn unify(targetMapping, sourceValue, currentSubst);\n\t\t\t\t\t\t} else if (Array.isArray(targetMapping)) {\n\t\t\t\t\t\t\t// If target is an array, source should also be an array\n\t\t\t\t\t\t\tif (!Array.isArray(sourceValue) || sourceValue.length !== targetMapping.length) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet resultSubst = currentSubst;\n\t\t\t\t\t\t\tfor (let i = 0; i < targetMapping.length; i++) {\n\t\t\t\t\t\t\t\tconst nextSubst = extractRecursive(sourceValue[i], targetMapping[i], resultSubst);\n\t\t\t\t\t\t\t\tif (nextSubst === null) return null;\n\t\t\t\t\t\t\t\tresultSubst = nextSubst;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn resultSubst;\n\t\t\t\t\t\t} else if (typeof targetMapping === \"object\" && targetMapping !== null) {\n\t\t\t\t\t\t\t// If target is an object, recursively extract each key\n\t\t\t\t\t\t\tif (typeof sourceValue !== \"object\" || sourceValue === null) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet resultSubst = currentSubst;\n\t\t\t\t\t\t\tfor (const [key, targetValue] of Object.entries(targetMapping)) {\n\t\t\t\t\t\t\t\tconst sourceNestedValue = sourceValue[key];\n\t\t\t\t\t\t\t\tconst nextSubst = extractRecursive(sourceNestedValue, targetValue, resultSubst);\n\t\t\t\t\t\t\t\tif (nextSubst === null) return null;\n\t\t\t\t\t\t\t\tresultSubst = nextSubst;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn resultSubst;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If target is a literal value, check for equality\n\t\t\t\t\t\t\treturn sourceValue === targetMapping ? currentSubst : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Extract each key and unify with corresponding variable/structure\n\t\t\t\t\tlet currentSubst = s;\n\t\t\t\t\tfor (const [key, outputMapping] of Object.entries(mapping)) {\n\t\t\t\t\t\tconst value = inputValue[key];\n\t\t\t\t\t\tconst nextSubst = extractRecursive(value, outputMapping, currentSubst);\n\t\t\t\t\t\tif (nextSubst === null) {\n\t\t\t\t\t\t\t// If any extraction fails, skip this result\n\t\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentSubst = nextSubst;\n\t\t\t\t\t}\n\n\t\t\t\t\tobserver.next(currentSubst);\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t}),\n\t\t);\n}\n\n/**\n * A goal that combines membero() and extract() - iterates over an array and extracts\n * specific keys from each element, creating one substitution per array element.\n *\n * Usage:\n *   extractEach($.array_of_objects, {\n *     name: $.item_name,\n *     age: $.item_age,\n *     email: $.item_email\n *   })\n *\n * This is equivalent to:\n *   membero($.item, $.array_of_objects),\n *   extract($.item, { name: $.item_name, age: $.item_age, email: $.item_email })\n *\n * But more concise and clearer in intent.\n */\nexport function extractEach(\n\tarrayVar: Term,\n\tmapping: Record<string, Term>,\n): Goal {\n\treturn (input$: SimpleObservable<Subst>) =>\n\t\tinput$.flatMap(\n\t\t\t(s: Subst) =>\n\t\t\t\tnew SimpleObservable<Subst>((observer) => {\n\t\t\t\t\tconst arrayValue = walk(arrayVar, s);\n\n\t\t\t\t\t// Input must be resolved to an array\n\t\t\t\t\tif (!Array.isArray(arrayValue)) {\n\t\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For each element in the array, extract the specified keys\n\t\t\t\t\tfor (const element of arrayValue) {\n\t\t\t\t\t\tif (typeof element === \"object\" && element !== null) {\n\t\t\t\t\t\t\t// Extract each key and unify with corresponding variable\n\t\t\t\t\t\t\tlet currentSubst = s;\n\t\t\t\t\t\t\tlet allUnified = true;\n\n\t\t\t\t\t\t\tfor (const [key, outputVar] of Object.entries(mapping)) {\n\t\t\t\t\t\t\t\tconst value = element[key];\n\t\t\t\t\t\t\t\tconst unified = unify(outputVar, value, currentSubst);\n\t\t\t\t\t\t\t\tif (unified !== null) {\n\t\t\t\t\t\t\t\t\tcurrentSubst = unified;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If any unification fails, skip this element\n\t\t\t\t\t\t\t\t\tallUnified = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (allUnified) {\n\t\t\t\t\t\t\t\tobserver.next(currentSubst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t}),\n\t\t);\n}\n","import util from \"node:util\";\n\nconst DEFAULT_CONFIG = {\n  enabled: false,\n  allowedIds: new Set<string>([\n    // \"FLUSH_BATCH\",\n    // \"FLUSH_BATCH_COMPLETE\",\n    // \"GOAL_NEXT\",\n    // \"UPSTREAM_GOAL_COMPLETE\",\n    // \"GOAL_COMPLETE\",\n    // \"GOAL_CANCELLED\",\n    // \"FLUSH_BATCH_CANCELLED_AFTER_QUERY\",\n    // \"FLUSH_BATCH_CANCELLED_DURING_ROWS\",\n    // \"FLUSH_BATCH_CANCELLED_DURING_SUBST\",\n    // \"DB_QUERY_BATCH\",\n    // \"CACHE_HIT\",\n    // \"CACHE_MISS\",\n    // \"UNIFY_SUCCESS\",\n    // \"UNIFY_FAILURE\",\n    // \"GOAL_BATCH_KEY_UPDATED\",\n    // \"ABOUT_TO_CALL_CACHE_OR_QUERY\",\n    // \"CACHE_OR_QUERY_START\",\n    // \"COMPATIBLE_GOALS\",\n    // \"ABOUT_TO_PROCESS_GOAL\",\n    // \"GOAL_GROUP_INFO\",\n    // \"DB_ROWS\",\n    // \"DB_NO_ROWS\",\n    // \"FLUSH_BATCH\",\n    // \"COMPATIBLE_MERGE_GOALS\",\n    // \"DB_QUERY_MERGED\",\n    // \"DB_ROWS_MERGED\",\n    // \"ABOUT_TO_CALL_CACHE_OR_QUERY\",\n    // \"USING_GOAL_MERGING\",\n    // \"USING_GOAL_CACHING\",\n    // \"USING_SUBSTITUTION_BATCHING\",\n    // \"CACHE_PERFORMANCE\",\n    // \"BATCH_PERFORMANCE\",\n    // \"CACHE_HIT_IMMEDIATE\",\n    // \"CACHE_MISS_TO_BATCH\",\n    // \"PROCESSING_CACHE_MISSES\",\n    // \"EXECUTING_QUERY_FOR_CACHE_MISSES\",\n    // \"SINGLE_CACHE_MISS_WITH_GOAL_MERGING\",\n    // \"EXECUTING_UNIFIED_QUERY\",\n    // \"DB_QUERY_UNIFIED\",\n    // \"POPULATING_CACHE_FOR_COMPATIBLE_GOALS\",\n    // \"MERGING_COMPATIBLE_GOALS\",\n    // \"COMPATIBLE_GOALS\",\n    // \"CACHED_FOR_OTHER_GOAL\",\n    // \"CROSS_GROUP_CACHE_CHECK\",\n    // \"OUTER_GROUP_CACHE_POPULATION\",\n    // \"GOAL_STARTED\",\n    // \"FOUND_RELATED_GOALS\",\n    // \"MERGE_COMPATIBILITY_CHECK\",\n    // \"CACHE_COMPATIBILITY_CHECK\",\n    // \"SINGLE_QUERY_COLUMN_SELECTION\",\n    // \"MERGED_QUERY_COLUMN_SELECTION\",\n    // \"GOAL_CREATED\",\n  ]), // empty means allow all\n  deniedIds: new Set<string>([\n    // \"FACT_ADDED\",\n    // \"UNIFY_FAILED\",\n    // \"THIS_GOAL_ROWS\",\n    // \"ALL_GOAL_ROWS\",\n    // \"COMMON_GOALS\",\n    // \"DB_QUERY\",\n    // \"GOAL_CREATED\",\n    // \"SAW_CACHE\",\n    // \"SHARED_GOALS\", // Disabled to reduce noise\n    // \"DB_QUERY\", // Disabled to reduce noise\n    // \"DB_NO_ROWS\",\n    // \"DB_ROWS\",\n    // \"GOAL_CREATED\", // Disabled to reduce noise\n    // \"MERGEABLE_CHECK\", // Disabled to reduce noise\n    // \"PENDING_QUERIES_DEBUG\", // Disabled to reduce noise\n    // \"MERGE_DEBUG\", // Disabled to reduce noise\n    // \"PENDING_ADD\", // Disabled to reduce noise\n    // \"CACHE_HIT\", // Enabled to see cache hits\n    // \"SHARED_UNIFY\", // Enabled to see shared unification\n  ]), // specific ids to deny\n};\n\nexport interface LoggerConfig {\n  enabled: boolean;\n  allowedIds: Set<string>;\n  deniedIds: Set<string>;\n}\n\nexport class Logger {\n  constructor(private config: LoggerConfig) {}\n\n  log(\n    id: string,\n    data: Record<string, any> | string | (() => Record<string, any> | string),\n  ): void {\n    if (!this.config.enabled) return;\n    if (this.config.deniedIds.has(id)) return;\n    if (this.config.allowedIds.size > 0 && !this.config.allowedIds.has(id))\n      return;\n\n    let out: Record<string, any> | string;\n    if (typeof data === \"function\") {\n      out = data();\n    } else {\n      out = data;\n    }\n\n    if (typeof out === \"string\") {\n      console.log(`[${id}] ${out}`);\n    } else {\n      console.log(\n        `[${id}]`,\n        util.inspect(out, {\n          depth: null,\n          colors: true,\n        }),\n      );\n    }\n    // console.log();\n  }\n}\n\nlet defaultLoggerInstance: Logger | null = null;\n\nexport function getDefaultLogger(): Logger {\n  if (!defaultLoggerInstance) {\n    defaultLoggerInstance = new Logger(DEFAULT_CONFIG);\n  }\n  return defaultLoggerInstance;\n}\n","import { isVar, unify, walk } from \"../core/kernel.js\";\nimport type { Subst, Term, Var } from \"../core/types.js\";\nimport type { WhereClause } from \"./types.js\";\n\nexport const queryUtils = {\n\t/**\n\t * Walk all keys of an object with a substitution and return a new object\n\t */\n\twalkAllKeys<T extends Record<string, Term>>(\n\t\tobj: T,\n\t\tsubst: Subst,\n\t): Record<string, Term> {\n\t\tconst result: Record<string, Term> = {};\n\t\tconst keys = Object.keys(obj);\n\n\t\tfor (const key of keys) {\n\t\t\tresult[key] = walk(obj[key], subst);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Walk all values in an array with a substitution\n\t */\n\twalkAllArray(arr: Term[], subst: Subst): Term[] {\n\t\treturn arr.map((term) => walk(term, subst));\n\t},\n\n\t/**\n\t * Check if all query parameters are grounded (no variables)\n\t */\n\tallParamsGrounded(params: Record<string, Term>): boolean {\n\t\tconst values = Object.values(params);\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tif (isVar(values[i])) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Check if all array elements are grounded (no variables)\n\t */\n\tallArrayGrounded(arr: Term[]): boolean {\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif (isVar(arr[i])) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Build query parts from parameters and substitution\n\t */\n\tbuildQueryParts(params: Record<string, Term>, subst: Subst) {\n\t\tconst selectCols = Object.keys(params).sort();\n\t\tconst walkedQ: Record<string, Term> = {};\n\t\tconst whereClauses: WhereClause[] = [];\n\n\t\tfor (const col of selectCols) {\n\t\t\twalkedQ[col] = walk(params[col], subst);\n\t\t\tif (!isVar(walkedQ[col])) {\n\t\t\t\twhereClauses.push({\n\t\t\t\t\tcolumn: col,\n\t\t\t\t\tvalue: walkedQ[col],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectCols,\n\t\t\twhereClauses,\n\t\t\twalkedQ,\n\t\t};\n\t},\n\n\tonlyGrounded<T>(params: Record<string, Term<T>>) {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(params).filter(([key, value]) => !isVar(value)),\n\t\t) as Record<string, T>;\n\t},\n\n\tonlyVars(params: Record<string, Term>) {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(params).filter(([key, value]) => isVar(value)),\n\t\t) as Record<string, Var>;\n\t},\n};\n\nexport const unificationUtils = {\n\t/**\n\t * Unify all selectCols in a row with walkedQ and subst\n\t */\n\tunifyRowWithWalkedQ(\n\t\tselectCols: string[],\n\t\twalkedQ: Record<string, Term>,\n\t\trow: Record<string, any>,\n\t\tsubst: Subst,\n\t): Subst | null {\n\t\tlet s2: Subst = subst;\n\t\tlet needsClone = true;\n\n\t\tfor (let i = 0; i < selectCols.length; i++) {\n\t\t\tconst col = selectCols[i];\n\t\t\tif (!isVar(walkedQ[col])) {\n\t\t\t\tif (walkedQ[col] !== row[col]) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (needsClone) {\n\t\t\t\t\ts2 = new Map(subst);\n\t\t\t\t\tneedsClone = false;\n\t\t\t\t}\n\n\t\t\t\tconst unified = unify(walkedQ[col], row[col], s2);\n\t\t\t\tif (unified) {\n\t\t\t\t\ts2 = unified;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn s2;\n\t},\n\n\t/**\n\t * Unify arrays element by element\n\t */\n\tunifyArrays(\n\t\tqueryArray: Term[],\n\t\tfactArray: Term[],\n\t\tsubst: Subst,\n\t): Subst | null {\n\t\tif (queryArray.length !== factArray.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn unify(queryArray, factArray, subst);\n\t},\n};\n\nexport const patternUtils = {\n\t/**\n\t * Check if all select columns are tags (have id property)\n\t */\n\tallSelectColsAreTags(cols: Record<string, Term>): boolean {\n\t\tconst values = Object.values(cols);\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tif (!(values[i] as any).id) return false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Separate query object into select and where columns\n\t */\n\tseparateQueryColumns(queryObj: Record<string, Term>) {\n\t\tconst selectCols: Record<string, Term> = {};\n\t\tconst whereCols: Record<string, Term> = {};\n\t\tconst entries = Object.entries(queryObj);\n\n\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\tconst [key, value] = entries[i];\n\t\t\tif (isVar(value)) {\n\t\t\t\tselectCols[key] = value;\n\t\t\t} else {\n\t\t\t\twhereCols[key] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectCols,\n\t\t\twhereCols,\n\t\t};\n\t},\n\n\t/**\n\t * Separate array query into select and where terms\n\t */\n\tseparateArrayQuery(queryArray: Term[]) {\n\t\tconst selectTerms: Term[] = [];\n\t\tconst whereTerms: Term[] = [];\n\t\tconst positions: number[] = [];\n\n\t\tfor (let i = 0; i < queryArray.length; i++) {\n\t\t\tconst term = queryArray[i];\n\t\t\tif (isVar(term)) {\n\t\t\t\tselectTerms.push(term);\n\t\t\t\tpositions.push(i);\n\t\t\t} else {\n\t\t\t\twhereTerms.push(term);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectTerms,\n\t\t\twhereTerms,\n\t\t\tpositions,\n\t\t};\n\t},\n\n\t/**\n\t * Separate symmetric query values into select and where - optimized\n\t */\n\tseparateSymmetricColumns(queryObj: Record<string, Term>) {\n\t\tconst selectCols: Term[] = [];\n\t\tconst whereCols: Term[] = [];\n\t\tconst values = Object.values(queryObj);\n\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst value = values[i];\n\t\t\tif (isVar(value)) {\n\t\t\t\tselectCols.push(value);\n\t\t\t} else {\n\t\t\t\twhereCols.push(value);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tselectCols,\n\t\t\twhereCols,\n\t\t};\n\t},\n};\n\nexport const indexUtils = {\n\t/**\n\t * Returns the intersection of two sets\n\t */\n\tintersect<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n\t\tconst result = new Set<T>();\n\t\tsetA.forEach((item) => {\n\t\t\tif (setB.has(item)) {\n\t\t\t\tresult.add(item);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t},\n\n\t/**\n\t * Returns true if a value is indexable (string, number, boolean, or null)\n\t */\n\tisIndexable(v: any): boolean {\n\t\treturn (\n\t\t\ttypeof v === \"string\" ||\n\t\t\ttypeof v === \"number\" ||\n\t\t\ttypeof v === \"boolean\" ||\n\t\t\tv === null\n\t\t);\n\t},\n\n\t/**\n\t * Create an index for a specific position/key\n\t */\n\tcreateIndex<T>(): Map<T, Set<number>> {\n\t\treturn new Map<T, Set<number>>();\n\t},\n\n\t/**\n\t * Add a value to an index\n\t */\n\taddToIndex<T>(index: Map<T, Set<number>>, key: T, factIndex: number): void {\n\t\tlet set = index.get(key);\n\t\tif (!set) {\n\t\t\tset = new Set<number>();\n\t\t\tindex.set(key, set);\n\t\t}\n\t\tset.add(factIndex);\n\t},\n};\n\n// Export individual functions for backward compatibility\nexport const intersect = indexUtils.intersect;\nexport const isIndexable = indexUtils.isIndexable;\n","import { walk } from \"../core/kernel.js\";\nimport { SimpleObservable } from \"../core/observable.js\";\nimport type { Goal, Subst, Term, Var } from \"../core/types.js\";\n\n/**\n * Aggregates all possible values of a logic variable into an array and binds to sourceVar in a single solution.\n */\nexport function aggregateVar(sourceVar: Var, subgoal: Goal): Goal {\n\treturn (input$) =>\n\t\tnew SimpleObservable((observer) => {\n\t\t\tlet active = 0;\n\t\t\tlet completed = false;\n\t\t\tconst subscription = input$.subscribe({\n\t\t\t\tnext: (s) => {\n\t\t\t\t\tactive++;\n\t\t\t\t\tconst results: Term[] = [];\n\t\t\t\t\tlet subgoalEmitted = false;\n\t\t\t\t\tsubgoal(SimpleObservable.of(s)).subscribe({\n\t\t\t\t\t\tnext: (subst) => {\n\t\t\t\t\t\t\tsubgoalEmitted = true;\n\t\t\t\t\t\t\tresults.push(walk(sourceVar, subst));\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: observer.error,\n\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\tconst s2 = new Map(s);\n\t\t\t\t\t\t\ts2.set(sourceVar.id, results);\n\t\t\t\t\t\t\tobserver.next(s2);\n\t\t\t\t\t\t\tactive--;\n\t\t\t\t\t\t\tif (completed && active === 0) observer.complete?.();\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tcompleted = true;\n\t\t\t\t\tif (active === 0) observer.complete?.();\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn () => subscription.unsubscribe?.();\n\t\t});\n}\n\n/**\n * For each unique combination of groupVars, aggregate all values of each aggVar in aggVars, and yield a substitution with arrays bound to each aggVar.\n */\nexport function aggregateVarMulti(\n\tgroupVars: Var[],\n\taggVars: Var[],\n\tsubgoal: Goal,\n): Goal {\n\treturn (input$) =>\n\t\tnew SimpleObservable((observer) => {\n\t\t\tlet active = 0;\n\t\t\tlet completed = false;\n\t\t\tconst subscription = input$.subscribe({\n\t\t\t\tnext: (s) => {\n\t\t\t\t\tactive++;\n\t\t\t\t\tconst groupMap = new Map<string, Term[][]>();\n\t\t\t\t\tsubgoal(SimpleObservable.of(s)).subscribe({\n\t\t\t\t\t\tnext: (subst) => {\n\t\t\t\t\t\t\tconst groupKey = JSON.stringify(\n\t\t\t\t\t\t\t\tgroupVars.map((v) => walk(v, subst)),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlet aggArrays = groupMap.get(groupKey);\n\t\t\t\t\t\t\tif (!aggArrays) {\n\t\t\t\t\t\t\t\taggArrays = aggVars.map(() => []);\n\t\t\t\t\t\t\t\tgroupMap.set(groupKey, aggArrays);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let i = 0; i < aggVars.length; i++) {\n\t\t\t\t\t\t\t\tconst value = walk(aggVars[i], subst);\n\t\t\t\t\t\t\t\taggArrays[i].push(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: observer.error,\n\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\tif (groupMap.size === 0) {\n\t\t\t\t\t\t\t\tconst s2 = new Map(s);\n\t\t\t\t\t\t\t\taggVars.forEach((v, i) => s2.set(v.id, []));\n\t\t\t\t\t\t\t\tobserver.next(s2);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const [groupKey, aggArrays] of groupMap.entries()) {\n\t\t\t\t\t\t\t\t\tconst groupValues = JSON.parse(groupKey);\n\t\t\t\t\t\t\t\t\tconst s2 = new Map(s);\n\t\t\t\t\t\t\t\t\tgroupVars.forEach((v, index) =>\n\t\t\t\t\t\t\t\t\t\ts2.set(v.id, groupValues[index]),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\taggVars.forEach((v, index) => s2.set(v.id, aggArrays[index]));\n\t\t\t\t\t\t\t\t\tobserver.next(s2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactive--;\n\t\t\t\t\t\t\tif (completed && active === 0) observer.complete?.();\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror: observer.error,\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tcompleted = true;\n\t\t\t\t\tif (active === 0) observer.complete?.();\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn () => subscription.unsubscribe?.();\n\t\t});\n}\n"],"mappings":"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","names":["branch","observable","group_by_collecto","group_by_counto","currentSubst","util"]}