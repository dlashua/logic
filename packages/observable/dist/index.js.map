{"version":3,"sources":["../src/operators.ts","../src/observable.ts"],"sourcesContent":["import { type OperatorFunction, SimpleObservable } from \"./observable.js\";\nimport type { Observer, Subscription } from \"./types.js\";\n\ntype ObserverOperator<A, B> = (\n  input$: SimpleObservable<A>,\n) => SimpleObservable<B>;\n\nexport function merge<A, B>(obsB: SimpleObservable<B>) {\n  return (obsA: SimpleObservable<A>) =>\n    new SimpleObservable<A | B>((observer) => {\n      let completed = 0;\n      const subscriptions = [\n        obsA.subscribe({\n          next: (r) => {\n            observer.next(r);\n          },\n          error: observer.error,\n          complete: () => {\n            completed++;\n            if (completed === 2) {\n              observer.complete?.();\n            }\n          },\n        }),\n        obsB.subscribe({\n          next: (r) => {\n            observer.next(r);\n          },\n          error: observer.error,\n          complete: () => {\n            completed++;\n            if (completed === 2) {\n              observer.complete?.();\n            }\n          },\n        }),\n      ];\n\n      return () => {\n        subscriptions.forEach((sub) => sub.unsubscribe());\n      };\n    });\n}\n\nexport function reduce<V>(\n  reducer: (accumulator: V, value: unknown) => V,\n  initialValue: unknown,\n): ObserverOperator<unknown, V> {\n  return (input$: SimpleObservable<unknown>): SimpleObservable<V> =>\n    new SimpleObservable<V>((observer) => {\n      let value: V = initialValue as V;\n      const sub = input$.subscribe({\n        next: (v: unknown) => {\n          value = reducer(value, v);\n        },\n        complete: () => {\n          observer.next(value);\n          observer.complete?.();\n        },\n        error: (e) => observer.error?.(e),\n      });\n\n      return () => sub.unsubscribe();\n    });\n}\n\nexport function map<T, U>(transform: (value: T) => U) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<U>((observer) => {\n      const subscription = input$.subscribe({\n        next: (value) => observer.next(transform(value)),\n        error: observer.error,\n        complete: observer.complete,\n      });\n      return () => subscription.unsubscribe();\n    });\n}\n\nexport function take<T>(count: number) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<T>((observer) => {\n      let taken = 0;\n      let upstreamUnsubscribed = false;\n      const subscription = input$.subscribe({\n        next: (value) => {\n          if (taken < count) {\n            observer.next(value);\n            taken++;\n            if (taken >= count) {\n              observer.complete?.();\n              setTimeout(() => {\n                subscription.unsubscribe();\n                upstreamUnsubscribed = true;\n              }, 0);\n            }\n          }\n        },\n        error: (err) => {\n          observer.error?.(err);\n        },\n        complete: () => {\n          observer.complete?.();\n        },\n      });\n      return () => {\n        if (!upstreamUnsubscribed) {\n          subscription.unsubscribe();\n        }\n        upstreamUnsubscribed = true;\n      };\n    });\n}\n\nexport function filter<T>(predicate: (value: T) => boolean) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<T>((observer) => {\n      const subscription = input$.subscribe({\n        next: (value) => {\n          if (predicate(value)) {\n            observer.next(value);\n          }\n        },\n        error: observer.error,\n        complete: observer.complete,\n      });\n      return () => subscription.unsubscribe();\n    });\n}\n\nexport function flatMap<T, U>(transform: (value: T) => SimpleObservable<U>) {\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<U>((observer) => {\n      const subscriptions: Subscription[] = [];\n      let outerCompleted = false;\n      let activeInnerCount = 0;\n      let scheduledCompletion = false;\n      let fullyComplete = false;\n\n      const checkCompletion = () => {\n        if (outerCompleted && activeInnerCount === 0 && !scheduledCompletion) {\n          scheduledCompletion = true;\n          setTimeout(() => {\n            observer.complete?.();\n            fullyComplete = true;\n          }, 0);\n        }\n      };\n\n      const outerSubscription = input$.subscribe({\n        next: (value) => {\n          activeInnerCount++;\n          const innerObservable = transform(value);\n          const innerSubscription = innerObservable.subscribe({\n            next: observer.next,\n            error: observer.error,\n            complete: () => {\n              activeInnerCount--;\n              checkCompletion();\n            },\n          });\n          subscriptions.push(innerSubscription);\n        },\n        error: observer.error,\n        complete: () => {\n          outerCompleted = true;\n          // Always defer completion check to next microtask\n          setTimeout(() => checkCompletion(), 0);\n        },\n      });\n\n      subscriptions.push(outerSubscription);\n\n      return () => {\n        if (!fullyComplete) {\n          subscriptions.forEach((sub) => sub.unsubscribe());\n        }\n      };\n    });\n}\n\nexport function share<T>(bufferSize: number = Number.POSITIVE_INFINITY) {\n  let observers: Observer<T>[] = [];\n  let subscription: Subscription | null = null;\n  let refCount = 0;\n  let completed = false;\n  let lastError: unknown = null;\n  const buffer: T[] = [];\n\n  return (input$: SimpleObservable<T>) =>\n    new SimpleObservable<T>((observer) => {\n      // Replay all buffered values to new subscribers (logic programming needs deterministic behavior)\n      buffer.forEach((value) => observer.next?.(value));\n\n      if (completed) {\n        if (lastError !== null) {\n          observer.error?.(lastError);\n        } else {\n          observer.complete?.();\n        }\n        return;\n      }\n\n      observers.push(observer);\n      refCount++;\n\n      if (subscription === null) {\n        subscription = input$.subscribe({\n          next: (value) => {\n            buffer.push(value);\n            // Limit buffer size if specified (for memory optimization)\n            if (buffer.length > bufferSize) {\n              buffer.shift();\n            }\n            observers.slice().forEach((o) => o.next?.(value));\n          },\n          error: (err) => {\n            lastError = err;\n            completed = true;\n            observers.slice().forEach((o) => o.error?.(err));\n            observers = [];\n          },\n          complete: () => {\n            completed = true;\n            observers.slice().forEach((o) => o.complete?.());\n            observers = [];\n          },\n        });\n      }\n\n      return () => {\n        observers = observers.filter((o) => o !== observer);\n        refCount--;\n        if (refCount === 0 && subscription) {\n          subscription.unsubscribe();\n          subscription = null;\n          completed = false;\n          lastError = null;\n          buffer.length = 0; // Clean up buffer when no more subscribers\n        }\n      };\n    });\n}\n\nexport function pipe<T>(): OperatorFunction<T, T>;\nexport function pipe<T, A>(op1: OperatorFunction<T, A>): OperatorFunction<T, A>;\nexport function pipe<T, A, B>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n): OperatorFunction<T, B>;\nexport function pipe<T, A, B, C>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n): OperatorFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n): OperatorFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n): OperatorFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n): OperatorFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n): OperatorFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n  op8: OperatorFunction<G, H>,\n): OperatorFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n  op8: OperatorFunction<G, H>,\n  op9: OperatorFunction<H, I>,\n): OperatorFunction<T, I>;\nexport function pipe(\n  // biome-ignore lint/suspicious/noExplicitAny: <unknown type produces bad DX>\n  ...operators: Array<OperatorFunction<any, any>>\n  // biome-ignore lint/suspicious/noExplicitAny: <unknown type produces bad DX>\n): OperatorFunction<any, any> {\n  return (input$) => operators.reduce((prev$, op) => op(prev$), input$);\n}\n","import {\n  filter as filterOperator,\n  flatMap as flatMapOperator,\n  map as mapOperator,\n  merge as mergeOperator,\n  reduce as reduceOperator,\n  share as shareOperator,\n  take as takeOperator,\n} from \"./operators.js\";\nimport type { Observable, Observer, Subscription } from \"./types.js\";\n\nexport type OperatorFunction<T, R> = (\n  source: SimpleObservable<T>,\n) => SimpleObservable<R>;\n\nconst isPromise = (v: unknown): v is Promise<unknown> =>\n  !!v && typeof (v as { then?: unknown }).then === \"function\";\n\nexport class SimpleObservable<T> implements Observable<T> {\n  private producer: (\n    observer: Observer<T>,\n  ) => (() => void) | void | Promise<(() => void) | undefined>;\n\n  constructor(\n    producer: (\n      observer: Observer<T>,\n    ) => (() => void) | void | Promise<(() => void) | undefined>,\n  ) {\n    this.producer = producer;\n  }\n\n  subscribe(observer: Observer<T>): Subscription {\n    let closed = false;\n    let cleanup: (() => void) | undefined = () =>\n      console.log(\"I HAVE NO CLEANUP\");\n\n    const safeObserver = {\n      next: (value: T) => {\n        if (!closed && observer.next) {\n          if (isPromise(value)) {\n            value.then((v) => observer.next(v as T));\n          } else {\n            observer.next(value);\n          }\n        }\n      },\n      error: (error: Error) => {\n        if (!closed && observer.error) {\n          observer.error(error);\n          closed = true;\n        }\n      },\n      complete: () => {\n        if (!closed && observer.complete) {\n          observer.complete();\n          closed = true;\n        }\n      },\n    };\n\n    try {\n      const result = this.producer(safeObserver);\n\n      if (result && typeof result === \"object\" && \"then\" in result) {\n        result\n          .then((asyncCleanup) => {\n            cleanup = asyncCleanup;\n            if (unsubbed && cleanup) {\n              cleanup();\n            }\n          })\n          .catch((error) => {\n            safeObserver.error(\n              error instanceof Error ? error : new Error(String(error)),\n            );\n          });\n      } else {\n        cleanup = result as (() => void) | undefined;\n      }\n    } catch (error) {\n      if (!closed) {\n        safeObserver.error(\n          error instanceof Error ? error : new Error(String(error)),\n        );\n      }\n    }\n\n    let unsubbed = false;\n    return {\n      unsubscribe: () => {\n        if (!unsubbed) {\n          closed = true;\n          unsubbed = true;\n          if (cleanup) {\n            cleanup();\n          }\n        }\n      },\n      get closed() {\n        return closed;\n      },\n    };\n  }\n\n  static of<T>(...values: T[]): SimpleObservable<T> {\n    return new SimpleObservable<T>((observer) => {\n      for (const value of values) {\n        observer.next(value);\n      }\n      observer.complete?.();\n    });\n  }\n\n  static from<T>(values: T[]): SimpleObservable<T> {\n    return SimpleObservable.of(...values);\n  }\n\n  static empty<T>(): SimpleObservable<T> {\n    return new SimpleObservable<T>((observer) => {\n      observer.complete?.();\n    });\n  }\n\n  static fromAsyncGenerator<T>(generator: AsyncGenerator<T>): Observable<T> {\n    return new SimpleObservable<T>((observer) => {\n      let cancelled = false;\n\n      (async () => {\n        try {\n          for await (const value of generator) {\n            if (cancelled) break;\n            observer.next(value);\n          }\n          if (!cancelled) {\n            observer.complete?.();\n          }\n        } catch (error) {\n          if (!cancelled) {\n            observer.error?.(error);\n          }\n        }\n      })();\n\n      return () => {\n        cancelled = true;\n        generator.return?.(undefined as unknown);\n      };\n    });\n  }\n\n  static fromPromise<T>(promise: Promise<T>): Observable<T> {\n    return new SimpleObservable<T>((observer) => {\n      promise\n        .then((value) => {\n          observer.next(value);\n          observer.complete?.();\n        })\n        .catch((error) => observer.error?.(error));\n    });\n  }\n\n  toArray(): Promise<T[]> {\n    let sub: Subscription;\n    return new Promise<T[]>((resolve, reject) => {\n      const values: T[] = [];\n      sub = this.subscribe({\n        next: (value) => values.push(value),\n        error: reject,\n        complete: () => {\n          setTimeout(() => sub.unsubscribe(), 0);\n          resolve(values);\n        },\n      });\n    });\n  }\n\n  firstFrom(): Promise<T> {\n    let sub: Subscription;\n    let settled = false;\n    return new Promise<T>((resolve, reject) => {\n      sub = this.subscribe({\n        next: (value) => {\n          settled = true;\n          resolve(value);\n          setTimeout(() => sub.unsubscribe(), 0);\n        },\n        error: (e) => {\n          settled = true;\n          reject(e);\n        },\n        complete: () => {\n          if (!settled) {\n            reject(new Error(\"NO_VALUE_EMITTED\"));\n          }\n          setTimeout(() => sub.unsubscribe(), 0);\n        },\n      });\n    });\n  }\n\n  lift<V>(\n    next_observable: (input$: SimpleObservable<T>) => SimpleObservable<V>,\n  ): SimpleObservable<V> {\n    return next_observable(this);\n  }\n\n  lastFrom(): Promise<T> {\n    let sub: Subscription;\n    let settled = false;\n    let valueRecevied = false;\n    let finalValue: T;\n    return new Promise<T>((resolve, reject) => {\n      sub = this.subscribe({\n        next: (value) => {\n          valueRecevied = true;\n          finalValue = value;\n        },\n        error: (e) => {\n          settled = true;\n          reject(e);\n        },\n        complete: () => {\n          if (!settled) {\n            if (valueRecevied) {\n              settled = true;\n              resolve(finalValue);\n            } else {\n              settled = true;\n              reject(new Error(\"NO_VALUE_EMITTED\"));\n            }\n          }\n          setTimeout(() => sub.unsubscribe(), 0);\n        },\n      });\n    });\n  }\n\n  // Fluent Operators\n  filter(predicate: (value: T) => boolean) {\n    return filterOperator(predicate)(this);\n  }\n\n  flatMap<U>(transform: (value: T) => SimpleObservable<U>) {\n    return flatMapOperator(transform)(this);\n  }\n\n  map<U>(transform: (value: T) => U) {\n    return mapOperator(transform)(this);\n  }\n\n  merge<R>(other: SimpleObservable<R>): SimpleObservable<T | R> {\n    return mergeOperator<T, R>(other)(this);\n  }\n\n  pipe(): SimpleObservable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): SimpleObservable<A>;\n  pipe<A, B>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n  ): SimpleObservable<B>;\n  pipe<A, B, C>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n  ): SimpleObservable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n  ): SimpleObservable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n  ): SimpleObservable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n  ): SimpleObservable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n  ): SimpleObservable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n  ): SimpleObservable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n  ): SimpleObservable<I>;\n  // biome-ignore lint/suspicious/noExplicitAny: <unknown type produces bad DX>\n  pipe(...operators: OperatorFunction<any, any>[]): SimpleObservable<any> {\n    return operators.length === 0\n      ? this\n      : // biome-ignore lint/suspicious/noExplicitAny: <unknown type produces bad DX>\n        (operators as Array<OperatorFunction<any, any>>).reduce<\n          // biome-ignore lint/suspicious/noExplicitAny: <unknown type produces bad DX>\n          SimpleObservable<any>\n        >((prev$, op) => op(prev$), this);\n  }\n\n  reduce<Q>(\n    reducer: (accumulator: Q, value: unknown) => Q,\n    initalValue: unknown,\n  ) {\n    return reduceOperator<Q>(reducer, initalValue)(this);\n  }\n\n  share(bufferSize: number = Number.POSITIVE_INFINITY) {\n    return shareOperator<T>(bufferSize)(this);\n  }\n\n  take(count: number) {\n    return takeOperator<T>(count)(this);\n  }\n}\n\nexport const observable = <T>(\n  producer: (observer: Observer<T>) => (() => void) | undefined,\n) => new SimpleObservable(producer);\n"],"mappings":";AAOO,SAAS,MAAY,MAA2B;AACrD,SAAO,CAAC,SACN,IAAI,iBAAwB,CAAC,aAAa;AACxC,QAAI,YAAY;AAChB,UAAM,gBAAgB;AAAA,MACpB,KAAK,UAAU;AAAA,QACb,MAAM,CAAC,MAAM;AACX,mBAAS,KAAK,CAAC;AAAA,QACjB;AAAA,QACA,OAAO,SAAS;AAAA,QAChB,UAAU,MAAM;AACd;AACA,cAAI,cAAc,GAAG;AACnB,qBAAS,WAAW;AAAA,UACtB;AAAA,QACF;AAAA,MACF,CAAC;AAAA,MACD,KAAK,UAAU;AAAA,QACb,MAAM,CAAC,MAAM;AACX,mBAAS,KAAK,CAAC;AAAA,QACjB;AAAA,QACA,OAAO,SAAS;AAAA,QAChB,UAAU,MAAM;AACd;AACA,cAAI,cAAc,GAAG;AACnB,qBAAS,WAAW;AAAA,UACtB;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,MAAM;AACX,oBAAc,QAAQ,CAAC,QAAQ,IAAI,YAAY,CAAC;AAAA,IAClD;AAAA,EACF,CAAC;AACL;AAEO,SAAS,OACd,SACA,cAC8B;AAC9B,SAAO,CAAC,WACN,IAAI,iBAAoB,CAAC,aAAa;AACpC,QAAI,QAAW;AACf,UAAM,MAAM,OAAO,UAAU;AAAA,MAC3B,MAAM,CAAC,MAAe;AACpB,gBAAQ,QAAQ,OAAO,CAAC;AAAA,MAC1B;AAAA,MACA,UAAU,MAAM;AACd,iBAAS,KAAK,KAAK;AACnB,iBAAS,WAAW;AAAA,MACtB;AAAA,MACA,OAAO,CAAC,MAAM,SAAS,QAAQ,CAAC;AAAA,IAClC,CAAC;AAED,WAAO,MAAM,IAAI,YAAY;AAAA,EAC/B,CAAC;AACL;AAEO,SAAS,IAAU,WAA4B;AACpD,SAAO,CAAC,WACN,IAAI,iBAAoB,CAAC,aAAa;AACpC,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,UAAU,SAAS,KAAK,UAAU,KAAK,CAAC;AAAA,MAC/C,OAAO,SAAS;AAAA,MAChB,UAAU,SAAS;AAAA,IACrB,CAAC;AACD,WAAO,MAAM,aAAa,YAAY;AAAA,EACxC,CAAC;AACL;AAEO,SAAS,KAAQ,OAAe;AACrC,SAAO,CAAC,WACN,IAAI,iBAAoB,CAAC,aAAa;AACpC,QAAI,QAAQ;AACZ,QAAI,uBAAuB;AAC3B,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,UAAU;AACf,YAAI,QAAQ,OAAO;AACjB,mBAAS,KAAK,KAAK;AACnB;AACA,cAAI,SAAS,OAAO;AAClB,qBAAS,WAAW;AACpB,uBAAW,MAAM;AACf,2BAAa,YAAY;AACzB,qCAAuB;AAAA,YACzB,GAAG,CAAC;AAAA,UACN;AAAA,QACF;AAAA,MACF;AAAA,MACA,OAAO,CAAC,QAAQ;AACd,iBAAS,QAAQ,GAAG;AAAA,MACtB;AAAA,MACA,UAAU,MAAM;AACd,iBAAS,WAAW;AAAA,MACtB;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AACX,UAAI,CAAC,sBAAsB;AACzB,qBAAa,YAAY;AAAA,MAC3B;AACA,6BAAuB;AAAA,IACzB;AAAA,EACF,CAAC;AACL;AAEO,SAAS,OAAU,WAAkC;AAC1D,SAAO,CAAC,WACN,IAAI,iBAAoB,CAAC,aAAa;AACpC,UAAM,eAAe,OAAO,UAAU;AAAA,MACpC,MAAM,CAAC,UAAU;AACf,YAAI,UAAU,KAAK,GAAG;AACpB,mBAAS,KAAK,KAAK;AAAA,QACrB;AAAA,MACF;AAAA,MACA,OAAO,SAAS;AAAA,MAChB,UAAU,SAAS;AAAA,IACrB,CAAC;AACD,WAAO,MAAM,aAAa,YAAY;AAAA,EACxC,CAAC;AACL;AAEO,SAAS,QAAc,WAA8C;AAC1E,SAAO,CAAC,WACN,IAAI,iBAAoB,CAAC,aAAa;AACpC,UAAM,gBAAgC,CAAC;AACvC,QAAI,iBAAiB;AACrB,QAAI,mBAAmB;AACvB,QAAI,sBAAsB;AAC1B,QAAI,gBAAgB;AAEpB,UAAM,kBAAkB,MAAM;AAC5B,UAAI,kBAAkB,qBAAqB,KAAK,CAAC,qBAAqB;AACpE,8BAAsB;AACtB,mBAAW,MAAM;AACf,mBAAS,WAAW;AACpB,0BAAgB;AAAA,QAClB,GAAG,CAAC;AAAA,MACN;AAAA,IACF;AAEA,UAAM,oBAAoB,OAAO,UAAU;AAAA,MACzC,MAAM,CAAC,UAAU;AACf;AACA,cAAM,kBAAkB,UAAU,KAAK;AACvC,cAAM,oBAAoB,gBAAgB,UAAU;AAAA,UAClD,MAAM,SAAS;AAAA,UACf,OAAO,SAAS;AAAA,UAChB,UAAU,MAAM;AACd;AACA,4BAAgB;AAAA,UAClB;AAAA,QACF,CAAC;AACD,sBAAc,KAAK,iBAAiB;AAAA,MACtC;AAAA,MACA,OAAO,SAAS;AAAA,MAChB,UAAU,MAAM;AACd,yBAAiB;AAEjB,mBAAW,MAAM,gBAAgB,GAAG,CAAC;AAAA,MACvC;AAAA,IACF,CAAC;AAED,kBAAc,KAAK,iBAAiB;AAEpC,WAAO,MAAM;AACX,UAAI,CAAC,eAAe;AAClB,sBAAc,QAAQ,CAAC,QAAQ,IAAI,YAAY,CAAC;AAAA,MAClD;AAAA,IACF;AAAA,EACF,CAAC;AACL;AAEO,SAAS,MAAS,aAAqB,OAAO,mBAAmB;AACtE,MAAI,YAA2B,CAAC;AAChC,MAAI,eAAoC;AACxC,MAAI,WAAW;AACf,MAAI,YAAY;AAChB,MAAI,YAAqB;AACzB,QAAM,SAAc,CAAC;AAErB,SAAO,CAAC,WACN,IAAI,iBAAoB,CAAC,aAAa;AAEpC,WAAO,QAAQ,CAAC,UAAU,SAAS,OAAO,KAAK,CAAC;AAEhD,QAAI,WAAW;AACb,UAAI,cAAc,MAAM;AACtB,iBAAS,QAAQ,SAAS;AAAA,MAC5B,OAAO;AACL,iBAAS,WAAW;AAAA,MACtB;AACA;AAAA,IACF;AAEA,cAAU,KAAK,QAAQ;AACvB;AAEA,QAAI,iBAAiB,MAAM;AACzB,qBAAe,OAAO,UAAU;AAAA,QAC9B,MAAM,CAAC,UAAU;AACf,iBAAO,KAAK,KAAK;AAEjB,cAAI,OAAO,SAAS,YAAY;AAC9B,mBAAO,MAAM;AAAA,UACf;AACA,oBAAU,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,OAAO,KAAK,CAAC;AAAA,QAClD;AAAA,QACA,OAAO,CAAC,QAAQ;AACd,sBAAY;AACZ,sBAAY;AACZ,oBAAU,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,GAAG,CAAC;AAC/C,sBAAY,CAAC;AAAA,QACf;AAAA,QACA,UAAU,MAAM;AACd,sBAAY;AACZ,oBAAU,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,WAAW,CAAC;AAC/C,sBAAY,CAAC;AAAA,QACf;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,MAAM;AACX,kBAAY,UAAU,OAAO,CAAC,MAAM,MAAM,QAAQ;AAClD;AACA,UAAI,aAAa,KAAK,cAAc;AAClC,qBAAa,YAAY;AACzB,uBAAe;AACf,oBAAY;AACZ,oBAAY;AACZ,eAAO,SAAS;AAAA,MAClB;AAAA,IACF;AAAA,EACF,CAAC;AACL;AAgEO,SAAS,QAEX,WAEyB;AAC5B,SAAO,CAAC,WAAW,UAAU,OAAO,CAAC,OAAO,OAAO,GAAG,KAAK,GAAG,MAAM;AACtE;;;ACxSA,IAAM,YAAY,CAAC,MACjB,CAAC,CAAC,KAAK,OAAQ,EAAyB,SAAS;AAE5C,IAAM,mBAAN,MAAM,kBAA6C;AAAA,EAChD;AAAA,EAIR,YACE,UAGA;AACA,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,UAAU,UAAqC;AAC7C,QAAI,SAAS;AACb,QAAI,UAAoC,MACtC,QAAQ,IAAI,mBAAmB;AAEjC,UAAM,eAAe;AAAA,MACnB,MAAM,CAAC,UAAa;AAClB,YAAI,CAAC,UAAU,SAAS,MAAM;AAC5B,cAAI,UAAU,KAAK,GAAG;AACpB,kBAAM,KAAK,CAAC,MAAM,SAAS,KAAK,CAAM,CAAC;AAAA,UACzC,OAAO;AACL,qBAAS,KAAK,KAAK;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAAA,MACA,OAAO,CAAC,UAAiB;AACvB,YAAI,CAAC,UAAU,SAAS,OAAO;AAC7B,mBAAS,MAAM,KAAK;AACpB,mBAAS;AAAA,QACX;AAAA,MACF;AAAA,MACA,UAAU,MAAM;AACd,YAAI,CAAC,UAAU,SAAS,UAAU;AAChC,mBAAS,SAAS;AAClB,mBAAS;AAAA,QACX;AAAA,MACF;AAAA,IACF;AAEA,QAAI;AACF,YAAM,SAAS,KAAK,SAAS,YAAY;AAEzC,UAAI,UAAU,OAAO,WAAW,YAAY,UAAU,QAAQ;AAC5D,eACG,KAAK,CAAC,iBAAiB;AACtB,oBAAU;AACV,cAAI,YAAY,SAAS;AACvB,oBAAQ;AAAA,UACV;AAAA,QACF,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,uBAAa;AAAA,YACX,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,UAC1D;AAAA,QACF,CAAC;AAAA,MACL,OAAO;AACL,kBAAU;AAAA,MACZ;AAAA,IACF,SAAS,OAAO;AACd,UAAI,CAAC,QAAQ;AACX,qBAAa;AAAA,UACX,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,QAC1D;AAAA,MACF;AAAA,IACF;AAEA,QAAI,WAAW;AACf,WAAO;AAAA,MACL,aAAa,MAAM;AACjB,YAAI,CAAC,UAAU;AACb,mBAAS;AACT,qBAAW;AACX,cAAI,SAAS;AACX,oBAAQ;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAAA,MACA,IAAI,SAAS;AACX,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,MAAS,QAAkC;AAChD,WAAO,IAAI,kBAAoB,CAAC,aAAa;AAC3C,iBAAW,SAAS,QAAQ;AAC1B,iBAAS,KAAK,KAAK;AAAA,MACrB;AACA,eAAS,WAAW;AAAA,IACtB,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,KAAQ,QAAkC;AAC/C,WAAO,kBAAiB,GAAG,GAAG,MAAM;AAAA,EACtC;AAAA,EAEA,OAAO,QAAgC;AACrC,WAAO,IAAI,kBAAoB,CAAC,aAAa;AAC3C,eAAS,WAAW;AAAA,IACtB,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,mBAAsB,WAA6C;AACxE,WAAO,IAAI,kBAAoB,CAAC,aAAa;AAC3C,UAAI,YAAY;AAEhB,OAAC,YAAY;AACX,YAAI;AACF,2BAAiB,SAAS,WAAW;AACnC,gBAAI,UAAW;AACf,qBAAS,KAAK,KAAK;AAAA,UACrB;AACA,cAAI,CAAC,WAAW;AACd,qBAAS,WAAW;AAAA,UACtB;AAAA,QACF,SAAS,OAAO;AACd,cAAI,CAAC,WAAW;AACd,qBAAS,QAAQ,KAAK;AAAA,UACxB;AAAA,QACF;AAAA,MACF,GAAG;AAEH,aAAO,MAAM;AACX,oBAAY;AACZ,kBAAU,SAAS,MAAoB;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,YAAe,SAAoC;AACxD,WAAO,IAAI,kBAAoB,CAAC,aAAa;AAC3C,cACG,KAAK,CAAC,UAAU;AACf,iBAAS,KAAK,KAAK;AACnB,iBAAS,WAAW;AAAA,MACtB,CAAC,EACA,MAAM,CAAC,UAAU,SAAS,QAAQ,KAAK,CAAC;AAAA,IAC7C,CAAC;AAAA,EACH;AAAA,EAEA,UAAwB;AACtB,QAAI;AACJ,WAAO,IAAI,QAAa,CAAC,SAAS,WAAW;AAC3C,YAAM,SAAc,CAAC;AACrB,YAAM,KAAK,UAAU;AAAA,QACnB,MAAM,CAAC,UAAU,OAAO,KAAK,KAAK;AAAA,QAClC,OAAO;AAAA,QACP,UAAU,MAAM;AACd,qBAAW,MAAM,IAAI,YAAY,GAAG,CAAC;AACrC,kBAAQ,MAAM;AAAA,QAChB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,YAAwB;AACtB,QAAI;AACJ,QAAI,UAAU;AACd,WAAO,IAAI,QAAW,CAAC,SAAS,WAAW;AACzC,YAAM,KAAK,UAAU;AAAA,QACnB,MAAM,CAAC,UAAU;AACf,oBAAU;AACV,kBAAQ,KAAK;AACb,qBAAW,MAAM,IAAI,YAAY,GAAG,CAAC;AAAA,QACvC;AAAA,QACA,OAAO,CAAC,MAAM;AACZ,oBAAU;AACV,iBAAO,CAAC;AAAA,QACV;AAAA,QACA,UAAU,MAAM;AACd,cAAI,CAAC,SAAS;AACZ,mBAAO,IAAI,MAAM,kBAAkB,CAAC;AAAA,UACtC;AACA,qBAAW,MAAM,IAAI,YAAY,GAAG,CAAC;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,KACE,iBACqB;AACrB,WAAO,gBAAgB,IAAI;AAAA,EAC7B;AAAA,EAEA,WAAuB;AACrB,QAAI;AACJ,QAAI,UAAU;AACd,QAAI,gBAAgB;AACpB,QAAI;AACJ,WAAO,IAAI,QAAW,CAAC,SAAS,WAAW;AACzC,YAAM,KAAK,UAAU;AAAA,QACnB,MAAM,CAAC,UAAU;AACf,0BAAgB;AAChB,uBAAa;AAAA,QACf;AAAA,QACA,OAAO,CAAC,MAAM;AACZ,oBAAU;AACV,iBAAO,CAAC;AAAA,QACV;AAAA,QACA,UAAU,MAAM;AACd,cAAI,CAAC,SAAS;AACZ,gBAAI,eAAe;AACjB,wBAAU;AACV,sBAAQ,UAAU;AAAA,YACpB,OAAO;AACL,wBAAU;AACV,qBAAO,IAAI,MAAM,kBAAkB,CAAC;AAAA,YACtC;AAAA,UACF;AACA,qBAAW,MAAM,IAAI,YAAY,GAAG,CAAC;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,OAAO,WAAkC;AACvC,WAAO,OAAe,SAAS,EAAE,IAAI;AAAA,EACvC;AAAA,EAEA,QAAW,WAA8C;AACvD,WAAO,QAAgB,SAAS,EAAE,IAAI;AAAA,EACxC;AAAA,EAEA,IAAO,WAA4B;AACjC,WAAO,IAAY,SAAS,EAAE,IAAI;AAAA,EACpC;AAAA,EAEA,MAAS,OAAqD;AAC5D,WAAO,MAAoB,KAAK,EAAE,IAAI;AAAA,EACxC;AAAA;AAAA,EAiEA,QAAQ,WAAgE;AACtE,WAAO,UAAU,WAAW,IACxB;AAAA;AAAA,MAEC,UAAgD,OAG/C,CAAC,OAAO,OAAO,GAAG,KAAK,GAAG,IAAI;AAAA;AAAA,EACtC;AAAA,EAEA,OACE,SACA,aACA;AACA,WAAO,OAAkB,SAAS,WAAW,EAAE,IAAI;AAAA,EACrD;AAAA,EAEA,MAAM,aAAqB,OAAO,mBAAmB;AACnD,WAAO,MAAiB,UAAU,EAAE,IAAI;AAAA,EAC1C;AAAA,EAEA,KAAK,OAAe;AAClB,WAAO,KAAgB,KAAK,EAAE,IAAI;AAAA,EACpC;AACF;AAEO,IAAM,aAAa,CACxB,aACG,IAAI,iBAAiB,QAAQ;","names":[]}